<html>
<head>

<style type="text/css">
	* {font-family: arial}
	pre {font-family:courier; margin-left:1Em; border-left: 3px solid blue; padding-left: 1Em; font-size: 16pt}
	h1 {padding-top:1Em}
	*.tag {color:black; padding:0.2Em; background-color: orange}
</style>
</head>
<body>


<h1>CFT Change log</h1>

<h3>v2.2.2 2020-12-27 Security</h3>
<p>
	Improved function Db2:GetSessionPassword to read password twice and check for match,
	before saving to Db (encrypted with Sys.secureSessionId) and returning it.
</p>
<p>
	Also added Lib.Util.randomBinary() function, that returns an SHA-1 hash of 
	a string that is sent as parameter + current time as millis + secureSessionId.
</p>


<h3>v2.2.1 2020-12-27 More security</h3>
<p>
	Added function Sys.secureSessionId() which returns a secure Binary. Extended the
	ValueBinary to an optionally safe version, which supports no functions, only to 
	be used as password or salt when encrypting data for storage in databases etc.
</p>
<p>
	Changing Lib.Util.Encrypt and Decrypt to expect Binary value for password, while
	making salt parameter optional, and of type string.
</p>
<p>
	Added check to File.binaryCreate() so it fails if the Binary is marked
	as secure, as the secure session binary must NEVER be exposed, as it
	will protect sensitive content in the database.
</p>
<p>
	Added Db2:GetSessionPassword function, for managing passwords in a secure way
	using the Sys.secureSessionId()
</p>


<h3>v2.2.0 2020-12-27 Password and encryption / Binary values</h3>
<p>
	Added function Sys.readPassword(). It requires the Stdio object to be instance of
	StdioReal (Java), which means it will fail inside parallel processes, example:
</p>
<pre>
$ SpawnProcess(Dict,Sys.readPassword("Enter password")).wait
/x

$ x.exitValue
null

$ x.output
0: Process fails with Exception: [&lt;func&gt; x:22] readPassword() requires StdioReal (java.lang.Exception)
</pre>

<p>
	Added new Value type Binary
</p>

<p>
	Added function String.getBytes() - returns Binary
</p>

<p>
	Added Lib.Util and Lib.Util.Encrypt() and Lib.Util.Decrypt()
</p>

<p>
	Added function process() to Encrypt/Decrypt binary data
</p>
<p>
	Added function processString() to Encrypt/Decrypt (same object), that returns hex string
	when encrypting, for string-only processing
</p>

<pre>
$ Lib.Util.Encrypt("roar","test").processString("roar")
D8EDECF0
$ /x                                             
$ Lib.Util.Decrypt("roar","test").processString(x)
roar
</pre>

<p>
	Added functions File.readBinary and File.binaryCreate
</p>





<h3>v2.1.8 2020-12-21 bugfix: onLoad exceptions</h3>
<p>
	Reporting error if onLoad fails, but still loads the script.
</p>

<h3>v2.1.7 2020-12-15 onLoad</h3>
<p>
	Created onLoad function processing. Example from Projects script:
</p>
<pre>
# Reset selected projects if new session
	if (Db2:Get("Projects","session") != Sys.sessionUUID) {
		Db2:Set("Projects","Project",null)
		Db2:Set("Projects","session", Sys.sessionUUID)
	}
/onLoad
</pre>	

<p>
	Also created CFT.props field globalOnLoad which is run when CFT starts. Calls Lib:GetTerminalSize. 
</p>

<p>
	Renamed old Cfg object to Term as that is what it deals with
</p>

<h3>v2.1.6 2020-11-27</h3>

<p>
	Improved String.synthesize: 
	Using hex encoding only when string contains non-printable characters,
	otherwise falling back to old implementation, for much improved
	readability of synthesized strings.
</p>

<p>
	Improved JSON parser by removing old code and correcting comment on
	Parse() function.

<p>
	Improved display of system log lines, so it respects screen width. Most
	frequently seen via the "help" statement.
</p>



<h3>v2.1.5 2020-11-26 List.filter</h3>
<p>
	Created List.filter which takes a callable (lambda or closure) as parameter,
	which is invoked for each element, 
	and returns list of non-null values.
</p> 

<h3>v2.1.4 2020-11-25 Sys.sessionUUID</h3>
<p>
	Letting the Root class generate a UUID-string, which is available via this
	function. Useful when saving session settings to database.
</p>

<h3>v2.1.3 2020-11-16 String functions</h3>
<p>
	Added toHexString and fromHexString and changed the syntesis function to use
	these. Old values in database with .unEsc will work as before.
</p>
<p>
	The point is to make non-printable characters made possible via Sys.uchar to
	be wrapped safely as printable text.
</p>


<h3>v2.1.2 2020-11-15 AppUI / Cfg / Sys.uchar / Curses script</h3>
<p>
	Created first version of AppUI script for standardizing application user interface in
	terminal.
</p>
<p>
	Changed Cfg.h and .w to return values without printing to stdout first
</p>
<p>
	Added function Sys.uchar() which can be made to produce any Unicode character, by entering
	the hex value. The preceding "\u" is optional. For example we can now produce the ANSI Esc
	character, and control color and cursor.
</p>
<pre>
	Sys.uchar("\u001b")+"[2J"     # print this to clear screen
</pre>
<p>
	Extended Sys.uchar to also allow integer value directly.
</p>
<p>
	Created Script Curses which uses ANSI escape codes for colors, clearing screen,
	and cursor control.
</p>



<h3>v2.1.1 2020-11-14 Error message from Lexer</h3>
<p>
	Fixed function processLine() to maintain internal line counter, to produce more accurate
	error messages for non-file input lines. For lines from files, there is a line number, 
	which the code uses along with file name.
</p>


<h3>v2.1.0 2020-11-14 Made Lambda synthesizable</h3>
<p>
	Also transferred this to Dict objects. 
</p>
<p>
	Note that lambdas added to a Dict are wrapped into Closures, but closures are not
	synthesizable. The Dict synthesis function creates code that adds the Lambda, 
	which just means a Closure object will be created when the code string is eval'ed.
</p>
<p>
	The string representation for lambdas isn't the prettiest, as it is generated from
	the tokens consumed while parsing, not the original character stream. But it works. 
</p>
<p>
	An improvement could be to let every token contain a string of all preceding whitespace,
	and use this to create better formatted synthesized code. Another day.
</p>


<h2 class="tag">2020-11-14 Tagging v2.0.0</h3> 



<h3>v1.9.14 2020-11-13 List.sort etc</h3>
<p>
	Adding a section to the doc about sorting, it became clear that sorting on floats had never
	been implemented. It also has not been missed, but it was a quick fix.
</p>
<p>
	Also had some script updates today, and a fix in Db2 for maintaining high throughput for
	write-intensive cases (not reading the file back to update internal map before needed
	for queries). 
</p>
<p>
	Finally, yesterday evening the ProcessMonitor object was easily integrated into the Hosts
	script, for "apt update / upgrade" and "check out and compile latest CFT version". These
	caused the VM server with 30 VM's being executed simultaneously to spike violently for a long while
	before catching up. Using ProcessMonitor to run 4 parallel jobs at the time, increased
	throughput greatly.
</p>


<h3>v1.9.13 2020-11-12 ProcessMonitor</h3>
<p>
	Added function Util:ProcessMonitor that returns an object with lambdas for flow control when
	running parallel processes, as currently doing APT upgrade on 30 VM's on the same server
	takes forever, because of IO wait. Tried first to write in Java, but CFT was so
	much better suited for the task, with code being 14 lines (same as example of use below).
</p>
<pre>
# Test function
# --
	mon = Util:ProcessMonitor
	Lib.Data.each(0,20)-&gt;x
		mon.Lwait.call(4)
		println("Starting process " + x)
		proc = SpawnProcess(SymDict(x),{
			Sys.sleep(1000+x*100)
		})
		mon.Ladd.call(proc)
		out(proc)
	| _-&gt;proc
		proc.wait
		println("process " + proc.data.x + " done")
/t
</pre>	

<h3>v1.9.13 2020-11-12 File compression</h3>
<p>
	Added File.convertCompressed() which converts between various types of compression, based on
	file name (.z or .gz for GZIP, .zip for ZIP otherwise uncompressed)
</p>
<pre>
	File("x.txt").convertCompressed(File("x.txt.zip"))
	File("x.txt.zip").convertCompressed(File("a.txt"))
	File("x.txt").hash==File("a.txt").hash

	true
</pre>

<h3>v1.9.12 2020-11-06</h3>
<p><b> Hardening Db2</b></p>
<p>
	Should handle parallel access from multiple active CFT processes on same host, by detecting file updates
	and reloading when needed. 
</p>
<p>
	Lots of script updates
</p>
<h4>2020-11-12 emergency fix</h4>
<p>
	Added File functions setWriteLF() and setWriteCRLF to dictate how create() and append() work
</p>
<p>
	Greatly improved JSON parser, and included a PrettyPrinter
</p>
<pre>
	$ JSON:PP
</pre>


<h3>v1.9.11 2020-11-06 Dict .subset() .copyFrom() and global SymDict()</h3>
<p>
	Added Dict.subset(keyList,defaultValue). 
</p>
<p>
	Added Dict.copyFrom(Dict)
</p>
<p>
	Added global expression SymDict() which takes as parameters a list of identifier
	expressions.
</p>
<p>
	Added utility method to Ctx.java : resolveExpr (String s)
</p>

<pre>
a=1 b=2 SymDict(a,b)  # returns Dict with a=1, b=2
</pre>
<p>
	It does this by parsing for identifiers, then executing those as code, which resolves
	to values. It was meant for variables, but also works with output from functions
	without parameters.
</p>
<pre>
$ a=1 b=2 SymDict(a,b,Dir)=>x Util:ShowDict(x)
 &lt;List&gt;
   0: Dir | CFT/ d:11 f:12
   1: a   | 1
   2: b   | 2
</pre>
<p>
	The necessary control over parsing requires this to be a global expression, not a
	member function (in ObjGlobal or elsewhere).
</p>


<h3>v1.9.10 2020-11-05 Added Process.data</h3>
<p>
	This function returns the context data Dict supplied in the original SpawnProcess()
	call.
</p>
<p>
	Updated Doc with comprehensive example for pinging multiple hosts in parallel.
</p>


<h3>v1.9.9 2020-11-04 Process exception handling</h3>
<p>
	If a process terminates with exception, add the full exception log to the
	virtual stdout of the process.
</p>
<p>
	Also verified there is NO invalid direct use of System.out throughout the code.
</p>
<p>
	Added Process.wait() function, which waits until process terminates, and returns self.
	This makes it easy to validate error handling, for example:
</p>
<pre>
	$ SpawnProcess(Dict,xxx).wait.output
 &lt;List&gt;
   0: Process fails with Exception: [input:19] unknown symbol 'xxx'
   1:    rf.configtool.data.LookupOrCall.resolve(LookupOrCall.java:80)
   2:    rf.configtool.data.ExprTerminal.resolve(ExprTerminal.java:177)
   3:    rf.configtool.data.ExprE.resolve(ExprE.java:40)
   4:    rf.configtool.data.ExprD.resolve(ExprD.java:55)
   5:    rf.configtool.data.ExprC.resolve(ExprC.java:54)
   6:    rf.configtool.data.ExprB.resolve(ExprB.java:51)
   7:    rf.configtool.data.ExprA.resolve(ExprA.java:50)
   8:    rf.configtool.data.Expr.resolve(Expr.java:62)
   9:    rf.configtool.main.runtime.lib.ObjProcess$Runner.run(ObjProcess.java:148)
  10:    java.base/java.lang.Thread.run(Thread.java:832)
</pre>
<p>
	Updated doc with example of using wait to collect data from set of processes.
</p>

<h3>v1.9.8 2020-11-03 Obj.clone + SpawnProcess()</h3>
<p>
	Created java function createClone() in the Obj class, and wrapped it as CFT function .clone(),
	which gets inherited by all Obj and Value objects. It works for synthesizable values by
	creating a synthesis string, then executing it, getting a perfect copy.  
</p>
<p>
	Renaming StmtSpawn to ExprSpawnProcess, and the CFT name to SpawnProcess.
</p>
<p>
	Added call to the ObjProcess start() method, which is called by ExprSpawnProcess, to convert the
	content of the Dict parameter to spawn() to the running context of the expression to 
	execute inside the Process. 
</p>
<p>
	Proof of concept
</p>
<pre>
Lib.Data.each(0,3)-&gt;x
	list=List(1,2)
	 
	Dict
		.set("list",list)
		.set("x",x)
		=&gt; data
	SpawnProcess(data, Inner{
		list.add(x)
		println("x=" + x)
		list-&gt;e println("list: " + e)
	}) =&gt; proc
	
	out(proc)
| _=>list
	Sys.sleep(1000)
	list-&gt;x
		println("------")
		x.output->line println(line)
/t
</pre>
<p>
	Tested blocking on input: ok
</p>
<pre>
# test 2̈́
# -
	data = Dict.set("a",1)
	process = SpawnProcess(data,Inner{
		println("Process running")
		x=readLine("Enter number").parseInt
		println("Adding one: " + (x+1))
		# return value
		"goodbye"		
	})

	Sys.sleep(500)
	process.output-&gt;line println("OUTPUT&gt; " + line) |
	line = readLine("Enter line to send to the process")
	process.sendLine(line)
	readLine("Enter to continue reading output from process")
	process.output-&gt;line println("OUTPUT&gt; " + line) |
	println("exitValue: " + process.exitValue)
/t2	


$ t2
OUTPUT&gt; Process running
OUTPUT&gt; (?) Enter number
(?) Enter line to send to the process
33
(?) Enter to continue reading output from process

OUTPUT&gt; Adding one: 34
exitValue: goodbye
  &lt;String&gt;
  exitValue: goodbye

</pre>

<p>
	Testing nested spawns: ok
</p>
<pre>
# test 3
# --
	proc = SpawnProcess(Dict,Dir.files)
	loop
		break(proc.isDone)
		Sys.sleep(1)
		println("tick")
	|
	println("t3 done")
	proc.exitValue
/t3

# test 4
# --
	proc = SpawnProcess(Dict,t3)
	loop
		break(proc.isDone)
		Sys.sleep(1)
		println("tock")
	|
	proc.output-&gt;line println("## " + line) |
	proc.exitValue
/t4


$ t4
tock
tock
tock
tock
## tick
## tick
## tick
## t3 done
  &lt;List&gt;
   0: CFT.props             | 3k  | 3094  | d:&lt;1 | 2020-11-04 13:15:44
       :
       :
</pre>




<h3>v1.9.7 2020-11-03 Stdio</h3>
<p>
	Made Stdio class into an abstract, and created StdioReal and StdioVirtual.
</p>
<p>
	Also added ObjProcess and modified StmtSpawn, but it's not right yet. Still, everything seems to
	work like before. Tagget v1.9.6 at github before checking in this, as a fallback just in case.
</p>


<h2 class="tag">2020-11-02 Tagging v1.9.6</h3> 




<h3>v1.9.6 2020-11-02 Db2Obj script</h3>
<p>
	Added Lib.Db.Db2.collections function. Updated Db2 script.
</p>
<p>
	Created object oriented database, where data are wrapped in a Dict with date and
	a UUID, with a find function using a lambda / closure.
</p>
<p>
	Added Dict.getMany, which takes a list of keys, and returns a list of values, with
	null for missing values.
</p>
<p>
	Modified report() so that if it has one parameter, and its a list, it formats the
	content of that list.
</p>



<h3>v1.9.5 2020-11-02 Lib.Db.Db2</h3>
<p>
	Moved Db2 from Lib to new object/function Lib.Db. Updated the "Db2" script.
</p>
<p>
	Added Lib.Db.UUID function
</p>

<h3>v1.9.4 2020-11-01 spawn()</h3>
<p>
	Added global statement spawn() which takes an expression as parameter, and executes it
	in a separate thread. No return value as of now.
</p>
<pre>
List(1,2,3,4)-&gt;x 
	spawn({
		Sys.sleep(2000)
		println("hello"+x)
	})
/t


Test $ t
  &lt;List&gt;
  (empty)
Test $ hello2
hello4
hello1
hello3
</pre>
<p>
	When Hosts script has been rewritten, its goodbye to Val() and ValDef(). Must presumably also
	do something about Stdio class, and even create a Process-type for these threads.
</p>
<p>
	Done a temporary fix on the Stdio object, making every method synchronized. The long term
	solution is creating individual Stdio instances for each thread, and store it inside the
	Ctx object, hiding the one accessed via ObjGlobal. These instances must properly block on reads,
	and be made available via some Process type.
</p>
<p>
	Renamed return object from Dir.runProcess from "Process" to "ExtProcess". That leaves the Process
	type free for spawn().
</p>
<p>
	Removed Val() and ValDef() from ObjGlobal, as well as from Doc, added text on Db2.
</p>



<h3>v1.9.3 2020-11-01 Val() and ValDef()</h3>
<p>
	Rewritten all code except Hosts script to use Db2 instead of Val() and ValDef(), as
	these will be removed from CFT. The aim is to make the CFT as functional as 
	possible.
</p>


<h3>v1.9.2 2020-11-01 Lib.Db2</h3>
<p>
	Implemented Lib.Db2 database, which connects to thread-safe memory database written
	in Java, persisting to files.
</p>
<p>
	Changed script Db2 to use Lib.Db2 for Set, Get and Keys
</p>


<h3>v1.9.1 2020-11-01 ObjPersistent synchronized</h3>
<p>
	Only two objects extend ObjPeristent: Input and ObjLineReader
</p>
<p>
	Fixed.
</p>


<h2>v1.9.0 2020-11-01 Working towards parallelizing CFT</h2>
<p>
	Looping and PIPE are forbidden inside local blocks, and will result in errors.
</p>




<h3>v1.8.1 2020-10-26 minor adjustments</h3>
<p>
	Renamed SoftException to SoftErrorException
</p>
<p>
	Added check in CondSequence that first parameter resolves to a boolean.
</p>

<p>
	Extended Val() function to take optional default value, which is stored
	if no value found, plus returned.
</p>

<p>
	Dir.create returns self, and throws Exception if failing to create dir
</p>

<p>
	Dict.mergeCodes now optionally takes two parameters, pre and post, which
	if not given, default to "${" and "}" as before.
</p>

<h2>v1.8.0 2020-10-25 java class SoftException</h2>
<p>
	Differing errors into hard and soft.
</p>
</p>
	Created Java class SoftException, and letting global function error() throw 
	SoftException instead of Exception. Created tryCatchSoft() to detect these,
	while passing hard exceptions on, to be caught by tryCatch() or the runtime
	system. 
</p>
<pre>
  tryCatchSoft ()
  ---------------
  ok: true
  result: ANY

  or

  ok: false
  msg: string

  tryCatch ()
  -----------
  ok: true
  result: ANY

  or 

  ok: false
  msg: string
  stack: List of string
</pre>




<h3>v1.7.6 2020-10-25 loop variables</h3>
<p>
	Assigning values to loop variables is forbidden, and now I've added code that
	generates an error if attempted.
</p>

<h3>v1.7.6 2020-10-25 if-expr</h3>
<p>
	After modifying the if-expression into two forms, the (original) inline format and
	the traditional form, the use of expressions only has become a problem:
</p>
<pre>
	# inline form
	if (cond, expr, expr)            # feels natural

	# traditional form
	if (cond) expr [else expr]       # this causes problems
</pre>
<p>
	The problem is that in order to do common things like assigning a variable, or 
	break current loop, the code had to be put inside a block, since blocks are
	expressions that may contain statements.
</p>
<pre>
	if (x>a) {a=x}
	if (x>a) {break}
</pre>
<p>
	This has now been fixed, by letting the if expression look for expressions when
	inline form, and statements in traditional form:
</p>
<pre>
	if (x>a) a=x
	if (x>a) break
</pre>


<h3>v1.7.5 2020-10-24 List.first</h3>
<p>
	Added List.first, working like List.last, both differing from List.nth
	in that they don't produce errors when list is empty or contains too 
	few elements.
</p>


<h3>v1.7.5 2020-10-24 Doc and Readme updated</h3>


<h3>v1.7.5 2020-10-24 Dir.runProcessWait deleted</h3>
<p>
	After introducing the Process return object from Dir.runProcess, the
	runProcessWait() function became redundant.
</p>

<h3>v1.7.5 2020-10-24 Lib.Text.Parser deleted</h3>
<p>
	The skeleton code for Parser has been deleted, as writing a recursive descent
	parser in CFT was rather easy. May want to have another go at processing
	full grammars, but retired the code for now.
</p>



<h3>v1.7.5 2020-10-24 Lib:runProcess</h3>
<p>
	Wrote new function for Lib script, which has same call interface as Lib:run, but runs
	external program in background, and manage it via the new Process object, as well
	as the Dict as object mechanism.
</p>
<p>
	As most of the code came from Lib:run, and as the new code tested ok, Lib:run is now
	implemented by calling Lib:runProcess and then calling the "wait" closure in the
	intermediate Dict object. The call signature of Lib:run is unchanged.
</p>
<p>
	Considering that Dir.runProcess was a hack to fork off Node processes to populate
	MongoDB, with no regard for what happened after, other than regularly reading the stdout
	file to generate statistics, and left to terminate or be killed from the OS, the
	humble Dir.runProcess has come a long way.
</p>



<h3>v1.7.5 2020-10-24 Dict as object</h3>
<p>
	Improved the "primitive objects" implementation by letting Dict.set
	detect Lambdas and wrapping them inside Closures, with current dict
	becoming the "self" object
</p>
<pre>
	Dict
		.set("a",Lambda{self.b.call}) 
		.set("b",Lambda{"this is b"})
		=> x
	x.a.call

	# results in "this is b"
</pre>
<p>
	Further, we also let Dict.set detect Closures, extracting the Lambda
	and rewrapping in new Closure, with current Dict as "self". This means
	obtaining a lambda (really a closure) from one Dict, and storing it
	in another, a new closure is created, so calling it via the new Dict
	means "self" points to it, and not the original Dict.
</p>
<pre>
# Clone dictionary
  P(1)=&gt;orig
  error(getType(orig) != "Dict", "Require Dict")
  new = Dict
  orig.keys->key new.set(key,orig.get(key)) |
  new
/CloneDict

# Test-code
# --
  Dict
  .set("i",1)
  .set("a",Lambda{self.b.call})
  .set("b",Lambda{
    self.set("i",self.i+1)
    self.i
  })
  =&gt; d1
  
  # Clone d1 into d2, then change its state
  CloneDict(d1) =&gt; d2
  d2.set("i",10)

  println("d1.a.call " + d1.a.call)
  println("d1.a.call " + d1.a.call)
  println("d2.a.call " + d2.a.call)
  println("d2.a.call " + d2.a.call)
/test

# Output
#
# d1.a.call 2
# d1.a.call 3
# d2.a.call 11
# d2.a.call 12
</pre>


<h3>v1.7.4 2020-10-22 Lib.Text</h3>
<p>
	Added code to the TokenStream object, to use for parsing JSON
</p>
<p>
	Created first (experimental) JSON parser in CFT, saved under code.examples
</p>


<h3>v1.7.3 2020-10-22 Process object</h3>
<p>
	Modified Dir.runProcess to return a Process object, with functions to 
	detect if process is still alive, obtain its exit code, and destroy it.
</p>
<pre>
# test
	stdin  = Lib:TmpFile("in")
	stdout = Lib:TmpFile("out")
	stderr = Lib:TmpFile("err")

	stdin.create("")
	
	process=Dir.runProcess(stdin,stdout,stderr,"ps -efal".split)
	loop
		println("Waiting")
		Sys.sleep(1)
		break(!process.isAlive)
	|
	println("exitCode=" + process.exitCode)
	stdin.delete
	if(stdout.exists) stdout.delete
	if(stderr.exists) stderr.delete
/t
</pre>

<h3>v1.7.2 2020-10-20 Extend interactive '?' function</h3>
<pre>
	$ ?              show all functions
	$ ?x             show functions x*
	$ ?s:            show all functions in script s
	$ ?s:y           show functions x* in script s
</pre>
<p>
	Also extended List.last() function to take optional count.
</p>
<p>
	Extended comment on PS:Call function, on how to invoke cmd functions like "dir".
</p>

<h3>v1.7.1 2020-10-20 Added -d startup option</h3>
<p>
	Added support for setting custom script directory, with
</p>
<pre>
	./cft -d someDir ...
</pre>
<p>
	Also added support for -help
</p>
<pre>
  ./cft
  ./cft scriptName [commandLines]*
  ./cft -version
  ./cft -help
  ./cft -d scriptDir [scriptName [commandLines]*]?
</pre>

<h2>v1.7.0 2020-10-17 Templating improvement</h2>
<p>
	Added expressions Sequence and CondSequence, which are used to create
	lists, in compact format, and also with separating comma optional.
</p>
<pre>
	Sequence(1,2)+CondSequence(false 3 4)+CondSequence(true 5 6)
	&lt;List&gt;
	1
	2
	5
	6
</pre>

<p>
	Added "RAW" string type, using '@' and extending to end of line. Not particularly suited
	for interactive use, but great for templates. 
</p>
<pre>
	lines = Sequence(
		@ bind:
		@   all
	)+CondSequence(isAlive,
		@ alive:
		@   true
	)+Sequence(
		@ over:
		@   and out
	)
</pre>
<p>
	Lines starting with '@' + space, have the "@ " sequence removed from the start of the line.
	Lines starting with '@@' have that sequence removed from the start of the line.
	For other cases, only the single '@' is stripped.
</p>
<p>
	This is an alternative to the "here" documents using &lt;&lt;&lt; EOF marks, for
	both greater readability, as the text lines can be properly indented, and flexibility
	with conditional sequences of lines.
</p>
<p>
	To test from command line, remember that by default '@' indicates a shortcut.
</p>
<pre>
	$ "" + @ this is a test
	&lt;String&gt;
	this is a test
</pre>





<h3>v1.6.1 2020-10-02</h3>
<p>
	Fixed '?xxx' command so that if exact match, show code, then check for startsWith().
</p>
<p>
	Improved Investigate script with support for topics, so that log files
	are properly named.
</p>

<h2>v1.6.0 2020-10-02 changed syntax for calling function in other script</h2>
<p>
	Added simplified call syntax for calling code in other scripts. 
</p>
<pre>
	call "Script:Function" (...) 

	now is written as

	Script:Function (...)
</pre>
<p>
	Modified all scripts.
</p>


<h3>v1.5.5 2020-10-02</h3>

<p>
	Modified Db script (under code.lib), adding function GUI() to maintain
	data in collection manually, as well as inspect content.
</p>


<h2 class="tag">2020-10-02 Tagging v1.5.4</h3> 


<h3>v1.5.4 2020-09-30 Various changes</h3>
<p>
	Changed return value for Dir.runProcessWait() from self to the exit-code. This makes the function
	thread-safe, in that there is no need to call Sys.lastEPS.
</p>

<p>
	Removing Sys.lastEPS and Sys.lastEPSData as this is an ugly hack. Except for
	ad hoc or interactive runs, for reliability, should always use runProcessWait(),
	as it returns exit code.
</p>
<p>
	Creating a function "Lib:run" that returns Dict, and changing SSH:run to use it,
	adding output filtering on top.
</p>

<p>
	Renamed function Sys.tryUnsafe() to the more logical tryCatch()
	Changed in scripts as well. A useful fu
</p>

<p>
	Added function Dir.setAsCurrentDir to programmatically set working directory.
</p>

<p>
	Various fixes in scripts as a consequence of the above changes, including getting
	MongoHA scrip
</p>


<h3>v1.5.3 2020-09-28 Added start parameter -version</h3>
<p>
	When managing multiple installs automatically, it is nice to
	be able to produce the version string easily.
</p>



<h3>v1.5.2 2020-09-28 Added global function tryUnsafe(expr)</h3>
<p>
	Implemented as global expression ExprTryUnsafe(). Returns Dict
	with fields result, msg, ok, stack, populated according
	to outcome.
</p>



<h3>v1.5.1 2020-09-26 Added global function getType()</h3>
<p>
	Having system libraries use x.?nth to check if x is a list, only works
	if x is a non-empty list. Easier to create one global function that returns the
	same string that is displayed interactively for every result value.
</p>
<pre>
	if (!getType(x)=="List") ...
</pre>

<h2>v1.5.0 2020-09-22 Assignment change</h2>
<pre>
	$ 3=a    # NOW INVALID
	$ 3=>a   # OK
	$ a=3    # OK
</pre>


<h3>v1.4.0 2020-09-15 Lib.Text.Parser</h3>
<p>
	Changed Node.setIsToken() so that tokenType is optional, and defaults to 0, because
	when using the Parser, we often will not care about type, only match / non-match.
</p>
<p>	
	Added Lib.Text.Lexer.Node.addTokenComplex function
</p>

<pre>
Lib.Text.Lexer.Node =date
date.addTokenComplex("iiii-ii-ii", Dict.set("i","0123456789")).setIsToken
</pre>


<h3>v1.3.3 2020-09-14 Lib.Text.Parser</h3>
<p>
	Have by now mostly figured out how the Parser should behave. For CFT we process the complete
	script file (or input line) into tokens first, then run recursive-descent parsing, coded
	in Java, with objects creating objects recursively. The CFT parser uses a lookahead of 1, and
	does not backtrack (the Lexer does).
</p>
<p>
	Creating a generic parser that will be used for both structured data such as JSON or HTML, 
	and processing log-lines with potentially complex and overlapping token definitions, this parser 
	will need to do backtracking. This means lookahead none, supporting multiple productions
	per non-terminal symbol.
</p>
<p>
	The "productions" scheme for grammar representation is inspired by EBNF, which is
	the Extended Backus-Naur Form. which evidently extended BNF by allowing '?', '*' and '+'
	modifiers in the grammar, saving lots of problematic (potentially infinite) recursion.
</p>
<p>
	I've made a further extension in the same direction, allowing not only the above modifiers,
	but for '*' and '+' also allowing reference to a second separator non-terminal that has to
	be matched inbetween repeating instances of the first non-terminal. It complicates the
	implementation a bit, but greatly simplifies the grammar.
</p>
<ul>
	<li>Created Lib.Text.Parser object</li>
	<li>Created Parser.readme</li>
	<li>Created Parser.production (just validates parameters)</li>
	<li>Fixed String.sub from (start,count) to (start,end)</li>
	<li>Checked Lib code: String.sub is never used</li>
</ul>



<h3>v1.3.2 2020-09-13 Lib.Text.Lexer</h3>
<ul>
	<li>Removed Identifier and LPAR, RPAR.</li>
	<li>Renamed function Empty() to Node().</li>
	<li>Added required integer token type parameter to LexerNode.setIsToken().</li>
	<li>Created ObjLexerToken class.</li>
	<li>Created ObjLexer.processLine, which adds tokens to internal list</li>
	<li>Created ObjLexer.getTokens and .getTokenStream to get tokens.</li>
	<li>The processLine function detects if lines were read from file, and
	supplies file name and line number into the source location of tokens.
	</li>
	<li>Created ObjLexerTokenStream class, but its functionality is not clear yet.</li>
	<li>Tested and updated doc</li>
</ul>




<h3>v1.3.1 2020-09-12 Created Dict.invoke</h3>
<p>
	Storing data and lambdas in a Dict, and invoking a lambda via Dict.invoke,
	we have simple objects, as the Dict.invoke calls the lambda with itself
	as the "self" value.
</p>
<h4>Test code</h4>

<pre>
# Creating Dict with data and lambda, calling lambda, inspecting data change
# Also illustrates lambdas calling each other, via the "self" variable.
	Dict
		.set("i",1)
		.set("incr",Lambda{
			self.get("i")+P(1,1) =x 
			self.set("i",x) 
		})
		.set("plus50",Lambda{
			self.invoke("incr",50)
		})
		=data
	
	data.invoke("incr",2)
	println("result=" + data.i)  # 3
	data.invoke("plus50")
	println("result=" + data.i)  # 53
/test2
</pre>


<h3>v1.3.1 2020-09-12 Created Closure</h3>
<p>
	A closure is created by binding a Lambda to a dictionary. It has 
	a .call() function just like a Lambda. When run, the Lambda accesses
	the dictionary via the "self" variable. 
</p>
<p>
	The implementation assures even when a Lambda is invoked directly, 
	not via a Closure object, 
	then the variable "self" points to an empty Dict object.
</p>
<pre>
	# this means that
	Lambda{self}.call
	# returns an empty Dict
</pre>
<h4>
	Initial test code.
</h4>

<pre>
# Function called with Lambda, which in turn gets called on certain condition
	P(1,Lambda{P(1)}) =eventHandler

	readLine("generate event (enter for none)") =val
	if (val != "") {
		eventHandler.call(val)
	}
/eventGenerator



# Function setting up empty data Dict, and Lambda, creating Closure, calling eventGenerator, then reporting result
	Dict =data
	Lambda{
		self.set("value",P(1))
	} =event
	data.bind(event) =closure
	
	event.call("x")  # not invoked via closure - should not access same Dict
	
	eventGenerator(closure)
	if(data.has("value")) {
	  println("event was called: " + data.get("value"))
	} else {
	  println("No event")
	}
/test 	
</pre>


<h2 class="tag">2020-09-12 Tagging v1.3.0</h3> 


<h2>v1.3.0 branch</h2>
<ol>
	<li><b>v1.3.0</b><br/>
	Changed ExprIf from if(cond,a,b) to ?(cond,a,b) and ?(cond,a) eliminating ExprWhen. Converted
	all script code.
</li><li><b>v1.3.0 (b)</b><br/>
	Changed {* ...} blocks to "Lambda {...}" and {...} to "Inner {...}". Converted all script code and
	tested.
</li><li><b>v1.3.0 (c)</b><br/>
	Reverted ?(...) to if(...), and currently mapping both if and when to ExprIf.<br/>
	Also extended parsing of ExprIf to handle two forms: if(expr,expr[,expr]) and if(expr) expr [else expr]
</li><li><b>v1.3.0 (d)</b><br/>
	Renamed ExprMacro to ExprBlock, and ValueMacro to ValueBlock.<br/>
	Added support for three modes: INNER, LAMBDA and LOCAL. Currently
	LOCAL equals INNER, just to get the syntax tested.
</li><li><b>v1.3.0 (e)</b><br/>
	Implemented local block, which is {...} and runs in same context, similar to statements outside the
	block. <br/>
	Looping inside a local block may cause strange effects, as it shares out-data with its
	containing environment. There is nothing preventing use of loops inside local blocks, but it is
	better to do so inside Inner blocks. 

</li><li><b>v1.3.0 (f)</b><br/>
	Modified assert(), reject() and break() to propagate up to first ctx marked with containing a loop.
	See Ctx.setAbortIterationFlag() and .setBreakLoopFlag() 
	<br/>
	Then did some testing, which is included here, as it is useful for understanding how loops
	are controlled, see below. 
	<br/>
	But the following works now:
	<br/>
	loop if(cond) {break(true)}
	<br/>
	Ditto for assert(cond) and reject(cond).
	<br/>
	Changed break to be both unconditional (no params) and conditional. 
	<br/>
	Changed global function error(cond, msg) to make condition optional.
</li></ol>

<p>2020-09-12 branch merged into master</p>

<pre>

List(1,2,3)-&gt;x 
	# Result: b2, c2, b3, c3
	# 
    # The following block is one statement (expression) seen from the loop above,
    # and loops check for loop controls after each statement. So here we get the result
    # we expect
    
    {
    println("juhu")
	assert(x&gt;=2)
	}
	
	List("a","b","c")-&gt;y 
		{assert(y=="b" || y=="c")}
		out(y+x)
	
/Test5


List(1,2,3)-&gt;x 
	# Result: b1, c1, b2, c2, b3, c3
	#
    # The local block makes the following one BIG statement (expression), and as
    # loop checks after each stmt, the result is correct!
    
    {
    println("juhu")
	assert(x&gt;=2)
	
	List("a","b","c")-&gt;y 
		{assert(y=="b" || y=="c")}
		out(y+x)
	}		
/Test6


List(1,2,3)-&gt;x 
    # Unknown symbol y
    #
    # Somewhat insane example, but still useful, because loop variables are
    # (currently) represented differently from function state variables.
    #
	# Loops never extend past '}', and also loop variables are not function
	# state variables. Function state variables are global within function, while
	# loop variables exist in the loop contexts, and the code following the 
	# local block hence does not recognize variable y

    {
	    println("juhu")
		assert(x&gt;=2)
		
		List("a","b","c")-&gt;y 
	}
		{assert(y=="b" || y=="c")}
		out(y+x)
		
/Test7
</pre>

<h3>v1.2.3 2020-09-08</h3>
<p>
	Grep: changed from default 1000 first to 1000 last matches
</p>

<p>
	Lib: removed edit history: buggy + never used. Adjusted CFT.props.
</p>



<h3>v1.2.2 2020-09-06</h3>
<p>
	Improved Hosts script, allowing wildchars. Added file logging for APTUpdate script when failing.
	Added functions CheckSSHKeys and UpdateAPT to Hosts script.
</p>
<p>
	Created Lib function DirPrivate, which replaces direct naming of Sys.homeDir around the code.
</p>
<p>
	Removed log message saying "directory exists" when trying to create a dir that exists.
</p>




<h3>v1.2.1 2020-09-04</h3>
<p>
	Fixed parsing of floats. Made Lib script a bit more robust with regards to "private" directory.
</p>

<h2>v1.2.0 2020-09-03</h2>
<p>
	Added Lib.Text.Lexer functionality, to enable advanced matching of strings. Built on the internal
	rf.configtool.parser.CharSet implementation. Made in preparation for (recursive-descent) line parser 
	implementation, for full logfile processing, etc.
</p>
<p>
	Lib.Text.Lexer functions:
</p>
<pre>
	Test $ Lib.Text.Lexer help
  # Empty(firstChars?) - create Empty node, possibly identifying firstChars list
  # Identifier() - create Identifier node
  # LPAR() - create LPAR node - matches '('
  # RPAR() - create RPAR node - matches ')'
</pre>

<p>
	Examples (from functional testing):
</p>
<pre>

# test 1
	Lib.Text.Lexer.Empty =top
	Lib.Text.Lexer.Identifier =ident
	top.sub(ident)   # first characters of identifier lead to identifier node
	ident.setIsToken

	"this is 2 some test".split-&amp;word
		report(word,top.match(word))
	|
	# should give 4,2,0,4,4
/t1

# test 2
	Lib.Text.Lexer.Empty =top
	"this is a test".split-&amp;word 
		top.addToken(word)=endNode 
		endNode.setIsToken 
	|
	"this is some test".split-&amp;word
		report(word,top.match(word))
	|
	# should return 4 2 0 4
/t2
	
	
# test 3
	Lib.Text.Lexer.Empty =top
	top.addToken("abc")=endNode
	endNode.setIsToken
	println(top.match("abc "))
	# should return 3
/t3

# test 4 - match string in double quotes
	Lib.Text.Lexer.Empty =top
	top.sub('"') =str
	str.setDefault(str)
	str.sub('"') =end
	end.setIsToken
	
	'"this is a test" xyz' =str
	println(top.match(str))
	# Should return 16, which is length of string included quotes 
/t4


# create hex parser
	"0123456789ABCDEFabcdef" =chars
	Lib.Text.Lexer.Empty(chars) =hex
	hex.sub(chars, hex)
	hex
/hex



# Match hex colon hex 
	Lib.Text.Lexer.Empty =top
	hex =h1
	hex =h2
	top.sub(h1)
	h1.sub(":") =colon
	colon.sub(h2)
	h2.setIsToken

	"3a:59d0 is 9a 9a: 9a:94xx".split-&amp;word
		report(word,top.match(word))
	|
	# Should return 7,0,0,0,5
/t5
</pre>


<h3>v1.1.16 2020-09-01</h3>
<p>
	Small script fixes
</p>

<h3>v1.1.15 2020-08-31</h3>
<p>
	Created script Hosts, which processes local Hosts.txt file, enabling
	various forms of automatic maintenance
</p>


<h3>v1.1.14 2020-08-30</h3>
<p>
	Created script Java to install or upgrade to OpenJDK 14 full "jdk" variant.
</p>
<p>
	Also created script APTUpdate to run apt-get update and apt-get upgrade on
	servers, using Db to store date of last run, to avoid frequent repeat runs.
</p>

<h3>v1.1.13 2020-08-29</h3>
<p>
	Moved SSH script file from code.examples to code.lib. Various script cleanup.
</p>


<h3>v1.1.12 2020-08-29</h3>
<p>
	Added Date.Duration.fmt() function
</p>
<p>
	Rewritten SSH script, moved code from ServersMaintenance
</p>

<h3>v1.1.11 2020-08-28</h3>
<p>
	Fixed bug in Db script
</p>

<h3>v1.1.10 2020-08-27</h3>
<p>
	Changed Db script into key/value store with multiple collections
</p>

<h3>v1.1.9 2020-08-26</h3>
<p>
	- Fixed '?ident' so that if matching only one function, all lines are showed.
</p>
<p>
	- Added String.chars() function
</p>
<p>
	- Added List.last() function
</p>
<p>
	- Created Db script under code.lib
</p>

<h3>v1.1.8 2020-08-24</h3>
<p>
	- Added Sys.homeDir() function.
</p>
<p>
	- Modified Investigate script, putting investigation files into "investigate.d" directory under 
	home directory. Breaking logs into files named by date. Adjusted ".gitignore". Removed file
	reference to ".investigate" (old log file in home dir) from Release script.
</p>
<p>
	- Added Dir.unprotect() and File.unprotect(). These require the dir or file to be protected,
	otherwise throwing exception, as these are not to be used routinely.
</p>


<h3>v1.1.7 2020-08-21 Added LastExtProgramStatus java class</h3>
<p>
	Pointer to one such object inside ObjGlobal. Method to clear it, set it
	and get it.
</p>
<p>
	Created function Sys.lastEPS() which returns the status as int, or -999 if undefined. Also
	created function Sys.lastEPSData() which returns Dict or null if undefined.
</p>
<p>
	Implemented for Dir.run() and Dir.runCapture(), plus Dir.runProcessWait()
</p>


<h3>v1.1.6b 2020-08-19 Added Lib.Exp.onCtxClose(macro)</h3>
<p>
	Mostly for testing, but might be nice to have if creating return() statement, acts like
	a finally in Java, except only when no exception ....
</p>
<p>
	Hmm, that's a thing to consider, 
	being able to ensure the code runs even when errors. 
</p>

<h3>v1.1.6b 2020-08-19 Added object Lib.Exp</h3>
<p>
	Created Lib.Exp function/object for experimental code. 
</p>

<h3>v1.1.6a 2020-08-19 Investigate script</h3>
<p>
	Changed text log format, for readability, simplified the commands, and created
	input-mode which loops until entering ".."	
</p>
<p>
	Modified the shortcuts in CFT.props as well
</p>

<h3>v1.1.6 2020-08-14 Small fix on ServersManagement / KVM scripts</h3>
<p>
	Instead of "sudo something" it is safer to do "sudo bash" followed by "something".
</p>

<h3>v1.1.5e 2020-08-11 Renamed Lib.LogFiles to Lib.Files</h3>
<p>
	Will contain tools for all types of file processing
</p>
<p>
	Created Lib.Files.FilterReader (LineReader, Grep), for fast search, shortcutting the need
	to create huge amounts of CFT line objects that will only be thrown away.
</p>

<h3>v1.1.5d 2020-08-08 Grep.line()</h3>
<p>
	Added function that matches single line, for use with LineReader etc
</p>

<h3>v1.1.5c 2020-08-08 Bugfix previous change</h3>

<h3>v1.1.5b 2020-08-08 Improved error handling LineReader</h3>

<h3>v1.1.5a 2020-08-07 Added CtxCloseHook</h3>
<p>
	Letting LineReader register via this hook, via its start() function. Removed LineReader.close() function and
	updated Doc.html.
</p>

<h2 class="tag">2020-08-06 Tagging v1.1.4</h3> 


<h3>v1.1.4 2020-08-06 Lib.LogFiles.LineReader</h3>
<p>
	Created LineReader function and persistent object, for reading lines from a file.
</p>
<p>
	Every time the LineReader() function is invoked for the same file object, it
	is reset to start reading from first line.
</p>


<h3>v1.1.4 2020-08-06 Lib.LogFiles / moved DateSort</h3>
<p>
	Created Lib.LogFiles and moved DateSort into it.
</p>

<h3>v1.1.4 2020-08-05 MongoHA</h3>
<p>
	Added support for a prefix to all host names, so that mcfg1, mcfg2, mcfg3 and so on becomes
	bmcfg1, bmcfg2, ... if prefix is "b". Creating VM's with these names and separate IP-addresses,
	lets us configure multiple MongoDB HA enviroments with the same script.
</p>

<h3>v1.1.4 2020-08-05 Scripts</h3>
<p>
	Added functions to ServersMaintenance to set /etc/hostname and configure /etc/netplan
	for VM's. Added code to the KVM Clone() function to use these, so that it now configures
	the newly created clone then reboots it. 
</p>
<p>
	This means there is no need as such to install CFT on the clone template VM, as
	all initial setup is managed from the outside. The VM script is becoming obsolete.
</p>

<h3>v1.1.4 2020-08-03 Doc</h3>
<p>
	Had to add a section "Fun and strange stuff", since there are a bit of those.


<h2 class="tag">2020-08-03 Tagging v1.1.3</h3> 


<h3>v1.1.3 2020-08-03 various</h3>
<p>
 	- Lib script: Improved menu selection to prefer exact match if possible.
</p>
<p>
	- Created MongoHA script which installs mongodb, mongo shell and mongos on servers in a
	HA configuration (EXPERIMENTAL)
</p>
<p>
	- Created Systemd script, with a function CreateService, called from MongoHA for setting
	up mongos as a service (EXPERIMENTAL)
</p>
<p>
	- Changed syntax for inline lists of text, so that one may use any number 
	of '&lt;' or '&gt;' as long as there as at least three, followed by a space and
	the identifier. This means it gets easier to see the inline text beginning and end.
</p>
<pre>
	&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; EOF
	this is
	some text
	&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EOF
</pre>
<p>
	- Added Dict.hasNullValue() function. Using it to detect if result from PDict() contains
	unmatched parameters.
</p>
<p>
	- Upgraded the Investigate script from experimental to normal, as it is now considered
	useful (and has been used for several days). 
</p>

<h3>v1.1.3 2020-08-02 KVM script</h3>
<p>
	Updated documentation (Readme function).
</p>

<h3>v1.1.3 2020-08-02 :sw</h3>
<p>
	Fixed :sw so that exact match overrides partial match when switching to different
	script.
</p>

<h3>v1.1.3 2020-08-02 DateSort.search()</h3>
<p>
	Created DateFormat.search to locate lines between date/time intervals in log files where lines
	start with date/time. It uses binary search internally, to locate start-point to read from,
	with random access reads. Should be fast even for huge log files.
</p>
<p>
	Example
</p>
<pre>
	Dir(...).protect
	/LogDir

	# Show log lines for 10 minutes
	Input("Date YYYY-MM-DD").get=d
	Input("Time HH:MM:SS").get=t
	Date.parse(d+" "+t).get =startTimeMs
	LogDir.files-&gt;f
		DateSort.search(f,startTimeMs,startTimeMs+10*60*1000)-&gt;line 
			out(line)
	| _=allLines
	DateSort.asc(allLines)
	/Search
</pre>


<h3>v1.1.3 2020-08-01 File.tail</h3>
<p>
	Using RandomAccessFile, calculating a likely offset from end of file. This is done via
	an assumed max line length (in bytes), which defaults to 256. This means the 
	tail() function uses same amount of
	time regardless of file size. If lines are on average longer, then fewer lines will be
	returned.
</p>

<h2 class="tag">2020-08-01 Tagging v1.1.2</h3>


<h3>v1.1.2 2020-08-01 root input loop</h3>
<p>
	Added logic so that input loop displays prompt only when no buffered input lines, as
	with Input.get and readLine()
</p>

<h3>v1.1.2 2020-08-01 SSH script</h3>
<p>
	Improved SSH script so that it creates target .ssh directory if it doesn't exist.
</p>

<h3>v1.1.2 2020-07-31 Doc update</h3>
<p>
	Included the .protect feature earlier, and reorganized a bit
</p>

<h3>v1.1.2 2020-07-31 File.protect / Dir.protect</h3>
<p>
	Made parameter optional, calling it desc instead of "code".
</p>


<h3>v1.1.2 2020-07-31 Improved Investigation script</h3>
<p>
	Standardized file output. Changed shortcuts to lower case.
</p>


<h3>v1.1.2 2020-07-31 Logical bug</h3>
<p>
	!a && !b  failed
</p>
<p>
	Seemed to end up as !(a && !(b)) due to indiscriminate Expr matching. 
</p>
<p>
	Fixed in ExprTerminal, where notExpr is now ExprE instead of Expr. Verified by simple
	truth table listout.
</p>
<pre>
a=true b=true false
a=true b=false false
a=false b=true false
a=false b=false true
</pre>

<h3>v1.1.2 2020-07-31 Colon command overhaul</h3>
<p>
	Improved feedback when typing just ":"
</p>
<p>
	Added :sw which switches between loaded scripts by partial match, or lists all
	available if no (partial) identifier given
</p>


<h3>v1.1.2 2020-07-27 Doc overhaul</h3>
<p>
	Replaced old term "code blocks" with "loop spaces", leaving "block expressions" and macros
	unchanged.
</p>


<h2 class="tag">2020-07-27 Tagging v1.1.1</h3>


<h3>v1.1.1 2020-07-27 created Sys.uptime</h3>
<p>
	Just for fun.
</p>
<p>
	Also fixed some "errror" messages (typos).
</p>


<h3>v1.1.1 2020-07-24 created PropsFile prompt code field</h3>
<p>
	Added code to CFT.props:

	prompt = Sys.scriptName=x if(x==null,"$ ",x+" $ ")
</p>

<h3>v1.1.1 2020-07-24 created Sys.scriptName</h3>
<p>
	Returns script name only - used by prompt script
</p>

<h3>v1.1.1 2020-07-24 moved savefile() to Sys.savefile()</h3>
<p>
	Also makes it return null when not defined, instead of error. Modified the @e shortcut accordingly.
</p>


<h3>v1.1.1 2020-07-24 moved isWindows to Sys.isWindows()</h3>
<p>
	Cleaning up global namespace
</p>

<h3>v1.1.1 2020-07-23 Error handling</h3>
<p>
	Created SourceException which improves error handling, by wrapping non-SourceExceptions into
	SourceExceptions at certain points, getting an indication about where the error occurred also
	for exceptions from inside java libraries, such as trying to read a file that doesn't exist.
</p>


<h3>v1.1.1 2020-07-23 Moved stdin() to Sys.stdin()</h3>
<p>
	The global statement stdin() is now function stdin() inside Sys object, in an effort
	to clear up global name space, and stdin is a natural name for a file parameter
	to Dir.runProcess* functions.
</p>


<h3>v1.1.1 2020-07-22 ServersMaintenance script</h3>
<p>
	Improved this script with new function RemoteCommandSetCoded() to easily categorize
	output from ssh session. The RemoteCommandSet function is improved as well, 
	echoing a marker string, and looking for it in stdout, to eliminate the
	welcome text when logging in. It also returns stderr lines, prefixing output
	lines with (stdout) or (stderr).
</p>


<h3>v1.1.1 2020-07-22 File.tail and .head</h3>
<p>
	Added File.head, and modified File.tail, so both return empty list
	if file doesn't exist, rather than exception.
</p>

<h3>v1.1.1 2020-07-21 Dir.runProcessWait timeout</h3>
<p>
	Added 5 minutes timeout
</p>


<h3>v1.1.1 2020-07-21 Dir.runProcessWait</h3>
<p>
	Functions like .runProcess() but waits for process to terminate. Dir.runProcess() was written
	for a case where we wanted to run up to 100 background node processes, for stress testing. 
	That is a valid use case, so leaving it unmodified, creating new function instead.
</p>


<h2 class="tag">2020-07-21 Tagging v1.1</h3>

<h3>v1.1.0 2020-07-21 P(N,Expr)</h3>
<p>
	Made resolving optional default-value Expr lazy, so only resolved when needed. This allows us to put
	interactive code as default, asking for the value, and saves us a "when (value==null, ...)"
	in the code.
</p>
<pre>
P(1,Input("Enter value").get) =value
</pre>

<h3>v1.1.0 2020-07-21 ServersMaintenance script</h3>
<p>
	Created script for automating apt-get update etc, on a number of hosts, based on
	SSH script for key based ssh (no password) plus adding to /etc/sudoers for
	password-less sudo command. See Readme in SSH script.
</p>
<p>
	Also added @SM shortcut for ServersMaintenance script.
</p>

<h3>v1.1.0 2020-07-21 Sys.sleep(millis)</h3>
<p>
	Added this to enable waiting for completion of external processes
</p>


<h3>v1.1.0 2020-07-21 SSH script</h3>
<p>
	Created script for distributing ssh key to various hosts, for password free login
</p>


<h3>v1.1.0 2020-07-20 Projects script</h3>
<p>
	Improved Projects script message when projects.txt file missing
</p>

<h3>v1.1.0 2020-07-20 debug mode / KVM</h3>
<p>
	Extended the :debug mode into the code, currently logging the source-location of
	each statement and Expr as it gets executed, and used this to find bug in KVM script.
</p>

<h2 class="tag">2020-07-19 Tagging v1.0.17</h3>
<pre>
v1.0.17 is now frozen. Next version is v1.1. 
Changes since v1.0:

	- cd/ls/edit/more 
	- error() function
	- when() expression
	- macros / block expressions
	- Root class handles multiple ObjGlobal 
	- full functionality in macros
	- CFT.props file / source dirs 
	- shell command
	- Dir and File protect
	- symlink awareness, though not fully handled
	- Grep memory use / limits / .fileCount
	- Lib script improvements / terminal size
	- Sys.lastResult / Investigate script (early version)
	- general Projects script
	- shortcuts, particularly @e freeing up symbol 'e' from all scripts

	- various bugs and improvements
</pre>




<h3>v1.0.17 2020-07-18 terminal size</h3>
<p>
	Added shortcut @term to check size of terminal. Had to move the ObjCfg instance from
	ObjGlobal to Root. 
</p>
<p>
	Changed Lib.m() to use system more on Windows as well.
</p>




<h3>v1.0.17 2020-07-18 shortcuts</h3>
<p>
	Added shortcuts feature. Consists of config lines in CFT.props, and handling in
	Root.processInteractiveInput.
</p>

<p>
	Example from CFT.props
</p>
<pre>
# Shortcuts
#
# The shortcuts are lines of code. If that code results in a macro, it is invoked with
# no parameters. Since we don't need parameters, there is really no need for macros
# here. The return value from a shortcut becomes the "last value", available
# via Sys.lastResult, as well as used by :syn etc
#
# Note that shortcuts only work when the prefix is at the start of the interactive
# input line. 
# ---
shortcutPrefix = @

shortcut:r = stdin(":load Release","?")
shortcut:p = stdin(":load Projects","?")

# List available shortcuts when typing '@' only
# ---
shortcut: = File("CFT.props").read-&gt;line assert(line.contains("shortcut:")) out(line)
</pre>
<p>
	This means typing @r on the comand line, loads "Release" script and lists its content
</p>
<p>
	Also moved PropsFile instance from ObjGlobal, which despite its name has multiple
	instances, into Root, which is the new single master object.
</p>
<p>
	And added autoload to PropsFile (called from top of Root.processInteractiveInput.
</p>
<p>
	Even implemented a default shortcut, when typing only @, which lists the shortcuts
	by searching the CFT.props file!!
</p>



<h3>v1.0.17 2020-07-17 Sys.lastResult()</h3>
<p>
	Created Sys.lastResult() function, that returns the last result as stored inside Root, 
	from previous interactive command.
</p>


<h3>v1.0.17 2020-07-17 :new</h3>
<p>
	Created new colon command "new", to create new empty script and set it as current.
</p>

<h3>v1.0.17 2020-07-17 Projects script</h3>
<p>
	Improved Projects script, making file name filtering more explicitly set and cleared.
</p>
<p>
	Removed CRLF
</p>
<pre>
$ :load Projects
$ savefile.read=x savefile.create(x)
</pre>

<h3>v1.0.17 2020-07-17 reload script bug</h3>
<p>
	Fixed minor bug, when deleting a script file that has been loaded, CFT crashed.
</p>


<h3>v1.0.17 2020-07-17 shell() function</h3>
<p>
	Added CFT.props field "winShell" set to "powershell" as default, 
	while keeping the "shell" field, and differentiating between windows and linux
	in the shell() function.
</p>	




<h2 class="tag">2020-07-17 Tagging v1.0.16</h3>


<h3>v1.0.16 2020-07-17 Issue #3</h3>
<p>
	Added Root class, which manages parallel ObjGlobal instances, as
	loaded with :load or when calling functions in other scripts. Handling of interactive
	commands is moved from Runtime to Root. Main and Runtime are both slimmed
	down.
</p>


<h3>v1.0.16 2020-07-15</h3>
<p>
	Created CONTRIBUTING.md file
</p>

<h3>v1.0.16 2020-07-14</h3>
<p>
	Changed Grep, removing .modeCheck and .modeCount, instead creating .fileCount(file)
	along with .file(file). 
</p>
<p>
	Also retiring the .lines() function. Grep is for files.
</p>
<p>
	Adding script Projects to examples, as well as (private) projects.txt
</p>
<p>
	Added DataFile.keys()
</p>
<p>
	Added code.example savefileProjects.txt which is a generic script for searching
	through different projects, as defined in file projects.txt under CFT home directory.
</p>

<h3>v1.0.16 2020-07-12</h3>
<p>
	Changed global error() function to take two parameters: boolean condition and message.
</p>
<p>
	Added newline for readLine. Added common prefix (?) to both readLine() and Input.get()
</p>
<o>
	Moved system messages from OutText to ObjGlobal, ensuring we can present them
	after all interactive processing is complete, for example when Grep.file() passes limits.
</o>

<p>
	Added function Sys.outCount() returning number of values emitted with out(), to do
	cutoffs for huge result sets.
</p>


<h3>v1.0.16 2020-07-11 Grep</h3>
<p>
	Fixed bug so that Grep.file() uses File.getEncoding()
</p>
<p>
	Improved handling of limit, so that if there is a limit, no more than that number of ValueObjFileLine
	are kept in memory at the time.
</p>
<p>
	Also applied a default corresponding to "limitFirst(1000)".
</p>
<p>
	Added Grep.modeCount() which changes .file() and .lines() to return number of matches instead
	of data.
</p>
<p>
	When doing regular search and reaching the limit, a WARNING is issued via the 
	OutText.addSystemMessage()
</p>


<h2 class="tag">2020-07-11 Tagging v1.0.15</h3>


<h3>v1.0.15 2020-07-10 File.encoding</h3>
<p>
	Merged File.setEncoding() into File.encoding, in order to limit number of functions. Tested synthesis ok. 
</p>


<h3>v1.0.15 2020-07-10 cleanup</h3>
<p>
	Cleaned up some scripts. Removed File.isSymLink() as there are getting many functions in File.
	A proper treatment of symlinks will require a separate class. For now, protecting symlink against
	destructive operations will have to do.
</p>

<h3>v1.0.15 2020-07-10 symlink detection</h3>
<p>
	Changed symlink restrictions into using the Protection object, and removed special
	handling for isSymlink(). Also added isSymlink() to Dir. Makes sense to maintain only
	one mechanism for blocking operations.
</p>


<h3>v1.0.15 2020-07-10 cat / edit / more</h3>

<p>
	Created class StmtCatEditMore as subclass of StmtShellInteractive, which implements these 
	three functions (as statements) via macros defined in CFT.props.
</p>
<p>
	Works perfectly. Makes it easy to customize key functionality.
</p>
<p>
	Deleted StmtCat standalone implementation from earlier, as this is a much
	more elegant (and fun) solution.
</p>


<h3>v1.0.15 2020-07-10 StmtShellInteractive</h3>
<p>
	Removed substring matching, now that globbing works as it should, as we're using same tokenizer 
	as for code. Example:
</p>
<pre>
	$ cat a.b
</pre>
<p>
	This is three tokens, "a", "." and "b", and so if there is no match on the concatenation "a.b", then
	doing substrings matching would look for file names containg a and dot and b. Not intuitive!
</p>
<p>
	Updated doc
</p>

<h3>v1.0.15 2020-07-10 File.tail(n)</h3>
<p>
	Added function to get n last lines of file.
</p>

<h3>v1.0.15 2020-07-10 Dir.protect() and File.protect()</h3>
<p>
	Protection is a property that can be set on a file or a directory. Any files and directories 
	derived from it, inherit the protection status. 
</p>
<p>
	A protected directory does not allow create, delete or copy file into dir. This includes blocking 
File.uncompress if target dir is protected.
</p>
<p>
A protected file does not allow delete, create, append, copyFrom (target), copyTo, move (source or target)
</p>




<h2 class="tag">2020-07-10 Tagging v1.0.14</h3>



<h3>v1.0.14 2020-07-09 - ls / cd / cat</h3>
<p>
	Implemented common parent class, StmtShellInteractive.java, for all shell functionality: 
	ls, cd, cat, edit, mkdir, rmdir, touch, rm
</p>
<p>
	Using existing parser still.
</p>
<p>
	Implemented and tested StmtLs, StmtCat, StmtCd
</p>

<h3>v1.0.14 2020-07-08 .runCapture</h3>
<p>
	Removed output to screen for Dir.runCapture()
</p>

<h3>2020-07-08 Lib e2()</h3>
<p>
	Created function e2() which edits a file from history. The history is persisted to file .editHistory
	in home directory. Done in preparation for global edit() command, which perhaps with no args
	can run the "Lib:e2" function.
</p>

<h3>v1.0.13 2020-07-07 Lib.Sys becomes just Sys (namespace)</h3>
<p>
	Renamed "Lib.Sys" into "Sys". Renamed function .sysMsg() to .log(). Moved global .codeDirs() inside.
</p>

<h3>v1.0.13 2020-07-06 shell()</h3>
<p>
	Added global function shell() and configuration field in props-file ("shell")
</p>

<h3>v1.0.12 2020-07-05 condOut()</h3>
<p>
	Like out() but with a conditional expression. For situations where assert/reject isn't suitable,
	for example we want to do more logic. Since out() is not an expression it can not be put inside
	an if() or when(), and also it can not be put inside a macro.
</p>

<h3>v1.0.11 2020-07-05 Props</h3>
<p>
	Added PropsFile class, which reads file "CFT.props". Configures only one field,
	codeDirs, which is a list of directories in sequence to search for script files, when
	loading, and using the first when saving. This means the first directory in the list
	is for work.
</p>

<p>
	Added global function codeDirs() which returns list of code dirs, if one wants to list
	content easily.
</p>
<pre>
	codeDirs->d d.files->f out(f)
</pre>



<h3>v1.0.10b 2020-07-04 Symbolic link</h3>
<p>
	Added symbolic link check on File (using nio). Created function .isSymlink() and added
	check preventing the following to operate when symlink: .delete() .create() .append() .move()
</p>


<h3>v1.0.10 2020-07-04 report() and Macro / block expressions</h3>
<p>
	Needed to clarify how report() works: each code block in a function or macro (logically) executes 
	in a single Ctx object. Each code block is (be definition) one loop space, and depending on whether
	there are looping statements there or not, will return either top-of-stack value, or list of elements 
	from calls to out(). Or report().
</p>
<p>
	Calls to report() are collected after the code block has executed, and are run through the Report
	tools, creating a list of strings, which are then added to the OutData, as if they were
	emitted via out(). Doing calls both to out() and to report() still means the lines from report()
	get added to the end of the OutData list.
</p>
<p>
	This same behaviour has now been implemented for ValueMacro, and verified.
</p>



<h3>v1.0.10 2020-07-04 PIPE in macro and block expression</h3>

<p>
	Renamed non-macro {} to "block expressions", as what is called ProgramLine in the code, and is
	the parts separated by PIPE '|', were called "code blocks" before {} was introduced.
</p>
<p>
	Enabled PIPE inside macros (and block expressions), tested ok
</p>
<p>
	Changed name from "plain text" to system messages in class OutText.
</p>
<p>
	Added function Lib.Sys.sysMsg(str) to test behaviour from macros etc
</p>




<h3>v1.0.9b 2020-07-03 Small fixes</h3>
<p>
	Removed FuncOverrides. It was always an abomination, and has never been needed.
</p>
<p>
	Deleted StmtCat - never used.
</p>



<h3>v1.0.9 2020-07-03 ObjFile encoding + small fixes</h3>
<p>
	Added backslash as valid "special" token. It was missing.
</p>
<p>
	Made Runtime.processInteractiveInput() more robust, in that if parsing fails completely,
	then reporting "next tokens" threw null-pointer-exception.
</p>
<p>
	Adding encoding attribute to ObjFile. (.encoding() and .setEncoding(Str)). Default is
	'ISO_8859_1'. Fixed and tested synthesis. Modifying functions .create .append .read .more,
	tested ok! Updated doc.
</p>


<h3>v1.0.8 2020-07-02 cd improvement</h3>
<p>
	Fixed processing of paths including File.separator, including absolute paths, and
	long relative paths, using the pre-existing tokenizer.
</p>
<p>
	Added Doc sections on "changing directory" and "listing files" at top of
	interactive use section.
</p>
<p>
	Improved Doc on generalized sorting etc.
</p>

<h3>v1.0.7b 2020-07-01 Removed some reporting</h3>
<p>
	Removed calls to outText.addPlainText() in ObjDir and ObjFile for situations that
	are what we expect. 
</p>
<p>
	println() can now be called without args for a simple newline
</p>
<p>
	Updated doc for code blocks, to follow section on conditionals
</p>
<p>
	Tiny modification to StmtIterate.execute() to execute single value iteration
	depending on value.getValAsBoolean() - was just considering boolean false, but 
	null is also boolean false (so is empty list, but that is correctly handled anyway).
</p>
<p>
	After the code parsing improvements, saving a script with "here"-documents from CFT
	replaced the "<<< EOF" notation with the generated List() code. Improved this by introducing
	modes to CodeLine objects: "NORMAL" is the default, and means the line was read from
	file, and is to be executed, as well as written back when saving. Then there's "ORIGINAL", which 
	means line was read from file and will be written to file, but not run, because it has been 
	replaced by one (or more) lines of type "GENERATED", which are run together with the "NORMAL"
	lines, but not saved.
</p>



<h3>v1.0.7 2020-06-30 Macro fixes</h3>
<p>
	Changed default macro into the "local" variant, only now it is known as "code-block", as it
	is resolved automatically. To make "independent" macros, the body must start with an
	asterisk '*' indicating it can run anywhere.
</p>

<pre>

(1) Changing defaults, so {} is now a local macro. The ExprMacro invokes
such a macro immediately, and returns the resulting value.

(2) The "independent" macro is now created as {* ... } where the star means
it can run anywhere. 

Updated Lib

(3) The local macro (or "code block") should run in a context that forwards 
lookups of parameters, but we must prevent outData.programContainsLooping() from
being global for the function. That means moving it into Ctx

(4) Moved it into Ctx, and added flag that stops propagation.

boolean programContainsLooping
boolean programContainsLoopingInfoStopsHere

Created method setProgramContainsLooping() and redirected calls from StmtLoop and StmtIterate.


Created Ctx.subContextForCodeBlock() which creates new sub-context same as sub() but
with separate OutData-object for collecting out(x). 


Seems to work.
</pre>

<h3>v1.0.6b 2020-06-29 Removed Net code</h3>
<p>
	Not in use, no clear idea of how it should work.
</p>
<p>
	Stored in CFT_Extra dir
</p>


<h3>v1.0.6 2020-06-29 Loops in macros</h3>
<p>
	Macros can now contain loops, but not the PIPE functionality.
</p>

<h3>v1.0.5 2020-06-27 ExternalScriptState - cached</h3>
<p>
	When calling function in external script, we want repeated calls to that same script to 
	reuse the same ObjGlobal. This is done by caching ExternalScriptState objects in
	ObjGlobal, allocated on a per-script basis.  
</p>
<pre>
	call "Lib:e" (savefile)
</pre>
<p>
	This means that the above code, which selects a favourite editor, and stores it in
	a ValDef, remembers this on the next call. Also, Input values and other data persisted
	to ObjGlobal are kept.
</p>
<p>
	Should an external script in turn call another external script, this gets cached internally
	in the same way, creating a tree of session states for external scripts.
</p>
<p>
	Updated doc on call expression and all over. Renamed macro mode from "global" to "independent".
</p>

<h2 style="color:blue">2020-06-27 project is "open source" on github</h3>



<h3>v1.0.4 2020-06-26 Modified if() expression</h3>
<p>
	The if() is modified so that when the selected expression resolves
	into a macro, it gets called automatically (once).
</p>


<h3>v1.0.4 2020-06-26 Added expression when()</h3>
<p>
	A simple implementation of multiple choice ("switch").
</p>
<pre>
	when (bool, expr)
</pre>
<p>
	When the first parameter is true, the expr is resolved. If it results in a macro (which is
	a value), then it is called automatically (once). If the boolean expression is false, 
	then the expression is never resolved, and instead null is returned.
</p>


<h3>v1.0.3b 2020-06-25 Fixed bug with CodeInlineDocument</h3>
<p>
	This was rewritten as part of file parsing 2020-06-21
</p>

<h3>v1.0.3 2020-06-24 Added global error() function</h3>
<p>
	Throws Exception, terminating code processing.
</p>


<h3>v1.0.2 2020-06-24 Added Lib.Sys</h3>
<p>
	The Sys object contains two functions: version() and functions()
</p>

<h3>v1.0.1 2020-06-23 cd improved</h3>
<p>
Changed so that if no direct match, cd uses one or more parts to match against 
available directories. This means one can enter one or more substrings of 
the target dir.
</p>

<h2 style="color:blue">2020-06-22 VERSION 1.0</h3>
<p>
	With the robustness added with regards to parsing script files and
	reporting errors, the versioning is changed from dates to numbers.
</p>

<p>
	Improved error reporting for interactive lines and defined functions when
	no script reload is done. Also fixed proper error reporting useing CodeLine.getSourceLocation()
	when Parser.parse() fails.
</p>



<h3>2020-06-21 SourceLocation improvement</h3>
<p>
	Using SourceLocation to report location in script file or
	"single line" just entered, or recently added but without script
	being reloaded (either manually or because of updates in editor).
	</p>
		

<h3>2020-06-21 File parsing / comments</h3>
<p>
	Fixed so that comments are processed correctly when executing code from file,
	by parsing the code as lines, instead of concatenating into a string which is
	then parsed.
	</p>
	
<p>
	Modified line editing command !x:marker!blabla to work only for 
	functions containing a single line of code
	</p>
	
<p>
	Also showing first non-blank line in function list '?', should perhaps contains
	a comment
	</p>
	
<h3>2020-06-14 Macro</h3>
<p>
	Created ExprMacro which is { Stmt* } and which when executed returns a
	ValueMacro object. This is a regular value, though not synthesizable, which
	can be stored in a variable or returned from a function,
</p>
<p>
	To call a macro, invoke the .call function on it, possibly with parameters,
	which are in turn picked up with the usual P() function.
</p>
<p>
	Macros come in two variants: local and global. A local macro has access
	to variables in the caller, and will redefine those when assigning, rather
	than create internal local variables. These macros
	are for internal use inside functions. This means that local variables inside
	the macro should be limited, as they have to be unique to avoid confusion.
</p>
<pre>
	{ &lt;- .... }
</pre>
<p>
	Global macros are scope-isolated macros that do not inherit anything from the caller 
	environment. They can be passed around as parameters, and called by anyone,
	without unfortunate side effects or errors due to missing symbols.
</p>
<pre>
	{ .... }           
</pre>
<p>
	Currently macros do not support loops or the PIPE character.
</p>
<h4>Example: automating data construction</h4>
<pre>
## Projects function
	{
		P(1)=name
		P(2)=path
		P(3)=types
	
		if(path.?trim, Dir(path), path) =path
		if(types.?trim, types.split, types) =types
	
		Dict.set("name",name).set("path",path).set("types",types)
	} =create
	#
	List(
		create.call("Project1", "xyz", "java"),
		create.call("Project2",  "c:\hub", "java txt")
	) 
/Projects
</pre>
<h4>Macros as parameters</h4>
<pre>
P(1,List)=options
P(2,{"name"})=macroGetElementName
	options-&gt;x
		println(macroGetElementName.call(x))
/ShowOptions

P(1,List)=options
P(2,{"name"})=macroGetElementName
	readLine("Enter part of name? ") =sel
	options-&gt;opt
		assert(macroGetElementName.call(opt).contains(sel))
		out(opt)
/SelectOptions
</pre>
<p>
	Here we see generic functions ShowOptions and SelectOptions, which are
	supplied a list of options, and a macro that is invoked on each
	item to produce a name.
</p>
<h4>Calling the above + extending if() expression</h4>
<pre>
Projects =p
	{
		" - " + P(1).get("name")
	} =macroGetElementName
	loop
		println("--------------------")
		println("Available projects")
		println("--------------------")

		ShowOptions (p, macroGetElementName)
		SelectOptions(p, macroGetElementName) =result
		false =breakOuter
		if (result.length==1, { 
			&lt;-
			ValDef("Project", result.nth)
			true =breakOuter
		}.call, 0)
		break(breakOuter)
		println("* Your selection gave " + result.length + " possible options")

/SelectProject
</pre>

<h3>2020-06-11 Added predicate calls: ".?"</h3>
<p>
	Instead of having to write predicate functions like String.isInt, there now
	is a modifier to dotted calls, and a new class DottedCall, invoked from ExprE.
</p>
<pre>
	"sdf".?parseInt
	&lt;boolean&gt;
  	false
</pre>
<p>
	This notation returns error string if there is an exception, otherwise boolean true. 
</p>
<p>
  The predicate calls can also be used to check if a function exists for a value, and
  in this way identify the type of a value, using identity functions, String.isString(), 
  List.isList() and so on. <b>TODO?</b>
</p>



<h3>2020-06-10 Added :NN</h3>
<p>
	Often one wants to access the n'th element of a result list, and ls(N) was created
	for this. Now created colon command, which checks if last result is a List, and then
	synthesizes the indicated element.
</p>
<pre>
	$ ls
	$ :0
</pre>

<h3>2020-06-09 Added Dir.runCapture() </h3>
<p>
	Created Dir.runCapture() which is a copy of Dir.run(), except that it captures output
	and returns a list with the output lines.
</p>
<p>
	The output lines are also sent to the screen, in case the external command asks the user
	for input. Curses-based programs like nano and top are not suited for .runCapture()
</p>

<pre>
	Dir.runCapture("ls")
</pre>

<h3>2020-06-09 Added List.empty() function</h3>

<h3>2020-06-09 Added Global.FileLine() function</h3>
<p>
	This enables full synthesize-functionality of FileLine, rather than inheriting the
	String class version, which is incomplete. Added and tested ValueObjFileLine synthesize()
	method.
</p>

<h3>2020-06-09 Added Version info</h3>
<p>
	Created Version.java class, displayed from Main
</p>

<h3>2020-06-09 fixed bug in String synthesize</h3>
<p>
	Force escaping when string contains newline, cr or tab
</p>

<h3>2020-06-08 P() default value fix</h3>
<p>
	Originally, the default value was only used if the number of parameters given was
	too short. Changed this so that giving null as positional parameter, means using
	the default, if any.
</p>

<h3>2020-06-08 PDict() expression</h3>
<p>
	Added PDict() under ExprTerminal. It takes a comma-separated list of strings, which are mapped to
	the function parameters by position, and returns a Dict object. If more names than
	actual parameters, the value null is stored in the Dict.
</p>
<p>
	The point is to simplify functions performing merging, which uses a dictionary. 
	Also changed the String.merge() function to replace value null with "" (and not just
	blindly getValAsString()).
</p>


<h3>2020-06-08 String.hash</h3>
<p>
	Added hash() function to string.
</p>

<h3>2020-06-08 File.hex \r\n\t</h3>
<p>
	Added detection for CR, LF and TAB, and displaying \r\n\t for those.
</p>

<h3>2020-06-07 negative index to List.nth</h3>
<p>
List.nth(-1) returns last element, .nth(-2) second last and so on
</p>

<h3>2020-06-07 File.hex</h3>
<p>
Renamed from File.hexList, made interactive, fixed bug (omitting display of characters with ascii 127), and
added position col
</p>

<h3>2020-06-07 CharTable</h3>
<p>
Code is used in MVRS, and fails for long strings due to stack overflow. Fixed and tested.
</p>

<h3>2020-06-07 println</h3>
<p>
Global function println
</p>


<h3>2020-06-05 assert/reject in loop</h3>
<p>
Code for checking for assert/reject logic was added for "loop" statement. 
</p>

<h3>2020-06-03 Command line arguments</h3>
<p>
	Renamed the ConfigTool start script to ./cft, and it now supports command line parameters.
	The first is the name of the script file, then follows zero or more strings that are
	executed as if they were regular input.
</p>

<h3>2020-05-24 New master Doc.html</h3>
<p>
The Overview.txt contains disposition of topics
</p>

<h3>2020-03-15 Net routing</h3>
<p>
Routing ok
</p>

<h3>2020-03-08 Net v2</h3>
<p>
Network module v2. Crypto ok. Ping ok.
</p>


<h3>2020-03-06 readLine(prompt)</h3>
<p>
	Reads single text line without any "remembering" previous values as Input does
</p>


<h3>2020-02-28 Stdio</h3>
<p>
	Internal change: created Stdio to replace presence of stdin, stdout and the buffer class
	for input text lines (programmed via stdin("xxx"))
</p>



<h3>2020-02-22 'here' documents</h3>
<p>
	Added notation for converting block of text in savefile to list of strings. 
</p>

<pre>
	&lt;&lt;&lt; marker
	line 1
	line 2
	&gt;&gt;&gt; marker
</pre>

<p>
	This is a source-file feature, not available in the interactive shell, which instead
	offers the function readLines(endMarker)
</p>

<h3>2019-12-20 Float()</h3>
<p>
	Following the template of Int() and Str(), for sorting floating point values
</p>

<h3>2019-11-07 File.readBytes()</h3>
<p>
	Added function readBytes on File object. Great for producing wave diagrams for sound
	recordings (signed).
</p>

<h3>2019-10-30 automatic refresh when savefile changed</h3>
<p>
	Editing files with editors, we now get immediate update
	when the save file is changed on disk.
</p>

<p>
	Keeping the ":load" without file name, though it is redundant.
</p>

<h3>2019-10-20 savefile</h3>
<p>
	Created global function savefile() which returns File object for current savefile.
</p>
<pre>
Dir.runDetach("leafpad",savefile.path)
</pre>


<h3>2019-10-19 List.push()</h3>
<p>
	Created "stack push" function for List, taking the following parameters:
</p>

<pre>
List.push(Count,Default?)
</pre>

<p>
	The Count is the number of elements we want pushed on the stack, and the Default is the
	value to use if list does not contain enough elements. The values can then be assigned
	to local variables in natural order.
</p>

<pre>
$ "x y".split.push(3,"*")=a=b=c a+":"+b+":"+c
  &lt;String&gt;
  x:y:* 
</pre>


<h3>2019-10-19 Dict properties as functions</h3>
<p>
	Setting properties with names that are identifies, that don't collide with existing
	functions, are added as dynamically generated functions, accessible via dotted notation.
</p>

<p>
	Dict.set("a",5)
	/x
	x.a  # gives 5
</p>

<h3>2019-10-18 Cfg.wrap() and :wrap</h3>
<p>
	Added wrap state to Cfg, settable via Cfg.wrap(boolean) and flippable via colon command ":wrap"
</p>

<h3>2019-10-18 Dir.showTree() function</h3>
<p>
	Added Dir.showTree(Dir, LimitKb?) which returns a list of lines with all directories
	under Dir, which contain files, and the sum of sizes of files in those directories is &gt;= LimitKb (defaults to 0). 
</p>

<p>
	Or one can use code
</p>

<pre>
+-----------------------------------------------------
| DFiles  : P(1,Dir)=d 0=n d.files-&gt;f f.length+n=n | n/1024=x ""+x+" kb"
| ShowTree: P(1,Dir).allDirs-&gt;d report(d.path, DFiles(d)) | _.sort
+-----------------------------------------------------
| .       : ShowTree
+-----------------------------------------------------
</pre>

<h3>2019-10-18 isWindows() function</h3>
<p>
	Returns boolean
</p>

<h3>2019-10-17 File.hexList</h3>
<p>
	Create File.hexList() which returns a list of strings displaying the
	content in hex for any file.
</p>


<h3>2019-10-17 cat</h3>
<p>
	Created statement "cat" which follows the format of "cd", in that it either
	takes (Expr) or eats the rest of the line, concatenates it and ends up with
	a file path, which is then dumped directly to output, line by line, no formatting.
</p>

<p>
	When successful, the cat statement puts the file as an ObjFile value on the
	stack.
</p>


<h3>2019-10-17 todo.txt</h3>
<p>
	Due to using text editors for modifying save files, there is no longer much point in
	creating advanced line editing functions. Even on a CLI one can always invoke "nano"
	or similar.
</p>

<p>
	Also, due to Dir.runDetach, the use of editors also reduce the need for 
	advanced File.more, as it is easier to search and page around in an editor. 
</p>


<h3>2019-10-16 Cfg.w / .getScreenWidth / Grep.file()</h3>
<p>
	Lines from files, must have TAB substituted with spaces. Using existing code
	written for File.more, moved it to rf.configtool.util.TabUtil, and
	now integrated it into Grep, for cleaner result lists still.
</p>
<p>
	Also added the same conversion on File.read, converting tabs to spaces, as 
	file reading is primarily about displaying data. Note that DataFile is not
	modified, as it is used to produce output files, and no conversion of tabs
	should take place there.
</p>

<h3>2019-10-15 Cfg.w / .getScreenWidth / displaying result</h3>
<p>
	Added code to respect this (Runtime.processInteractiveInput()), after making
	Report class return list of strings, rather than writing to stdout itself. 
</p>


<h3>2019-10-15 call() finalized</h3>
<p>
	The call statement is now the call expression, and its syntax is extended:
</p>

<pre>
	call "savefile:function" [ with(Dict) ] Params?
</pre>

<p>
	And it all works, and is a way to reuse code while overriding functions with values, 
	as long as those values can be synthesized into strings.
</p>

<pre>
+-----------------------------------------------------
| a   : 5
| b   : "hei"+a
| d   : Dict.set("a","xxx")
| test: call "test:b" with (d)
+-----------------------------------------------------
| .   : test
+-----------------------------------------------------
Current save name: test
$ test
  &lt;String&gt;
  heixxx 
$
</pre>

<p>
	The same mechanism will be handy when invoking from the command line, wrapping each
	value into ValueString, then synthesizing, to ensure valid code. 
</p>

<p>
	Implementation details:  rf.configtool.main.CallScriptFunc is the gateway.
</p>




<h3>2019-10-13 list becomes List</h3>
<p>
	The list function is renamed to List.
</p>

<p>
	To identify needed changes:
</p>
<pre>
$ Dir.files(Glob("savefile*"))-&gt;f Grep("list").file(f) -&gt;line out(line)
</pre>


<h3>2019-10-12 cd / ls</h3>
<p>
	As cd is used interactively, it was easy to fix it, just scanning the rest
	of the input, and concatenating a path string. Also eliminated the name "dir",
	and added two more names, so that
</p>

<ol>
	<li>"ls" - list of directories and files</li>
	<li>"lsf" - list of files</li>
	<li>"lsd" - list of directories</li>
</ol>


<h3>2019-10-06 savefile format</h3>
<p>
	Created v2 savefile format, which is readable and editable. It is identified
	by first line of file being #v2. Also modified '?' command to display code in
	the same order as in the save file. Multi-line code is supported on read, and 
	is preserved when saved, except for functions that have been changed. 
</p>

<p>
	But even for modified functions, we preserve original lines preceding the function,
	if such exist.
</p>

<p>
	Also modified updates so that the original order is maintained.
</p>

<p>
	And finally modified the ":load" command so that identifier is optional, except
	for the very first time, as reload after modifications to save file will now
	be required.
</p>

<h3>2019-10-01 debug</h3>
<p>
	Added statement debug(expr), to display text directly.
</p>

<h3>2019-10-01 loop / break</h3>
<p>
	Created loop statement, which loops forever, until break(true) is invoked. Note that
	break can also be applied when iterating over a list value with "expr-&gt;..."
</p>

<p>
	Created in anticipation of FileReader, which reads single lines from files, for 
	filtering huge log files.
</p>

<h3>2019-09-26 changed local variable scope rules</h3>
<p>
	Introduced java class FunctionState, which contains both function parameters, and
	all variables assigned via "=x". This allows for more logical constructs such as
	</p>

<pre>
	$ 0=sum list(1,2,3)->x sum+x =sum | sum   # <-- returns 6
</pre>

<h3>2019-09-15 global Cfg object</h3>
<p>
	Created Cfg object, available via global function by same name. It currently contains the 
	following variables:
</p>
<ol>
	<li>'h' - height of screen - default 24</li>
	<li>'w' - width of screen - default 130</li>
	<li>'wd' - wrap data output - default true</li>
	<li>'wm' - wrap more lines - default false</li>
</ol>
</p>

<h4>Currently implemented</h4>
<ul>
	<li>the '?' command - respects 'w'</li>
	<li>the showCode() function - respects 'w'</li>
</ul>
</p>


<h3>2019-09-15 list.insert</h3>
<p>
	Added function insert(pos,val) on list, doing destructive modification on self().
</p>

<h3>2019-09-14 list.set</h3>
<p>
	Added function set(pos,val) on list, doing a destructinve modification on self()
</p>

<h3>2019-09-15 list.remove</h3>
<p>
	Added function remove(pos) on list, doing a destructive change on self(), constituting
	the opposite of add() which also modifies the instance itself (and which is important when
	using Val() to repeatedly refer to same object).
</p>

<h3>Manual entry - example</h3>
<p>
	Using readLines to paste in for example a netplan file, followed by a ":syn" to create an
	actual list value. Then use replace to replace for instance an IP address with a merge
	code.
</p>

<h3>2019-09-14 list.replace</h3>
<p>
	Added function replace(str1,str2) for the list value object. It traverses the list
	and reads each value as string, then replaces str1 with str2. Returns new list.
</p>

<h3>2019-09-14 readLines</h3>
<p>
	Added global function readLines(endmarker) which reads input lines until label found on separate line.
	Returns a list, which must be synthesized (with :syn) to be useful. Nice for creating a list
	of strings from a text file that is copy-pasted into the window, followed by manually
	entering the endmarker.
</p>
<p>
	2019-10-17 renamed from original name "cat", as "cat" is now used to list a file.
</p>



<h3>2019-09-04 Dir.run()</h3>

<p>
	Run external commands. Uses redirecting of stdin, stdout and stderr. This means
	we get to interact with external programs, but not buffer input via the stdin()
	mechanism. For that we must probably implement some threads.
</p>

<pre>
	$ Dir.run("ls")
	$ Dir.run("ls","-l")
	$ list("ls","-l")
	$ /cmd
	$ Dir.run(cmd)
</pre>

<h3>2009-09-04 File.move()</h3>
<p>
	Implemented .move(File) to rename and/or move a file. Returns self or throws
	Exception. 
</p>

<h3>2009-09-04 Dict.setStr() and .mergeCodes()</h3>

<p>
	Added setStr() function to Dict, which parses string on format "xxx : yyy" or "xxx = yyy", and
	puts value "yyy" in dictionary under key "xxx" (both trimmed).
</p>

<p>
	Also added function mergeCodes() that returns copy where all keys are modified into ${key},
	for use as merge codes.
</p>

<h3>2019-09-04 DataFile upgrades</h3>

<p>
	DataFile supports comment lines to be excluded.
</p>

<pre>
	$ DateFile(File("x.txt"),"###").comment(";")
	$ /df
</pre>

<h3>2019-09-02 Dict.get default value</h3>

<p>
	Added optional default value for Dict.get(name), so that when no value is found for name,
	the default value is added to the dictionary, under the given name, and then returned.
</p>

<p>
	This enables compact code:
</p>

<pre>
	$ P(1,Dict)=d d.get("lines",list).add("hello")
</pre>

<h3>2019-09-02 Session Values</h3>

<p>
	Created two global functions, for maintaining session values. These let us instantiate
	a Dict or list object that does not go away until explicitly reset, which can be
	referred via simple code:
</p>

<pre>
	$ ValDef("x",list)
	$ /Init

	$ Val("x")
	$ /x

	$ x.add(1)
	$ x.add(2)
	$ x.sum
	  3
</pre>

<p>
	Persistent values can are cleared by redefining them to null, which is the default
	value when trying to get a value that doesn't exist.
</p>

<pre>
	$ ValDef("x",list)
</pre>


<h3>2019-09-02 String .esc and .unEsc</h3>
<p>
	Needed a more robust synthesize method for strings, so added two functions to String, which
	escapes all dangerous characters (even including space) and the reverse function. 
</p>

<p>
	Changed the synthesize method of ValueString, so that when string contains both types of quotes,
	it returns the escaped string in regular quotes, followed by .unEsc, thus generating code 
	that restores the actual string.
</p>


<h3>2019-06-28 Input history</h3>

<p>
	Added history over the last 100 entered values, accessed via
</p>

<pre>
	:       -- list numbered options
	:N      -- use numbered option
	::sdf   -- text starting with colon
</pre>



<h3>2019-06-25 Remote Server and Client</h3>
<p>
	Created a remote server that listens to a port, and a remote client that
	connects to a remote server on an address and port. Currently no 
	gentle way of leaving the connection, but apart from that it works
</p>

<pre>
	Net.RemoteServer(2500).init

	Net.RemoteClient("localhost",2500).connect

	[localhost] $
</pre>

<p>
	TODO
</p>

<ol>
	<li>put connection into the background, where it receives output and buffers it
	internally, to be displayed later when put into foreground</li>
	<li>Need a way of regaining control of the local process, f.ex via command ":local"</li>
	<li>Must also have a way of displaying connections, closing connections and activating background connection</li>
	<li>Running connections in the background gives us a multitasking ability with, when
		connecting localhost and running code there
	</li>
</ol>

<h3>2019-06-18 uncompress compressed files</h3>
<p>
	Added File.uncompress(targetDir). Using old FileInfo class. It is not sophisticated, but it
	solved a problem. Copies uncompressed files unchanged
</p>

<h3>2019-05-31 Lib.Net</h3>
<p><b>2019-06-25: moved to GlobalObj</b></p>
<p>
	Want to use ConfigTool to push data over networks, possibly extending to full
	remote control. Added the following functions, which allows us to set up a server
	listening on a TCP server port, and using a client to push files over the network
	to such servers. 
</p>

<pre>
	Net.PushServer(2500).init    # sets up tcp server on port 2500

	Net.PushClient("127.0.0.1",2500)  # creates client
	/c

	c.push(File)
	c.push(File,"targetName")
	c.remoteDir("xxx")
</pre>

<h3>2019-05-30 Grep takes regex</h3>

<p>
	Added two functions to Grep: matchRegex(re) and rejectRegex(re)
</p>

<h3>2019-05-30 String matching</h3>
<p>
	Added functions for locating substrings
</p>

<pre>
	"abcd".before("c")
	"ab"

	"abcd".after("b")
	"cd"

	"abcd".between("a","d")
	"bc"

	"abbb".beforeLast("b")
	"abb"

	"aaab".afterLast("a")
	"b"
</pre>

<h3>2019-04-04 Regex handling</h3>
<p>
	Created class Regex under runtime.lib, with a single static method for building RegEx from strings. Using
	this method from <i>ObjGlob</i>.
</p>
<p>
	Also modified inner workings of old class <i>ObjFilter</i> to build internal list of RE's, using Regex class. This allows
	for more sophisticated filtering, as multiple contains("xxx") operate with logical AND between them, 
	plus that Filter has support for case sensitive on/off. Added method for adding RE directly.
</p>

<p>
	<i>TODO: upgrade ObjGrep to use RE's internally?</i>
</p>

<h3>2019-03-22 syn() function</h3>
<p>
	In preparation for creating multiline scripts, as well as for general flexibility, I've added
	the global syn() function, which takes a synthesizable value, and returns as a string the code
	that creates it. If the value can not be synthesized, an error is reported.
</p>

<p>
	Also added String.indexOf() function for improved parsing.
</p>


<h3>2019-02-17 Function.java </h3>

<p>
	(2019-03-13 updated)
</p>

<p>
	As part of creating a Gui class which should contain interactivity, we needed to extend the callFunction()
	of the Function class, as invoked from LookupOrCall.resolve(). Created a parallel method, called callFunctionNew(), 
	which by default calls the callFunction() method, which is now defined in Function.java throwing exception.
</p>

<p>
	The callFunctionNew() takes Ctx object instead of TextIn and TextOut, which are anyway direct properties of the
	Ctx object. 
</p>

<p>
	Also extended the CommandProcessor interface to include the method processProgramLine.
</p>

<p>
	In sum this makes it possible to create code that executes code. The first example is the Gui.button("name","code"), which
	when having its "clicked" function called, executes the "code", using the CommandProcessor.processProgramLine() method. This
	method returns a value, which becomes the return value from the clicked() method. This of course exemplifies how an
	eval("str") function should work.
</p>

<p>
	So obviously eval(str) was the next to be created.
</p>

<p>
	2019-03-17 Never got the GUI to work, so deleted it.
</p>

<h3>2019-02-17 ObjPersistent</h3>
<p>
	After creating Gui.show, which displays a graphical interface, a method for killing that window on exit was needed. 
</p>
<p>
	This was done by extending
	the ObjPersistent class with a method cleanupOnExit(), which for ObjGui performs a dispose on the App object. Also added identically named method to ObjGlobal, and a call to that from Main on exit.
</p>
<p>
	Also added method initPersistentObj() which is called once for each persisted instance. Added this method to the Gui object (ObjGui),
	as a way of popping up the JFrame after it has been created and recognized as the first Gui object. Later calls to Gui which returns
	objects with persistence-id matching an existing object are thrown away, and replaced by the persisted object.
</p>


<h3>2019-03-13 showCode()</h3>
<p>
	Added wildcard '*' option at end of name matches.
</p>

<p>
	Example: showCode("DirCurr,Dir*:Config|S*:Search|*:The rest")
</p>

<p>
	The point of DirCurr before Dir* is to ensure DirCurr is displayed before other Dir* whatever their alphabetical order.
</p>

<h3>Older changes</h3>


<pre style="border:0; padding:0; margin:0">
2019-01-10 DONE
------------
- showCode() for putting code lines of interest into different categories, as an alternative to '?' for listing program code
- added Dict.has(key) -> boolean
- added "cd" statement
   - cd .   # go to start directory
   - cd ..
   - cd "string"
   - cd identifier
- removed Cmd module
- added Glob and Regex top-level objects
- extended various methods of Dir object with optional Glob parameter ()
   - dirs()
   - files()
   - allDirs()
   - allFiles()
- modified presentation of Dir and File objects to not include full path, plus add File.separator to end of name for Dir (presentation only)
- created dual named expression ("dir" and "ls"), currently no parameters, returns list of directories and files in current directory
- created "pwd" as expression, no parameters, returns current directory as Dir object and displays full path
   - in fact corresponds to Dir without parameters, but pwd is easier to type

- added ValueInt.f() method to return as float
- added ValueFloat.f() method that returns itself, to be able to "cast" any numeric value to float, even if it is a float
- likewise with i() method of Int and Float

2018-11-15 DONE
---------------
- Added method String synthesize() throws Exception to Obj, to be overridden by various objects and values
- Overridden in all Value types
- Added :syn command to Runtime.java and tested with the above
- Added override of synthesize() methods to the following objects 
   - Date
   - Date.Duration
   - Dir
   - File
   - ValueObjInt
   - ValueObjStr
   - ObjDict


2018-11-14 DONE
---------------
- Made Input.get silent when there is buffered input in the InText object
- Added no-argument constructor for Dir (using ".")
- Added function Dir.find(str) to locate files which contain str in name
- Added numbers in front of list entries when return value is list, for easy access with nth


2018-11-12 DONE
---------------
- Added global Date class
- Date is automatically set to current date and time
- Added method Duration, which returns a Duration object
- The Duration object is also the output from the diff() method
- Durations are formatted differently from dates
- Added line numbers to File.more()


- Date methods
   Duration - create Duration of 0
   add(duration)
   after(date)
   before(date)
   dayOfMonth
   dayOfYear
   diff(date) - returns Duration
   fmt
   get
   hour
   millisecond
   minute
   month
   parse(value)
   set(value)
   setFormat(str)
   sub(duration)
   year
   
- Duration  methods
   days(val)
   get
   hours(val)
   millis(val)
   minutes(val)
   seconds(val)
   
For sorting on date, use get() method to return int (long) value, and sort on this.



2018-11-09 DONE
---------------
- Changed Dict to not take label, and not be session-persistent
- Renamed String.replace to String.replaceChars
- Created new String.replace, which replaces string a with string b
- Added Data.each(from,to) for integer counting - returns list
- Added String.merge, taking a Dict, and replacing each key with corresponding value 
	- for particular notation, such as ${x}, just modify keys accordingly


2018-11-08 DONE 
---------------
- Fixed int parse problem, now parsing as long
- String.parseFloat
- String.replace
- Added InText class, exists as instance in ObjGlobal
- Modified Function.callFunction() interface, to include InText object
- Added stdin(...) statement, which adds buffered input lines to the InText object
- Modified Input object, removed readline-method from Obj, using InText instead
- Added Dict as session persistent object
	.set, .get, .keys, .remove
- Added File.more function for paging through files
- Added function yes() to Lib.Data



2018-11-05 DONE
---------------
- Lib object
- Lib.Math object (.sin(x) .cos(x))
- Lib.Data object (.for(init,limit,incr) -> list)
- Lib.Plot object (.readCSVFile(f) .plot(f))

2018-10-?? DONE
---------------
- Added ExprIf(expr,expr,expr) with "lazy" evaluation, so only one of the last two expressions gets resolved
- Added syntax to repeat a named line as text:
	!x! ...
	!x:pattern!...



2018-09-15 DONE
---------------
- Fix problem with int+-*/float
- Added round() function to ValueFloat

2018-09-09 DONE
---------------
- Change list.add to modify same instance, instead
of creating new. This means we can add data to an
instance referred via local variable.

- 'help' displays functions inside object in alphabetical
order.

2018-09-08 DONE
---------------
- Allow multiple programlines to be added on a single
line, separated by the pipe symbol, and using the "_"
underscore value for the return value of the 
previous programline:

Dir(".").files->f out(Int(f.length,f)) | _.sort.reverse->x out(x.data)


2018-08-27 DONE
---------------
- Supporting parameters to named lines:

P(pos,val) returns parameter value at pos (1-based) if called, otherwise val.

Ex. 

P(1,"x")=s s+"y"
-> returns xy when declared
/F

F("a")
-> returns "ay"
</pre>


</body>
</html>	
