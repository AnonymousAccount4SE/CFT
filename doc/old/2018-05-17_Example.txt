
$ Dir("d:\systor\data\valid") =validDir
$ validDir.allFiles(recursive:true) ->f emit(f.getName().toUpperCase()) | =allFiles
$ <"TIF" "TIC" "AIT" "NAT" "TR"> =type1
$ <"OBUSTATUSFILE" "TIF" "NAT"> =typeRecv

$ allFiles ->f type1->t f.startsWith(t) -> t.length =len f.sub(len,6)=bin emit(bin) | =bin1
$ allFiles ->f typeRecv->t f.startsWith(t) -> t.length =len (len+5)=start emit(f.sub(start,6)) | =bin2
$ bin1+bin2 =bins

$ :CreateBINS
% Created macro CreateBINS:
%    bins /bin1/bin2         = Code: bin1+bin2
%    bin2 /allFiles/typeRecv = Code: allFiles ->f typeRecv->t f.startsWith(t) -> t.length =len (len+5)=start emit(f.sub(start,6))     bin1 /allFiles/type1 = Code: allFiles ->f type1->t f.startsWith(t) -> t.length =len f.sub(len,6)=bin emit(bin)
%    typeRecv                = <"OBUSTATUSFILE" "TIF" "NAT">
%    type1                   = <...>
%    allFiles /validDir      = Code: validDir.allFiles(recursive:true) ->f emit(f.getName().toUpperCase())
%    validDir                = Code: Dir("d:\systor\data\valid")

# Variables represent expressions, which are executed to produce a value.
# Variables are NAMED PIECES OF CODE, NOT VALUES.

# So for example:

$ <"acfc" "easygo" "roadside"> ->x emit("c:\xyz\" + x + "\root") |=rootDirs
$ bins->b emit(b+"\in") emit(b+"\out") |=inOut
$ rootDirs->R inOut->X Dir(R+"\"+X).mkdir() |=mkdirs

# Creating a macro means including all RELEVANT code, via dependency detection.
#
# This means that other macros can be created from the PARTS of another macro, as
# each macro is a namespace for blocks of code, some of which produce data, and some
# which only do stuff. 

$ :CreateDirs {mkDirs}
%      Dir("d:\systor\data\valid") =validDir
%      validDir.allFiles(recursive:true) ->f emit(f.getName().toUpperCase()) | =allFiles
%      <"TIF" "TIC" "AIT" "NAT" "TR"> =type1
%      <"OBUSTATUSFILE" "TIF" "NAT"> =typeRecv
%      allFiles ->f type1->t f.startsWith(t) -> t.length =len f.sub(len,6)=bin emit(bin) | =bin1
%      allFiles ->f typeRecv->t f.startsWith(t) -> t.length =len (len+5)=start emit(f.sub(start,6)) | =bin2
%      bin1+bin2 =bins
%      <"acfc" "easygo" "roadside"> ->x emit("c:\xyz\" + x + "\root") |=rootDirs
%      bins->b emit(b+"\in") emit(b+"\out") |=inOut
%      rootDirs->R inOut->X Dir(R+"\"+X).mkdir() |=mkdirs
%      {mkDirs}


# As the bins list can be handy for other purposes, we create it into a different macro:

$ :GetBINS {bins}

# At a later time, we can load different macros and reuse different parts of them, as well
# as cloning macros and substituting parts. For example, to reuse the mkdirs symbol, we
# need to provide a value for rootDirs and inOut, as these are the dependencies of
# the "mkdirs" symbol.

$ <"c:\home"> |=root
$ <"a" "b"> |=sub
$ root => :CreatedDirs.rootDirs   # rewire operation, this eliminates dependencies from original location
$ sub => :CreatedDirs.inOut
$ call :CreatedDirs.mkdirs | =execute

$ +:CreateMultipleDirSets{execute}
%      <"c:\home"> |=root
%      <"a" "b"> |=sub
%      root->R sub->X Dir(R+"\"+X).mkdir() |=x001mkdirs |=execute

# Repeat assignments just assign the previous as code.
# Symbols from inside the referred macro are rewritten if crashing with
# symbols in current location.

