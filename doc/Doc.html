<html>
<head>

<style type="text/css">
	* {font-family: arial}
	pre {font-family:courier; margin-left:1Em; padding-left: 1Em; font-size: 16pt}
	h1 {padding-top:1Em; color: blue}
</style>
</head>
<body>

<h1 style="padding-left:0; margin-left:0; font-size:24pt; font-family:monospace; color:black">
CFT / ConfigTool
</h1>

<pre style="padding-left:0; margin-left:0">

Last updated: 2020-09-28 RFO
v1.5.2

</pre>

<h1>Introduction</h1>

<p>
  CFT is an interactive programmable shell-like application, for automation of all kinds.
</p>
<p>
  It is a Java application that runs on the command line, and has no graphical elements, which
  means it can run everywhere. The syntax is compact, so as to be able to do useful
  work even entering code interactively, one line at a time.
</p>
<p>
  Automating tasks is done by creating functions, which initially are named sequences
  of code. Functions call each other, as well as a library of global functions.
</p>
<p>
  CFT is tested on Linux and Windows, and easily integrates with external commands
  on both, such as PowerShell, git, ssh. It should run anywhere that supports Java.
</p>

<p>
  Development has been going on since May 2018, and v1.0 towards end of June 2020
  marked a certain level of robustness and error
  handling, being mature enough for open source release on github. 
</p>

<p>
  As the language evolved, CFT has been moving away from strictly entering code via the
  command line, to editing the save files, which are referred to as "script files". This allows
  multiple-line functions, and makes CFT suitable for more complex tasks. 
</p>




<h1>Functionality</h1>
<p>
  The CFT programming language is thought to act as glue between library functions and objects,
  and the ability to run external programs. In that respect, CFT is similar to shell scripts,
  where major functionality depends on external programs.
</p>
<p>
  CFT is object oriented in the sense that everything is objects. Entering the integer 1 on the
  command line, is an expression which resolves into a value object of type "int". All objects
  have member functions, for example the "bin()" function on integers, that returns the number
  as a binary string.
</p>
<pre>
  $ 1.bin
  &lt;String&gt;
  00000001
</pre>
<p>
  Here the '$' is the prompt.
</p>
<p>
  The ".bin" calls the function "bin" inside the integer object. Parantheses are optional when no parameters.
</p>


<h2>System functions and objects</h2>
<p>
  A number of global functions are available, and all produce objects of some sort, where
  we may in turn call other functions, and so on. 
</p>
<p>
  The global functions are available from the command line as follows:
</p>
<pre>
  $ help
</pre>
<p>
  Global functions give access to objects of different types. Some of the most important
  and frequently used are:
</p>
<ul>
  <li>lists</li>
  <li>directories</li>
  <li>files</li>
  <li>dictionaries</li>
</ul>



<h1>Getting help</h1>

<h2>Show all global functions</h2>
<pre>
  $ help
</pre>


<h2>Show functions inside objects</h2>
<p>
  To show all functions inside an object, create an instance of that object followed by the word help. 
  Specifically, the help statement takes the value on top of the stack and lists it's available
  functions.
</p>
<pre>
  $ 1 help               # integer
  # 3.14 help            # float
  $ "xxx" help           # string
  $ List help
  $ Dict help
  $ Dir help
  $ File("x.txt") help   # the file needs not exist
</pre>



<h2>Show your own functions</h2>
<p>
  List the functions that you have defined by typing
</p>
<pre>
  $ ?
</pre>




<h1>CFT as a shell</h1>
<p>
  Commands like "ls" and "cd" exist, with globbing, as well as "more" and "edit" (which opens a file
  in an editor), and they are meant for moving around the directory tree.
</p>
<p>
  Actually changing 
  and moving files and directories is supposed to be scripted with code.
</p>
<pre>
  $ pwd
  $ cd ..
  $ ls *.txt
</pre>

<p>
  CFT differs from traditional *ix / *ux shells, in that it works with objects, not just strings.
</p>




<h2>Show content of file</h2>
<p>
  Now if we want to list content of file "TODO.txt", we can enter
</p>

<pre>
  $ cat TODO.txt
  $ more TODO.txt
</pre>

<h2>Open a file in editor</h2>
<pre>
  $ edit TODO.txt
</pre>




<h1>Automation - creating functions</h1>
<p>
  Automation is in its simplest form to assign a name to a sequences of statements.
</p>

<pre>
  $ Dir.allFiles(Glob("*.java"))
</pre>
<p>
  This line of code generates a list of all java files under the current directory or sub-directories. 
  To save typing, we may want to assign a name to the code. This is done by entering a slash followed by
  an identifier.
</p>

<pre>
  $ /JavaFiles
</pre>
<p>
  Now every time we want the list of java files, we just type JavaFiles.
</p>
<pre>
  $ JavaFiles-&gt;f out(f.read.length) | _.sum
</pre>
<p>
  This single line of code now counts the number of lines in all the files, and sums them up. 
</p>
<ol>
  <li>the "arrow" followed by an identifier is the "for each" construct</li>
  <li>the out() statement generates output from the loop</li>
  <li>the "pipe" character terminates the loop, and delivers the result to the next part, where ...</li>
  <li>the special expression '_' just means "get value on top of stack", which in this case is a list ...</li>
  <li>on which we call the "sum()" function</li>
</ol>





<h1>List basics</h1>
<p>
  Lists are return value from many functions, such as getting the files in a directoryu. Lists
  can also be created 
  with the global List() function, which takes any number of parameters, and creates a List object
  from those values.
</p>
<pre>
  $ List(1,2,3,4)

  $ Dir.files
  $ "abcdef".chars
  $ "one two three".split
</pre>

<p>
  Many functions are available on a List object. One frequently used is "nth", which
  gets a specific element, defaulting to 0 if no argument.
</p>
<pre>
  $ List("a","b","c").nth
  &lt;String&gt;
  a
</pre>

<p>
  For details of available functions, as always use the help system:
</p>
<pre>
  $ List help
</pre>







<h1>Files</h1>
  <pre>
  $ File("x.txt")
   &lt;obj: File&gt;
   x.txt   DOES-NOT-EXIST 
  </pre>

 <p>
  The File() function requires a name, and returns a File object. As seen
  above, the file needs not exist.
</p>
<p>
  File objects created with a simple file name (no path), are always located in
  the CFT home directory. This gives predictability for certain data files etc.
</p>
<p>
  To access or create files in other directories, enter an absolute or relative
  path in the parameter to File(), or use the file() function inside
  some Dir object:
</p>
<pre>
  $ SomeDirExpression.file("x.txt")
</pre>




<h2>Page through a file</h2>

<p>
  To page through text file
</p>
<pre>
  more x.txt
</pre>

<h2>Show bytes of file</h2>
<p>
  To page through hex listing of file
</p>
<pre>
  File("x.txt").hex
</pre>



<h2>Encoding</h2>
<p>
  Default encoding is "ISO_8859_1", but this can be changed, for example:
</p>
<pre>
  File("x.txt").encoding("UTF-8")
</pre>





<h1>Directories</h1>
<pre>
  $ Dir
  &lt;obj: Dir&gt;
  ConfigTool/ d:5 f:20
</pre>

<p>
  Calling the Dir function with no parameters returns a Dir object for the current directory.
</p>
<p>
   The Dir
  object offers multiple member functions, one of which is <b>.files()</b>, which produces a list of files in 
  the directory. Another is <b>.allFiles()</b> which return files from all subdirectories as well.
</p>


<h2>Create a subdirectory</h2>
<pre>
  Dir.sub("someDir").create
</pre>


<h2>Parent directory</h2>
<p>
  To get the parent directory of a Dir object:
</p>
<pre>
  Dir.sub("..")
</pre>

<h2>Get files in a directory</h2>
<pre>
  Dir.files
</pre>

<h2>Create a file in a directory</h2>
<pre>
  Dir.file("x.txt").create("something")
</pre>

<h2>Get immediate directories in a directory</h2>
<pre>
  Dir.dirs
</pre>
<h2>Get all files recursively under a directory</h2>
<pre>
  Dir.allFiles
</pre>
<h2>Get all directories recursively under a directory:</h2>
<pre>
  Dir.allDirs
</pre>
<h2>Delete a sub-directory</h2>
<p>
  The sub-directory must be empty
</p>
<pre>
  Dir.sub("something").delete
</pre>





<h1>The shell() function</h1>
<p>
  The global shell() function starts a shell inside CFT. When you exit from it, you're back
  in CFT.
</p>
<pre>
  $ shell
  (starts bash or cmd or Powershell or something else)
  exit
  # Running /usr/bin/bash completed: 25529ms
  $
</pre>










<h1>Core types</h1>
<ul>
  <li>String</li>
  <li>int - (Java long)</li>
  <li>float - (Java double)</li>
  <li>boolean</li>
  <li>List</li>
  <li>Dict</li>
</ul>
<p>
  All values in CFT are objects, which may contain functions. Strings can be written using double
  or single quotes. 
</p>

<h2>String literals</h2>
<p>
  Strings are written in single or double quotes, and can be summed with '+', which allows
  for all kinds of combinations.
</p>
<pre>
  $ "double quotes"
  $ 'single quotes'

  $Â "'a'"
  &lt;String&gt;
  'a'

  $ '"' + "'a'" + '"'
  &lt;String&gt;
  "'a'"
</pre>
<p>
  Also, backslash is not used as escape character, which means backslash is just another character,
  simplifying those Windows paths.
</p>


<h2>Dictionaries</h2>
<p>
  Dictionaries are maps that store any value identified by names (strings). 
</p>
<pre>
  $ x=Dict x.set("a",1) x.get("a")
  &lt;int&gt;
  1
</pre>



<h1>List iteration / filtering</h1>

<p>
  Lists are essential for all processing with CFT.
</p>
<p>
  Lists can be created manually using the global List() function. 
</p>

<pre>
  $ List(1,2,3)
  $ List("a","b","c")
</pre>

<p>
  A much used way for creating lists of strings, is to use the string function split(), which by default
  splits a string on spaces. This means the following produce the same result.
</p>

<pre>
  $ List("a","b","c")
  $ "a b c".split
</pre>




<h2>Iterating over list content</h2>
<p>
  The iterator in CFT takes the form of an arrow followed by a loop variable. For a loop construct
  to return output, we use the out() statement inside.
</p>

<pre>
  $ "1 2 3".split-&gt;x out("a"+x)
  &lt;List&gt;
   0: a1
   1: a2
   2: a3
</pre>

<p>
  The result is a list of strings, as displayed.
</p>




<h2>Filtering with assert(), reject() and break() + out()</h2>
<p>
  Using the assert() statement, we may abort processing for elements that do not meet a condition. 
</p>
<pre>
  $ Dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
</pre>
<p>
  The reject() statement is the inverse of assert(), and aborts processing for elements that meet
  a certain condition.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x reject(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
  2
  1
</pre>
<p>
  The break() statement terminates the loop if the condition is true.
</p>
<pre>
  List(1,2,3,2,1)-&gt;x break(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
</pre>



<h2>The condOut() statement</h2>
<p>
  In addition to controlling loops with assert/reject and break, there is the condOut()
  statement, which takes a boolean condition as first parameter, and the value to 
  be sent out as second parameter. Can be useful some times.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x condOut(x&lt;2,"(") out("b") condOut(x&lt;2,")") | _.concat
  &lt;String&gt;
  (b)bbb(b)
</pre>





<h2>List addition</h2>
<p>
  Two lists can be added together with "+".
</p>
<pre>
  List(1,2) + List(3)
  &lt;List&gt;
  1
  2
  3
</pre>

<p>
  Also, elements can be added to a list with "+" as long as the list comes first.
</p>
<pre>
  List(1,2)+3
  &lt;List&gt;
  1
  2
  3
</pre>





<h1>Creating functions</h1>



<h2>Naming lines of code</h2>
<p>
  When some code does what we want, we typically create a function from it. This is done by entering
</p>
<pre>
  ... (some code) ...
  /name
</pre>
<p>
  This assigns the name "name" to the last line, and we have now created a custom function.
</p>

<pre>
  $ "java txt html".split
  $ /Types

  $ Dir.allFiles-&gt; f assert(Types.contains(f.name.afterLast("."))) out(f)
  $ /TextFiles
</pre>



<h2>Calling a function</h2>
<p>
  To call the above function, just enter its name.
</p>
<pre>
  TextFiles
</pre>



<h1>Savefiles</h1>
<h2>Save</h2>
<p>
  To save all named functions, enter the special command below
</p>

<pre>
  $ :save Test
</pre>

<p>
  This creates a file under the CFT home directory,
  called savefileTest.txt. 
</p>

<h2>Load</h2>

<pre>
  $ :load Test
</pre>


<h2>Create new empty script</h2>
<p>
  To create a new script from scratch, there is the colon command:
</p>
<pre>
  $ :new
</pre>
<p>


<h2>The @e shortcut</h2>
<p>
  A common shortcut is @e, which opens current savefile in an editor:
</p>
<pre>
  $ @e
</pre>
<p>
  Shortcuts can be redefined in the CFT.props file.
</p>


<h2>CFT.props - codeDirs</h2>
<p>
  The CFT.props file contains the following line by default
</p>
<pre>
codeDirs = . ; code.examples ; code.lib
</pre>
<p>
  The codeDirs field defines a search order when loading scripts. 
  The first directory is <b>always</b> used when you type ":save".
</p>
<p>
  The code.examples contains some example code for various use, while code.lib contains
  library code, used by most other scripts.
</p>
<p>
  This means you are free to save a script using the name "Lib", and it will be written to
  the code.work directory. Doing this means it will hide the version in the code.lib directory.
  Which may be perfectly fine, as long as it is what you intended.
</p>





<h1>Protecting files and directories</h1>
<p>
  To save typing, one often create functions that just return some directory, or 
  some files.  The JavaFiles example above illustrates this.
</p>
<p>
  The protect mechanism in CFT lets us attach a protect state to any Dir and File object,
  which guarantees that:
</p>
<ol>
  <li>all files and directories derived from it are also protected</li>
  <li>blocks destructive modifications</li>
</ol>
<h2>Example</h2>
<p>
  Adding .protect to each file that the JavaFiles function generates, ensures that all
  files returned from this function are blocked against accidental delete and modifications.
</p>
<pre>
  $ Dir.allFiles-&gt; f assert(f.name.endsWith(".java")) out(f.protect)
  $ /JavaFiles
</pre>
<p>
  Demonstration:
</p>
<pre>
  $ JavaFiles.nth.append("")   # Trying to append empty line to first file
  ERROR: [input:16] INVALID-OP append : /home/roar/Prosjekter/Java/CFT/src/rf/configtool/main/SourceException.java (PROTECTED: -) (java.lang.Exception)
</pre>
<p>
  The .protect() function can also take a description string, which if present, is displayed in this error.
</p>



<h2>No guarantee</h2>
<p>
  Calling .protect on a Dir object, before using it to locate files, will propagate the protected
  state to all those files. However, creating a new Dir object for the same path, without calling 
  .protect() on it, and then accessing content via this, does not protect anything.
</p>
<p>
  Note also that .protect can not detect for example using the path of a protected File object in
  an external program, or even to create a new File object (which will not be protected). Example:
</p>
<pre>
  File(protectedFile.path)
</pre>

<h2>Laziness is our friend</h2>
<p>
  Usually we will reuse an existing function over creating a new one that does the same.
</p>
<p>
  It may be good design to create functions that return top directories, and protect those
  where we don't want to introduce changes, with secondary functions for locating sub-content, 
  depending on the first function to produce the start point. 
</p>






<h1>More programming</h1>




<h2>Local variables</h2>
<p>
  The inside of a function may use local variables for simplifying expressions etc.   
</p>

<pre>
  $ a=3 b=2 a+b
  &lt;int&gt;
  5 
</pre>

<p>
  Can also use "stack based" notation, where the assignment picks the current value
  off the stack and stores it into a variable:
</p>
<pre>
  3=&gt;a 2=&gt;b a+b
  5
</pre>




<h2>Nested loops</h2>
<p>
  Loops are implemented using the "for each" functionality of "-&gt; var". Loops may well be nested.
</p>

<pre>
  $ List(1,2,3)-&gt;x List(1,2,3)-&gt;y  out(x*y)
  &lt;List&gt;
   0: 1
   1: 2
   2: 3
   3: 2
   4: 4
   5: 6
   6: 3
   7: 6
   8: 9
</pre>

<p>
  In this case, the body of each loop is all code following the "-&gt; var"
  construct. But this can be changed using the "pipe" symbol, which "closes" all loops.
</p>



<h2>Loop spaces - "pipes"</h2>
<p>
  The body of any loop is the rest of the code of the function, or until a "pipe" symbol
  is found. The pipe symbol ("|") more accurately breaks the code into a sequence of
  <em>loop spaces</em>, which means acting as an end-point for 
  running loops.
</p>
<p>
  The way a "pipe" works, is to wait for all current loops to terminate, then take the
  return value from that loop space and putting it onto the stack for the next loop
  space to work with (or do something else). Example:
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | =&gt;sizes sizes.sum
</pre>
<p>
  This single line of code first contains a loop, which outputs a list of integers for
  the sizes of all files in the current directory. Then the "pipe" symbol terminates that
  loop space, and creates a new one, where we pick the result from the previous loop
  space off the stack and assigns it to a local variable. We then apply the sum() function to it.
</p>
<p>
  To save us some typing, the special expression "_" (underscore) pops the topmost value off
  the stack.
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | _.sum
</pre>

<p>
  As we see from the above code, a loop spaces don't <em>need</em> containing loops. The 
  following is perfectly legal, although a little silly.
</p>
<pre>
  $ 2+3 | | | | =&gt;x x | =&gt;y y | _ _ _ |
</pre>
<p>
  Yes, it returns 5.
</p>




<h2>Result value from a loop space</h2>
<p>
  All bodies of code in CFT consist of one or more <em>loop spaces</em>. The result value
  from any such body is the return value from the last loop space.
</p>

<h3>If the loop space contains looping ...</h3>
<p>
  If a loop space contains loop statements, the result value is a list of data generated
  via calls to out() or report() statements. If no actual iteraions take place, or
  filtering with assert(), reject() or break() means no data is generated via out() or report(), 
  then the result is an empty list.
</p>

<h3>Otherwise ...</h3>
<p>
  A loop space that doesn't contain loop statements, has as its return value the topmost
  element on the stack after all code has executed. If there is no value on the stack,
  the return value is <em>null</em>.
</p>




<h2>Editing script files</h2>
<p>
  After saving, a script file is created. It can be edited with any editor. CFT automatically detects
  if it has been changed, and reloads it when issuing the next interactive command.
</p>
<p>
  There also exists a shortcut, which opens the current script file in an editor:
</p>
<pre>
  $ @e
</pre>

<p>
  For windows, it starts notepad. For linux, there is a selection list, where one identifies 
  which editor to use. This is remembered for the rest of the session.
</p>
<p>
  To reset the selection:
</p>
<pre>
  $ @ee
</pre>

<p>
  Shortcuts are user-defineable in the CFT.props file
</p>

<h3>Comments</h3>
<p>
  The hash character '#' indicates that the rest of the line is a comment.
</p>











<h2>Function parameters</h2>
<p>
  Custom functions can also take parameters. This is done using the P() expression, which
  identifies the parameter by position. Note that <em>parameter position is 1-based</em>.  
</p>
<pre>
  $ P(1)=&gt;a P(2)=&gt;b a+b   # fails!
</pre>
<p>
  If you enter the above code interactively, it will fail, complaining that you can not add
  "null + null". This is because there is no call yet, and so there are no parameter values. This is 
  fixed by letting the P() expression take a second parameters, which is a default value expression.
</p>
<p>
  The default value parameter to P() is important for three reasons.
</p>
<ol>
  <li>Allows the function code to execute while being developed interactively</li> 
  <li>May act as documentation in the source</li>
  <li>
    Provides an elegant way of making functions interactive and non-interactive at the same time, 
    as the default expression is evaluated only when parameter is not given (or is null), 
    and may then ask the user to input the value.
</li>
</ol>




<h3>Simple example</h3>
<p>
  Here we make an improved version of the JavaFiles function, that takes a directory parameter, and if none given, uses the current directory ("Dir").
</p>
<pre>
  $ P(1,Dir) =&gt;dir dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
     :
     : (code result)
     :
  $ /JavaFiles
</pre>

<p>
  Typing this code interactively means it gets executed directly, with no actuall call
  parameters. This means P(1) is null, and so the default value ("Dir") is used, which means
  the code runs on current directory.
</p>
<p>
  After defining the function, we may call it without parameters, or supply null for
  a given parameter, which again means the 
  default expression is used, and the code again executes on current directory.
</p>
<p>
  But now we can let this function run on a custom Dir object, regardless of the current
  directory.
</p>
<pre>
  $ Dir("/home/user/project1")
  $ /DirProject1

  $ JavaFiles(DirProject1)
</pre>



<h2>User input</h2>
<p>
  CFT contains the following for asking the user to enter input:
</p>
<pre>
  value = Input("Enter value").get
  value = readLine("Enter value")
</pre>
<p>
  The difference is that Input remembers the last input values, and lets the user
  press enter to use the last value, or may enter colon to select between previous
  values. The readLine() is much simpler, and allows for empty input, as enter
  doesn't mean "last value" as for Input.
</p>
<p>
  The optional default value parameter to the P() expression for grabbing parameters to
  functions, can be used to produce functions that ask for missing values.
</p>
<pre>
  P(1,Input("Enter value").get) =&gt;value ...
</pre>









<h2>Block expressions</h2>
<p>
  The traditional blocks inside curly braces are present in CFT as well, and are used for different
  things.
</p>


<h3>Local blocks</h3>
<p>
  Local blocks are just for grouping code that runs in the same context as the code around it. Technically
  they are considered expressions.
</p>
<pre>
  if (a&gt;b) {
    ...
  }
</pre>


<h3>Lambdas</h3>
<p>
  A Lambda is an object (a value) that contains code, so it can be called, with parameters. The code
  inside runs detached from the caller, and behaves exactly like a function.
</p>
<pre>
  myLambda = Lambda { P(1)+P(2) } myLambda.call(1,2)
</pre>
<p>
  Great for local functions inside regular functions, and for sending as parameters to other functions,
  or lambdas.
</p>



<h3>Inner blocks</h3>
<p>
  An inner block is a cross between local blocks and the Lambda. An Inner block is executed
  immediately, and has access to the local variables inside the function, but maintain a separate
  context for loops and loop output. Technically, inner blocks are expressions, just as with local
  blocks. 
</p>
<p>
  In other words: Inner blocks define their own loop space.
</p>
<pre>
  Inner {
    someList->x out(x+1)
  } =&gt;resultList 
  ...
</pre>
<p>
  Inner blocks are a way of running loops isolated from the environment. Remember that loops by 
  default extend to the end of the function, or until hitting a "pipe". The third thing that 
  terminates loops are hitting the end of the current block.
</p>
<p>
  Even the end of local blocks terminate loops, but they share the loop space of the surrounding code, 
  providing somewhat "complicated" outcomes.
</p>
<p>




<h3>Summary</h3>
<p>
  Local (plain) blocks for non-looping blocks of code, typically used with "if". Running in
  the same loop space as outside the block, means it can call break() and out() as well as
  assert() and reject() and affect the (innermost) loop of those outside the block. 
</p>
<p>
  Inner blocks for isolated processing loops inside other code. This means calling break() and
  out() and assert() and reject() have no effect on loops outside the block.
</p>
<p>
  Lambdas are "functions" as values.
</p>





<h2>Conditionals - if expression</h2>
<p>
  Conditional execution of code is done in two ways in CFT, with the first being how we
  control processing loops with assert, reject and break.
</p>
<p>
  Then there is the if-exression. It takes two forms, but is always considered an expression, not a statement. The
  difference is that expressions always return a value, which statements need not.
</p>
<h3>Inline form</h3>
<pre>
  if (condition, expr1, expr2)
  if (condition, expr1)
</pre>
<p>
  The first selects between the two expressions, based on the condition, evaluating and returning 
  expr1 if condition is true, otherwise expr2. The second conditionally evaluates expr1, or if 
  the condition is false, returns null.
</p>

<h3>Traditional form</h3>
<pre>
  if (condition) expr1 else expr2
  if (condition) expr1
</pre>

<h3>Functionally identical</h3>
<p>
  The two forms are functionally the same. To select between two simple expressions, the inline
  form is probably most readable, while when using block expressions, the traditional form
  usually feels more natural. Also note that block expressions allow us to call statements, 
  such as out() and break() as well as assignments.
</p>
<pre>
  # Example: produce a default value if null
  if (value != null, value, "x") =&gt;value

  # Example: call statements inside blocks
  i=1
  loop
    if (i>10) {
       break
    } else {
      i=i+1
    }
</pre>


<h3>if-ladders</h3>
<p>
  The implementation in CFT supports chaining multiple if after each other.
</p>
<pre>
  if (cond) {
    ...
  } else if (condB) {
    ...
  } else if (condC) {
    ...
  }
</pre>
<p>
  Decoding some value x into a numeric code, we can enter the following
</p>
<pre>
  code = if (x=="a") 1 else if (x=="b") 2 else if (x=="c") 3 else 4
</pre>






<h2>Lazy evaluation</h2>
<h4>Lazy if</h4>
<p>
  The if-expression uses lazy evaluation, which means that only the selected
  value expression (if any) gets evaluated. This is the same as every other
  language.
</p>
<h4>Lazy AND, OR - &amp;&amp; ||</h4>
<p>
  Boolean expressions with logical AND and OR, are lazy, again as in
  every other language. 
</p>
<h4>Lazy P(N,defaultExpr)</h4>
<p>
  The P() expression to access function parameters only evaluates the default
  expression if parameter N is null.
</p>





<h2>The error() function</h2>
<p>
  The error() expression is another that contains a conditional part, and if true, throws
  an exception with the string part, terminating current execution. Alternatively it can
  be used without the condition, which means it always throws an exception.
</p>
<pre>
  error(1+1==2,"this should not happen")

  if (1+1==2) {
    error("oops again")
  }
</pre>



<h2>Output</h2>
<p>
  Output to screen
</p>
<pre>
  println("a")
  debug("b")
</pre>







<h1>Running external programs</h1>



<h2>Summary</h2>
<p>
  The functions for running external programs are part of the Dir object, implicitly defining
  working directory for the program.
</p>

<pre>
  $ Dir.run ( list|...)
  $ Dir.runCapture ( list | ...)
  $ Dir.runDetach ( list|...)
  $ Dir.runProcess ( stdinFile, stdoutFile, stdErrFile, list|... )
  $ Dir.runProcessWait ( stdinFile, stdoutFile, stdErrFile, list|... )
</pre>

<p>
  The parameters written as "list|..." means either a List object, or a list of
  String values, separated by comma.
</p>




<h2>Dir.run()</h2>
<p>
  This command is used for running external programs in the foreground. What this means is that if
  the program requires user input, we can give it, and the CFT code will not continue until
  the external process has terminated.
</p>
<pre>
  $ Dir.run("cmd","/c","git","pull","origin","master")
</pre>
<p>
  Many Windows programs require the "cmd","/c" in front of the actual program.
  For proper operating systems (Linux) you naturally skip the two first elements of the command list.
</p>
<p>
  Often it is easier to use String.split in this case, as Dir.run() accept a single List value
  instead of a list of values.
</p>
<pre>
  Dir.run("cmd /c git pull origin master".split)
</pre>



<h2>Dir.runCapture()</h2>
<p>
  This works the same as Dir.run(), but returns a List of strings representing stdout from the
  external program, to be processed further.
</p>

<pre>
  Dir.run("which","leafpad") =&gt;lines lines.length&gt;0 && lines.nth.contains("leafpad")
  /HasLeafpad
</pre>



<h2>Dir.runDetach()</h2>
<p>
  Use to run external program in the background. The CFT code continues running after forking
  off the background process. Nice for editors etc.
</p>
<pre>
  $ Dir.runDetach("leafpad", Sys.savefile.path)
</pre>

<p>
  This example runs the (linux) leapad editor in the background, with the path of the current savefile as 
  argument.
</p>




<h2>Dir.runProcess() / .runProcessWait()</h2>
<p>
  Dir.runProcess() is similar to Dir.runDetach(), and Dir.runProcessWait() is similar to
  Dir.run(), but for cases where we need to provide non-interactive input, 
  and inspect the output, as this uses files for stdin, stdout and stderr.
</p>
<p>
  At this level of complexity, one-line functions get a bit less readable, so the example below
  is spread out across multiple lines, and depends on editing the script file directly.
</p>
<p>
  (note: may be less readable on .md format - open Doc.html instead)
</p>
<pre>
  ## --- create temp-file
  name = P(1) 
    Dir("/tmp").file(name + "." + currentTimeMillis)
  /TmpFile

  ## --- Call ssh to list remote processes with ps -efal
  P(1,Input("Enter ssh-target on format user@host").get)=&gt;target
    # 
    # Create temp files
    #
    stdin = TmpFile("in")
    stdout = TmpFile("out")
    stderr = TmpFile("err")
    #
    # stdin contains the command(s) we want to run remotely
    #
    stdin.create("ps -efal")
    #
    # Call ssh (requires passwordless login)
    #
    Dir.runProcessWait(stdin, stdout, stderr, "ssh", target)
    #
    # get list of output from the "ps" command
    #
    result = stdout.read
    #
    # delete temp-files 
    #
    stdin.delete
    stdout.delete
    if(stderr.exists, stderr.delete)
    #
    # return value
    #
    result
  /ListRemoteFiles
</pre>

<h3>ssh without password</h3>
<p>
  To set up ssh login without password, create and distribute an ssh key, then
  copy it to the target host, as follows (in Linux shell).
</p>
<pre>
  $ ssh-keygen -t rsa
  $ ssh-copy-id user@host
</pre>


<h2>External Program Status</h2>
<p>
  To obtain the exit code from an external program:
</p>
<pre>
  Sys.lastEPS           # int or -999 if no value
  Sys.lastEPSData       # Dict or null if no value
</pre>
<p>
  The exit code is collected for the following ways of running external programs:
</p>
<ul>
  <li>Dir.run()</li>
  <li>Dir.runCapture()</li>
  <li>Dir.runProcessWait()</li>
</ul>
<h3>Example</h3>
<p>
  Traditionally, exit code 0 means all ok.
</p>
<pre>
  $ Dir.run("which","unknownCommand")
  $ Sys.lastEPS
  &lt;int&gt;
  1
</pre>


<h1>Session persistent data</h1>
<p>
  When working interactively with large sets of data, or in order to remember
  certain selections, we have the option of saving those
  data into a session persistent data store. Two global functions let us define
  a named value, and access it.
</p>
<h2>ValDef</h2>
<p>
  Store a value under a name.
</p>
<pre>
  $ ValDef("a",12)
</pre>
<h2>Val</h2>
<p>
  Get value by name, or null if not defined.
</p>
<pre>
  $ Val("a")
  &lt;int&gt;
  12
</pre>

<p>
  Being tied to the session, these data are lost when quitting CFT.
</p>







<h1>Synthesis</h1>

<h2>The problem</h2>

<p>
  If we use "cd" and "ls" to move
  to a directory, and want to create a function that works on files or subdirectories under
  that location, we have to take care.
</p>

<p>
  The issue is that we can not just say
</p>
<pre>
  Dir.allFiles-&gt;f ...
</pre>
<p>
  ... because the Dir() function returns the current directory, which may change. 
</p>


<h2>Creating code from values</h2>
<p>
  This is where the <i>syntesis</i> functionality comes in. The most often used variant takes
  the form of two "colon commands". 
</p>
<ol>
  <li>The :syn command syntesizes code from the last result.</li>
  <li>The :NN  (where NN is an integer) syntesizes the indicated element of the last result list. If 
  last result is not a list, an error is reported.</li>
</ol>


<h2>Example using :syn</h2>

<pre>
  $ cd ..
    # /home/roar
    &lt;obj: Dir&gt;
    roar/ d:61 f:33 
  $ cd project1
    # /home/roar/project1
    &lt;obj: Dir&gt;
    project1/ d:0 f:0 
  $ :syn
  synthesize ok
  +-----------------------------------------------------
  | .  : Dir("/home/roar/project1")
  +-----------------------------------------------------
  Assign to name by /xxx as usual

  $ /DirProject1
</pre>

<p>
  When we use "cd" to change to a directory, it returns a Dir object. The shell remembers the last
  result value, and the ":syn" attempts to create code representing that value in as direct a way as 
  possible. If this succeeds, it inserts the generated code line tino the "code history", as the 
  last command, which means it can now be assigned a name, for example "DirProject"
</p>

<p>
  Calling function "DirProject" will now always generate a Dir object pointing to the same
  directory, and is no longer dependening on current directory.
</p>

<h2>Example using :NN</h2>

<p>
  To synthesize a single element when the last result was a list, use :NN, as follows
</p>

<pre>
  $ ls
  &lt;List&gt;
   0: runtime/              | d:2 | f:12
   1: CallScriptFunc.java   | 1k  | 1398  |             | 2020-02-28 22:38:09
   2: CodeHistory.java      | 10k | 10980 | 2d_22:23:24 | 2020-06-07 12:57:49
   3: CommandProcessor.java | 0k  | 365   |             | 2020-02-28 22:38:09

  $ :2
  synthesize ok
  +-----------------------------------------------------
  | .  : File("/home/roar/Prosjekter/Java/ConfigTool/src/rf/configtool/main/CodeHistory.java")
  +-----------------------------------------------------
  Assign to name by /xxx as usual  
</pre>

<p>
  If the last value was not a list, the ":NN" command will fail with an error.
</p>





<h1>Output format / Cfg</h1>
<p>
  Output to screen is regulated via a Cfg object. It is a session object, that contains default
  settings for number of lines and line width of the current window / terminal. It's default
  mode of operation is to disable wrapping, which means long lines are cut, ending with a simple '+'
  to indicate this.
</p>
<p>
  To change the current size of the terminal window, we may use global function Cfg() to obtain
  the Cfg object, and methods to set or view the properties.
</p>



<h2>The @term shortcut</h2>
<p>
  After the introduction of short cuts, the easiest way to set the terminal window width and
  height, is to enter
</p>
<pre>
  $ @term
</pre>

<p>
  This works on Linux (using stty command) and on Windows (powershell). 
</p>



<h2>Line wrapping</h2>
<p>
  By default, ouput line wrapping is off, which means that lines longer than the Cfg.w gets truncated
  with a '+' to indicate there is more. It can be switched on/off via the Cfg object, but there is also a
  colon command ":wrap" which toggles wrapping on or off.
</p>








<h1>Templating</h1>
<p>
  CFT has multiple mechanisms that can be used to produce configuration files, as well
  as automated generation of code, from shell scripts to any higher level language,
  autogenerated email text, etc.
</p>



<h2>Merging text with Dict</h2>
<p>
  To merge values into a template, we use a dictionary object (Dict) combined with the
  merge() function of strings. This replaces occurrences of names in the dictionary
  with their values (as strings).
</p>
<pre>
  $ Dict.set("name","Julius")
  $ /data
  $ "Dear name".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>

<p>
  The merge is based on a direct match. Often we like to mark our merge codes. The Dict
  object has a function, ".mergeCodes()", which returns a new Dict object, where all names of fields
  are rewritten into ${name}. Changing the template correspondingly, this eliminates the risk of 
  accidentally matching text not meant as merge codes.
</p>
<pre>
  $ Dict.set("name","Julius").mergeCodes
  $ /data
  $ "Dear ${name}".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>



<h2>Using individual template files</h2>
<p>
  The simplest way to create template text, is to enter it into a text file, which CFT
  then reads and processes. The File.read() function returns a list of lines from the
  file, which we then iterate over and apply the merge data.
</p>
<pre>
  File("myTemplate.txt")
  /templateFile

  P(1,Dict)=&gt;data
  templateFile.read-&gt;line
    out(line.merge(data))
  /generate
</pre>



<h2>Script file "here" documents</h2>
<p>
  The second easiest way of creating lines of text for processing with merge codes, apart from
  editing a separate file, is to use a special feature of the script files, called
  "here" documents. The syntax is picked up when reading the savefile, and the lines
  of text are converted into code on the fly, becoming a List object.
</p>
<pre>
  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Identifier
  This is
  some text
  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Identifier
  /myTemplate
</pre>
 <p>
  Calling the myTemplate function from the interactive shell, produces the following result
</p>
<pre>
  $ myTemplate
  &lt;List&gt;
  0: This is
  1: some text
</pre>
<p>
  There needs to be at least three of the '&lt;' or '&gt;' followed by space and an identifier.
</p>

<h3>A more complex example</h3>
<pre>
  P(1,"a")=&gt;a
  P(2,"b")=&gt;b
  Dict
    .set("a",a)
    .set("b",b)
    .mergeCodes
  =&gt;data
  &lt;&lt;&lt; SomeMarker
  Value of a: ${a}
  Value of b: ${b}
  &gt;&gt;&gt; SomeMarker
  -&gt;line 
    out(line.merge(data))
  /myMergedTemplate
</pre>





<h2>Using DataFile</h2>
<p>
  Another mechanism for templating, particularly if the text blocks are big, is the 
  DataFile function and object, which processes
  a single text file which can contain numerous individual templates. 
</p>
<p>
  The different templates are separated by a user defined selector string, and given names, 
  by which they are accessed from code.
</p>
<p>
  Example data file 'data.txt'
</p>
<pre>
  ### A

  This is
  template A
  
  ### B
  
  This is 
  template B
</pre>
<p>
  The code to use this file consists of creating the DataFile object, passing the separator
  string as a parameter, then accessing the individual templates.
</p>
<pre>
  $ DataFile(File("data.txt"),"###")
  $Â /df

  $ df.get("A")
  &lt;List&gt;
  This is
  template A
</pre>

<h3>Include blank lines</h3>
<p>
  The function DataFile.get() returns only non-blank lines. To get all lines, use function getAll().
</p>

<h3>Filter away comments</h3>
<p>
  Also, DataFile has support for comments in the template text, which can be automatically
  removed. They are defined by another prefix string as follows:
</p>
<pre>
  $ DataFile(someFile,"###").comment("//")
  $ /df
</pre>
<p>
  Now all lines starting with "//" are automatically stripped from any output.
</p>





<h2>PDict()</h2>
<p>
  With many parameters to be merged into the template text, the special expression PDict() saves
  us some writing. It takes a comma-separated list of value names, which are mapped to 
  parameter values by position, creating a Dict object. 
</p>
<p>
  For missing parameters, the value null is stored in the Dict.
</p>
<p>
  The String.merge() function logic replaces value null for a merge field with empty string.
</p>
<pre>
  data = PDict("a","b").mergeCodes
  &lt;&lt;&lt; SomeMarker
  Value of a: ${a}
  Value of b: ${b}
  &gt;&gt;&gt; SomeMarker
  -&gt;line 
    out(line.merge(data))
  /myMergedTemplate
</pre>
<p>
  If missing parameters is a problem, use the Dict.hasNullValue() function, which returns true
  if one or more values of the Dict is null.
</p>
<pre>
  data = PDict("a","b").mergeCodes
  error(data.hasNullValue,"Expected parameters a,b")
</pre>  







<h1>Use as a calculator</h1>


<h2>Expressions and "variables"</h2>
<p>
  Having a running instance of CFT on the desktop means access to a capable calculator.
</p>
<pre>
  $ 24*60*60
  &lt;int&gt;
  86400
  /x

  x*365
  &lt;int&gt;
  31536000
</pre>
<p>
  As noted before, the symbol "x" does not refer to the value 86400, but to the code that 
  generates the value.
</p>



<h2>Lib.Math</h2>
<p>
  The global function Lib() creates a Lib object, which in turn contains functions that
  create other objects, such as the Math object, which contains trigonometric functions.
</p>



<h2>Lib.Convert</h2>
<p>
  The Lib.Convert function returns another object, which contains code for lots of common
  conversions. Use the help system to show all options.
</p>
<pre>
  $ Lib.Convert help
</pre>



<h2>Lib.Plot</h2>
<p>
  The Lib.Plot function returns an object with functions for creating a primitive plot, for
  visualizing data. Again, use the help system to examine options.
</p>
<p>
  Note that Lib.Plot is a quick-and-dirty implementation. For better graphs, some external
  package should be invoked.
</p>
<pre>
  File("/tmp/" + currentTimeMillis+".txt")
  /tmpFile

  
  f = tmpFile
  Lib.Data.each(0,720)-&gt;i
    f.append(""+Lib.Math.sin(i) + "," + Lib.Math.cos(i))
  |
  Lib.Plot.typeTimeline.readCSVFile(f).plot(File("out.png"))
  f.delete
  /DemoPlot
</pre>
<p>
  The above code generates an example plot as a png file in the current directory.
</p>











<h1>Various topics</h1>
<p>
  In no particular order
</p>



<h2>Command line args</h2>
<p>
  If CFT is invoked with command line arguments, the first is the name of the script,
  that is, a savefile minus the "savefile" prefix and ".txt" ending.
</p>
<p>
 Then follows zero
  or more command lines, on string format. For values containing space or otherwise 
  have meaning to the shell, use quotes. Example:
</p>
<pre>
  ./cft Projects Curr
</pre>
<p>
  This loads script Projects, then calls the Curr function inside.
</p>






<h2>Calling functions in external scripts</h2>
<p>
  Sometimes we want to call a useful function in another script file. This is
  implemented with the "call" expression below.
</p>
<pre>
  call "Script:Function" (....)
</pre>
<p>
  Parameters are given as a list of values inside ()'s and may be omitted if no parameters.
</p>




<h2>Protecting directories and files</h2>
<p>
  In order to avoid accidental delete or modifications, both Dir and File have
  a function .protect() which takes an optional description string,  and 
  which attaches a protection status to that object.
</p>
<p>
  Any Dir and File objects created from such an object, inherit the protection status.
</p>
<pre>
  Dir("src").protect("Source")
  /dirSrc
</pre>

<p>
  Invalid operations result in an error, where the operation is described, along with the
  protection code (String).
</p>

<p>
  All source directories when searching should be protected, as well as log directories, if originals
  matter.
</p>


<h3>A protected directory does not allow</h3>

<ul>
<li>create</li>
<li>delete</li>
<li>copy file into dir - includes blocking File.uncompress when target dir is protected</li>
</ul>


<h3>A protected file does not allow</h3>
<ul>
  <li>delete</li>
  <li>create</li>
  <li>append</li>
  <li>copyFrom (target)</li>
  <li>copyTo</li>
  <li>move (source or target)</li>
</ul>






<h2>Working with pasted text lines from stdin</h2>
<p>
  If you've got some text in the copy-paste buffer that you want to work with, the 
  readLines() global functions can be used. It takes one parameter, which is an end-marker, which must 
  occur alone on a line, to mark the end.
</p>
<p>
  The readLines() function returns a list of strings, which you can turn into code and save under
  some function name, using synthesis.
</p>
<pre>
  readLines("XXX")
  (paste or enter text, then enter end-marker manually)
  XXX
  &lt;list&gt;
  0: ...
  1: ...

  :syn
  /someName
  
  ...
</pre>






<h2>Differing between Windows and Linux</h2>
<p>
  Calling function Sys.isWindows() is used to differ between the two in code. It does this
  by checking if (Java) File.separator is a backslash.
</p>
<pre>
  $Â Sys.isWindows
  &lt;boolean&gt;
  false
</pre>





<h2>Session state</h2>

<p>
  The session state is where previous values to Input() are stored, as well as values
  stored with ValDef(). When invoking some function in another script, that code runs in
  a separate environment ("ObjGlobal"), so as to avoid cross-contamination.
</p>
<p>
  Further, the separate environments for all external scripts invoked, are cached, so that
  each call to a function in the same script, is run within the same environment.
</p>
<p>
  This lets individual scripts have persistent session state, that is remembered between
  calls, which means Input() remembers what you typed in last time, etc.
</p>





<h2>Predicate calls</h2>
<p>
  Example: to decide if a string is an integer, without
  resorting to either creating a built-in predicate function like .isInt, or even
  using regular expression matching, there is the <em>predicate call</em> functionality,
  where one calls a function in a special way, resulting in a boolean value that tells
  if the call was ok or not.
</p>
<p>
  All dotted calls are made into predicate calls, by adding a '?' questionmark between the dot 
  and the function name. 
<pre>
  "sdf".?parseInt
  &lt;boolean&gt;
  false

  "123".?parseInt
  &lt;boolean&gt;
  true
</pre>



<h2>Try-catch</h2>
<p>
  Catching of exceptions in CFT is implemented as a global function, tryUnsafe(expr) which
  invokes the given expression, and returns a Dict object, detailing the outcome, and 
  preventing exceptions from terminating the running of CFT script code.
</p>
<pre>
  tryUnsafe(xxx) =x

  # Contains
  #    ok           - boolean
  #    result       - if ok, null if not
  #    msg          - exception message if not ok
  #    stack        - stack trace
</pre>
<p>
  Remember that blocks of code are expressions also.
</p>





<h2>Get type of value</h2>
<p>
  The global function getType() takes one parameter, and returns 
  the type name of that value, as a string
</p>
<pre>
  $Â getType(3)
  &lt;String&gt;
  int
  $ getType(Dict)
  &lt;String&gt;
  Dict
</pre>





<h2>List.push()</h2>
<p>
  The push() function of the List object pushes a number of value from the list onto the stack
  to be assigned in "logical" order, and allows us to supply a default value if list too short.
</p>
<pre>
  $ List("x","y").split.push(3,"*") =&gt;a =&gt;b =&gt;c a+":"+b+":"+c
  &lt;String&gt;
  x:y:*
</pre>




<h2>Dict set with strings</h2>
<p>
  Reading name-value assignments from a property file or similar, is best done via the .setStr()
  function on the Dict object. It strips whitespace and accepts both colon and '='.
</p>
<pre>
  Dict.setStr("a : b")
  /d
  d.get("a")
  &lt;String&gt;
  b
</pre>
<p>
  To process a property file, assuming commented lines start with '#', we can do 
  this:
</p>
<pre>
  P(1) =&gt;propFile
    Dict =&gt;d
    propFile.read-&gt;line
      reject(line.trim.startsWith("#"))
      assert(line.contains(":") || line.contains("="))
      d.setStr(line)
    |
    d
  /GetProps
</pre>





<h2>Dict fields as functions</h2>
<p>
  For readability, values with names that are valid identifiers, and don't collide with regular 
  member functions, can be referenced via dotted notation, for increased readability.
</p>
<pre>
  Dict.set("a","b")
  /d
  d.a
  &lt;String&gt;
  b
</pre>  




<h2>Dict.get with default value</h2>
<p>
  The Dict.get() method takes an optional default-value which is returned if no value
  associated with the name, but in that case the default value is <em>also stored</em> in the
  dictionary. 
</p>
<p>
  Usually this makes sense only for session objects.
</p>
<pre>
  ValDef("data",Dict)
  Val("data").get("a",3)
  &lt;int&gt;
  3

  Val("data").keys
  &lt;List&gt;
  0: a
</pre>




<h2>List.nth() negative indexes</h2>
<p>
  Using negative indexes to List.nth() counts from the end of the list. Using value -1 returns the
  last element, -2 the second last, and so on.
</p>
<pre>
  List(1,2,3,4).nth(-1)
  &lt;int&gt;
  
</pre>




<h2>Function parameters as List or Dict</h2>

<p>
  In addition to grabbing one parameter at a time, using P(pos), we can also process the
  parameter values as a list and as a dictionary.
</p>

<p>
  The function parameter expression P() when used with no parameters, returns a list of
  the parameter values as passed to the function.
</p>

<p>
  The PDict() expression takes a sequence of names to be mapped to parameters by position,
  resulting in a Dict object. Missing values lead to the special value null being stored
  in the dictionary.
</p>





<h2>The general loop statement</h2>
<p>
  In addition to looping over lists, there is a general loop construct. It identifies no
  loop variable, and loops forever, until break() is called. It also obeys assert()
  and reject() as with list iteration. 
</p>
<pre>
  a=0 loop break(a&gt;3) out(a) a=a+1
  &lt;List&gt;
  0
  1
  2
  3
</pre>
<p>
  If you forget to increment the variable a, or forget or create an invalid break(), then
  the loop may never terminate, and CFT has to be killed with ^C
</p>




<h2>Storing CFT data structures to file - syn() and eval()</h2>
<p>
  Session persistent data are stored and retrieved with ValDef() and Val(), but are obviously
  lost when the session ends.
<p>
  A more persistent solution is to store a data structure to file. This is done using
  the synthesis functionality, which is made available as a global function as well as the
  "colon command" used before. This means we can write huge lists and sets of files and
  directory objects to file, and restore it later, without going through possibly time
  consuming computations.
</p>
<p>
  To restore the structure, we use the global eval() function.

<pre>

  P(1)=&gt;file
  P(2,"data") =&gt;data
    file.create(syn(data))
  /saveData

  P(1)=&gt;file
  eval(file.read.nth)
  /restoreData
</pre>
<p>
  This can be used to save arbitrarily big structures, as long as they are synthesizable.
</p>




<h2>String .esc() and .unEsc()</h2>
<p>
  As was mentioned initially, CFT doesn't use backslash as an escape character. 
  However, we still require a way of converting "difficult" strings to code,
  via synthesis. For this purpose, the two functions String.esc() and String.unEsc() was
  created.
</p>
<p>
  One rarely needs to call these manually, but they are worth mentioning, as sometimes synthesis
  of a string may result in code such as this:
</p>
<pre>
  "^q^aa^a^q".unEsc
</pre>



<h3>Escape codes</h3>
<p>
  For an escaped string, the escape character is the ^ symbol.
</p>
<ul>
  <li>"Double quotes" ^q</li>
  <li>'Single quotes' / Apostrophe ^a</li>
  <li>Newline ^n</li>
  <li>Carriage Return ^r</li>
  <li>Tab ^t</li>
  <li>The ^ symbol ^^</li>
</ul>
<p>
  To gives a way of creating strings with newlines inside.
</p>
<pre>
  "this^nis^na test".unEsc

  &lt;String&gt;
  this
  is
  a test 
</pre>



<h2>Automating interactive functions / Sys.stdin()</h2>
<p>
  Functions may query the user with Input("prompt").get and readLine("prompt"). If we want
  to automate such functions, we use function Sys.stdin() to buffer up any number of 
  input lines. 
</p>
<pre>
  Sys.stdin("read-this") Input("Enter data").get
  &lt;String&gt;
  read-this
</pre>
<p>
  Note that both Input.get() and readLine() detect if there is buffered input, and
  if so, do not display the prompt or other info. Particularly useful for Input.get(),
  since buffering the empty string "" with Sys.stdin() means repeating the last value.
</p>




<h2>Running colon commands from script code</h2>
<p>
  Using the Sys.stdin() statement without being followed by Input.get() or readLine(), is just 
  another way of entering commands. This means colon commands are available from CFT code.
</p>
<pre>
  stdin("2+3")
  &lt;int&gt;
  5
</pre>
<p>
  This can be exploited to let a script modify itself, by redefining
  functions, although that will be troublesome if those functions read input. A better
  use is that of running colon commands, particularly loading scripts. This is used
  frequently with shortcuts.
</p>
<pre>
  stdin(":load SomeScript","?")
</pre>






<h2>Simple line editing</h2>
<p>
  When using CFT mainly in interactive mode, a primitive line editor can be used to modify
  the code of an existing function, by optionally cutting off text following a pattern, as well
  as optionally adding text. 
</p>
<p>
  The syntax is as follows
</p>
<pre>
  $ !x!       # inserts code from function x as text, then executes it
  $ !x! txt   # inserts code from function x, followed by " txt", then executes it
  $ !x:p!     # inserts code from function x up to but not including pattern 'p'
  $ !x:p! txt
</pre>

<h3>Develop complex code in steps</h3>
<pre>
  $ Dir.files
  $ /x
  $ !x!-&gt;f out(f)
  $ /x!
  $ !x:out!assert(f.name.endsWith(".txt")) out(f)
  $ /x!
</pre>

<p>
  Note: this only applies to single-line functions.
</p>




<h2>CFT.props - mCat, mEdit and mMore lambdas</h2>
<p>
  The configuration fields mCat, mEdit and mMore ("m" for macro) define lambdas
  that are called for interactive commands cat/edit/more. This means it is possible
  to redefine what edit means. Currently, mEdit calls either "Lib:e". The
  mMore lambda calls "Lib:m", while the mCat macro just calls .read on file parameter.
</p>





<h2>CFT.props - shortcuts</h2>
<p>
  The CFT.props text is self explanatory.
</p>
<pre>
# Shortcuts
#
# The shortcuts are lines of code. If that code results in a macro, it is invoked with
# no parameters. Since we don't need parameters, there is really no need for macros
# here. The return value from a shortcut becomes the "last value", available
# via Sys.lastResult, as well as used by :syn etc
#
# Note that shortcuts only work when the prefix is at the start of the interactive
# input line. 
# ---
shortcutPrefix = @

shortcut:r = Sys.stdin(":load Release","?")
shortcut:p = Sys.stdin(":load Projects","?")

# List available shortcuts when typing '@' only
# ---
shortcut: = File("CFT.props").read-gt;line assert(line.contains("shortcut:")) out(line)
</pre>
<p>
  This means that typing @r loads the Release script, then executes the '?' command, which
  lists its content.
</p>

<h3>Show all shortcuts</h3>
<p>
  To list defined shortcut, just type 
</p>
<pre>
  $ @
</pre>
<p>
  This is a shortcut itself, that traverses the CFT.props file and identifies and 
  displays the
  shortcut definitions from it.
</p>



<h1>Some example code</h1>

<h2>Windows PowerShell</h2>
<p>
  The following code is an effective way of using PowerShell from CFT, saving lots of typing.
</p>
<pre>
  host=P(1) cmd=P(2) ## Run remote PowerShell script-block 
    List("powershell","invoke-command","-computername",host,"-scriptblock","{" + cmd + "}") =&gt;fullCmd
    Dir.run(fullCmd)
  /PSRun

  # List services via PowerShell (interactive)
    Input("Host").get =&gt;host
    Input("Service name (including wildcards)").get =service
    "get-service -name " + service =&gt;cmd  # no splitting
    PSRun(host, cmd)
  /PSGetServ

</pre>


<h2>Windows CMD</h2>
<p>
  Running commands using CMD in windows, mostly requires the "/c" flag.
</p>
<pre>
  Dir("...")
  /DirProject

  # Add, commit and push with git
    DirProject.run("cmd","/c","git","add",".")
    msg=Input("Commit message").get
    DirProject.run("cmd","/c","git","commit","-m",msg)
    DirProject.run("cmd","/c","git","push","origin","master")
  /GitPush
</pre>


<h2>Linux get user name</h2>
<pre>
  Dir.runCapture("whoami").nth
  /GetUser
</pre>




<h1>Lib.Text.Lexer</h1>
<p>
  <i>v1.2.0 EXPERIMENTAL</i><br/>
  <i>v1.3.2 Lexer stabilizing</i>
</p>
<p>
  The Lib.Text.Lexer objects adds 
  capability to match complex tokens with CFT, using the same Java tokenizer that is used when
  parsing CFT script code. 
</p>
<h2>Motivation</h2>
<p>
  Working with log data, it would be nice identifying data in log lines beyond
  doing free text searches. The Lexer is the first step, and will in time be followed by 
  some more classes, including a basic recursive-descent parser.
</p>

<h2>Concept</h2>
<p>
  The concept is that of a tree of maps, each map maps single characters to other maps, and so on.
  If map A contains mapping of digits 0-9 pointing at map B, and our parse process so far has led 
  us to map A, with next input character being 0,1,2,3..., then that character is "consumed", which is
  fancy speak for matched, and the current map becomes B. The process then repeates.
</p>
<p>
  If the current map has no mapping for the current next character, then one of the following happen:
</p>
<ol>
  <li>If the current map is marked with "this is a token", then parsing succeeds</li>
  <li>Otherwise, we backtrack, unconsuming previourly consumed characters, until finding a map that "is a token"</li>
  <lI>Or ,if no map in our parse tree has the "this is a token" mark set, then parsing fails</li>
</ol>

<h2>Implementation</h2>
<p>
  In the CFT functions, such maps are called nodes. They are created via the
  Lib.Text.Lexer.Node function.
</p>
<pre>
  $ Lib.Text.Lexer help
  
  # Node(firstChars?) - create empty node, possibly identifying firstChars list
  # getTokenStream() - get list of tokens identified via processLine as TokenStream object
  # getTokens() - get list of tokens identified via calls to processLine
  # processLine(rootNode,line,eolTokenType?) - processes line, adds to internal token list - returns self
</pre>
<p>
  The nodes in turn contain the following:
</p>
<pre>
  $ Lib.Text.Lexer.Node help

  # addToken(token) - create mappings for token string, returns resulting Node
  # match(Str) - returns number of characters matched
  # setDefault(targetNode?) - map all non-specified characters to node, returns target node
  # setIsToken(tokenType) - tokenType is an int - returns self
  # sub(chars, targetNode) or sub(chars) or sub(targetNode) - add mapping, returns target Node
</pre>
<p>
  A simple example:
</p>
<pre>
  top=Lib.Text.Lexer.Node
  x=top.sub("0123456789")   # new node
  x.sub("0123456789",x)  # x points to itself for digits
  x.setIsToken(1) # token type: non-negative numbers for regular tokens

  top.match("300xx")  # returns 3, matching sequence '300'
</pre>
<p>
  The match() function is for testing only.
</p>



<h3>.sub()</h3>
<p>
  The sub() function of any node is used to connect pointers from one map to another. It takes 
  three forms:
</p>
<pre>
  (1)
  someNode.sub("abc",someOtherNode)  
    # when at someNode and one of the characters ("abc") are next character in input
    # string, then consume character, and move to that other node, which may of course
    # be the same node or some other node

  (2)
  someNode.sub("abc")
    # When no node parameter, an empty node is created, which "abc" points to from
    # someNode. The new node is returned

  (3)
  someNode.sub(someOtherNode)
    # When creating libraries of reusable nodes, they always must define a set of
    # characters which are called "firstChars". These are the characters that indicate
    # the start of some sort of data. For example for Lib.Text.Lexer.Identifier, the
    # "firstChars" are "a-zA-Z_". It's the letters an identifier can start
    # with. Similarly we can create our own library node functions, by supplying a
    # firstChars list as parameter to Lib.Text.Lexer.Node
    #
    # So what happens is that inside someNode, pointers are added to someOtherNode for
    # all characters in that node's firstChars.
</pre>


<h2>Reusable nodes - integer sequence</h2>
<p>
  To create a reusable node, we need to specify the "firstChars" of a node, which are given
  as parameter when creating an Node node. This means adding it as "sub" under some other node,
  lets those characters point at it.
</p>

<pre>
  # Create reusable node for integers. 
    "0123456789"=&gt;digits
    Lib.Text.Lexer.Node(digits) =&gt;x
    x.sub(digits,x)
    x.setIsToken(1)

    x
  /NodeInt

  # Now we can for example match a IP v4 address
    Lib.Text.Lexer.Node =top
    a=NodeInt
    b=NodeInt
    c=NodeInt
    d=NodeInt
    
    top.sub(a)
    a.sub(".").sub(b) # creates intermediary nodes for the dots
    b.sub(".").sub(c)
    c.sub(".").sub(d)
    d.setIsToken(2)

    top
  /MatchIPAddress

  # Test
  "192.168.1.1 255.255.x 10.0.0.1 1.2.3 .4".split-&gt;word
    report(word, MatchIPAddress.match(word))
    # should return 11,0,8,0,0
  /t1
</pre>


<h2>Processing single lines</h2>
<p>
  To process all text in a line, we need to build a root node to which we add
  pointers to sub-nodes for all valid tokens. For simplicity, let us match only
  identifiers.
</p>
<p>
  Since identifiers are separated by space, we also need to match
  whitespace. Since we are not interested in whitespace, we assign whitespace 
  tokens a negative token type, as those get automatically ignored.
</p>
<pre>
# Identifiers
  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_" =&gt;firstChars
  firstChars+"0123456789" =&gt;innerChars
  
  ident = Lib.Text.Lexer.Node(firstChars)
  ident.sub(innerChars,ident)
  ident.setIsToken(1)
  
  ident
/Identifiers

# Whitespace
  " ^t^n^r".unEsc =&gt;chars
  Lib.Text.Lexer.Node(chars) =&gt;ws
  ws.sub(chars,ws)
  ws.setIsToken(-1)
    
  ws
/WhitesSpace

# Root node
  Lib.Text.Lexer.Node =&gt;root
  root.sub(Identifiers)
  root.sub(WhiteSpace)
/Root
</pre>
<p>
  With the Root node ready, we can now parse strings consisting of identifiers and space, 
  ignoring space.
</p>
<pre>
# Test
  Lib.Text.Lexer.processLine(Root,"this is a test").getTokens->token
    report(token.sourceLocation, token.str, token.tokenType)
/test
</pre>
<p>
  Now running the test we get
</p>
<pre>
  $ test
  &lt;List&gt;
   0: pos=1  | this | 1
   1: pos=6  | is   | 1
   2: pos=9  | a    | 1
   3: pos=11 | test | 1
</pre>


<h2>Processing files</h2>
<p>
  Processing files is easy, using File.read and iterating over those, calling .processLine
  on the same Lexer object. If we want, we can let the lexer add "newline"-tokens at the end
  of each line, by just defining a token type, here we use 100.
</p>
<pre>
# Process file
  Root =&gt;root
  Lib.Text.Lexer =&gt;lexer

  File("...").read-&gt;line 
    lexer.processLine(root,lexer,100) 
  |
  
  lexer.getTokens-&gt;token
    report(token.sourceLocation, token.str, token.tokenType)
/ProcessFile
</pre>
<p>
  The Lexer.processLine is smart enough to detect when lines are read from a file, as
  lines read from file are not regular strings, but a subtype of String, which contain
  filename and line number. This info is included in the sourceLocation available
  for each token.
</p>


<h2>Limitations</h2>
<p>
  As there is at most one pointer per character in each node, we can not both recognize
  identifiers AND certain keywords, such as "begin" and "end", separately. Unless of course
  the keywords start with a different sequence of characters in front, that make them
  unique from identifiers.
</p>
<p>
  With the "symbols" we can easily recognize both "=" and "==" as symbols, because the second
  is an extension of the first, and the "=" node is not configured to match any stream
  of "=", such as identifiers are for letters and numbers.
</p>
<p>
  This also means we can not both match integer and dates on numeric format, such as
</p>
<pre>
  2020   # integer
  2020-09-12   # date
</pre>

<h2>Different uses</h2>
<p>
  Parsing a programming language or JSON structure, requires us to identify every
  token in the string. The lexer tree must house them all.
</p>
<p>
  Parsing a log line piece by piece does not have this requirement. Different 
  lexer nodes may be used for each part of the line, some allowing for alternatives,
  most just looking to match a fixed format string, for which regular expressions
  would also be suited.
</p>


<h2>Complex tokens</h2>
<p>
  For the case where we want to identify parts of a log line, one token at a time, 
  individual token definitions may not co-exist under a shared root, but that is
  exactly the point: we have clear expectations for what we look for, at any time.
</p>
<p>
  The Node.addTokenComplex() function is not one that lives happily together with
  others.
</p>

<h3>Regular Node.addToken() example</h3>
<p>
  With the normal .addToken() function, we can do something like this:
</p>
<pre>
  Lib.Text.Node =&gt;grade
  "A AA AAA B C".split->x grade.addToken(x).setIsToken
</pre>
<p>
  Overlapping definitions, such as "A" and "AA" and "AAA" is not a problem for Node.addToken()
</p>




<h3>Node.addTokenComplex() example</h3>
<p>
  This function adds a token, where some of the characters in the token string map to 
  sets of characters, via a Dict object. This function does not have the freedom to
  expand and reuse existing (overlapping) nodes, as with the regular .addToken() function.
</p>
<p>
  It is meant for matching one thing only, and not for collecting all token definitions
  under a shared root, as before. It is targeted at the Parser object, as well as stand-alone
  specific matching.
</p>
<pre>
  Lib.Text.Node =&gt;date
  Dict.set("i","0123456789") =&gt;mappings
  date.setTokenComplex("iiii-ii-ii", mappings).setIsToken

  date.match("2020-09-15xxx")  # returns 10 (characters matched)
  date.match("2020-009-15xxx") # returns 0 (no match)
</pre>
<p>
  Feels like Regex character classes, no?
</p>








<h1>Closures</h1>
<p><i>v1.3.1</i></p>
<p>
  A closure is created by binding a Lambda to a Dict object. The Closure
  has a .call function just like the Lambda, and invokes the lambda, with
  the Dict object referenced via "self" variable.
</p>
<p>
  Nice for event based callbacks.
</p>
<pre>
  Dict =&gt;data
  data.bind(Lambda{
    self.set("received_value", P(1))
  }) =&gt;closure

  closure.call("test")
  data.get("received_value")  # returns "test"
</pre>
<p>
  For robustness and testing, when lambdas are run directly (not via closures)
  there is also a "self" variable, which points at an empty Dict object.
</p>
<h2>Another example</h2>
<p>
  Here we create a Closure that when called strips N characters from the
  start and end of a string.
</p>
<pre>
  P(1)=&gt;n
  Dict.set("n",n).bind(Lambda{
    P(1)=&gt;s 
    self.get("n")=&gt;n
    s.sub(n,s.length-n)
  })
/Strip
</pre>
<p>
  Test:
</p>
<pre>
  $ Strip(2).call("this is a test")
  &lt;String&gt;
  is is a te
</pre>





<h1>Primitive objects</h1>
<p><i>v1.3.1</i></p>
<p>
  Storing both data and lambdas inside a Dict, and using the .invoke() function of the
  Dict, we can now call a lambda stored under some name, with the dictionary object
  accessed via the "self" variable.
</p>
<pre>
  Dict
    .set("i",1)
    .set("incr",Lambda{
      P(1,1) =amount
      self.set("i",self.i+amount)
    })
    =&gt;data

    data.invoke("incr",10) # data.i is now 11
</pre>

<h4>Member lambdas calling each other</h4>
<p>
  One such lambda function can in turn call other Dict member functions in the same way,
  via self.invoke(...)
</p>
<pre>
  Dict
    .set("i",1)
    .set("incr",Lambda{
      P(1,1) =amount
      self.set("i",self.i+amount)
    })
    .set("incr50",Lambda{
      self.invoke("incr",50)
    })
    =data

    data.invoke("incr50")  # data.i is now 51
</pre>







<h1>Reference: Colon commands</h1>
<p>
  Colon commands are best described by entering a single colon at the CFT prompt.
</p>

<pre>
$ :

Colon commands
--------------
:save [ident]?           - save script
:load [ident]?           - load script
:new                     - create new empty script
:sw [ident]?             - switch between loaded scripts
:delete ident [, ident]* - delete function(s)
:copy ident ident        - copy function
:wrap                    - line wrap on/off
:debug                   - enter or leave debug mode
:syn                     - synthesize last result
:&lt;int&gt;                   - synthesize a row from last result (must be list)
:quit                    - terminate CFT

</pre>
<p>
  Confusing colon commands with shortcuts? You're not alone.
</p>
<p>
  Colon commands exist outside the language, and are fixed (written in Java), while shortcuts run CFT program
  code, and are defined in the CFT.props file. So far all good.
</p>
<p>
  The "problem" is that CFT code (and so shortcuts) can run colon commands via "abusing" the Sys.stdin() command.
</p>





<h1>Reference: Synthesizable types</h1>
<ul>
  <li>boolean</li>
  <li>int</li>
  <li>float</li>
  <li>string</li>
  <li>null</li>
  <li>List</li>
  <li>Dir</li>
  <li>File</li>
  <li>FileLine</li>
  <li>Date</li>
  <li>Date.Duration</li>
  <li>Int</li>
  <li>Float</li>
  <li>Str</li>
  <li>Dict</li>
  <li>Glob</li>
  <li>Regex</li>
</ul>






<h1>Fun and strange stuff, comments</h1>



<h2>Why Input("label").get?</h2>
<p>
  Why can't the Input() function just ask the user for input? Why the .get()?
</p>
<p>
  This is because it was envisioned more functions on the Input object, such as 
  programming it to reset its remembered values, or get values from other sources.
</p>
<p>
  This never came to fruition, and with Input() being a pretty old function, Input("xxx") remains an object, with a single .get() function inside.
</p>
<p>
  At least it leaves us with the option of adding clever stuff later.
</p>


<h2>Function name AFTER code?</h2>
<pre>
  Dir.files
  /showFiles
</pre>
<p>
  This stems back to the time of entering code line by line. Having to decide the name of a function before
  seeing how much functionality you got crammed into one line, or if it at all worked,
  made little sense. Instead you write some code
  that does something useful, then decides what to call it.
</p>
<p>
  This might at some point be changed, at least for script files, as it still feels backward, but this 
  is the reason.
</p>
<p>
  The syntax with the slash and an identifier was inspired by PostScript.
</p>




<h2>Using Sys.stdin to run colon commands etc</h2>
<p>
  That functionality an example of an "unexpected feature", as the Sys.stdin() was created to automate functions that used
  Input and readLine(). There was a moment of confusion when discovering what happened to input lines not consumed
  by those interactive functions.
</p>
<p>
   Great fun!
</p>



<h2>2020-09-12 Inner blocks??</h2>
<p>
  The first block expression added to CFT, was what is now called the Inner block. Then immediately followed
  macros, now called Lambdas. The local blocks were introduced in the v1.3 overhaul. 
</p>
<p>
  The previous "odd" syntax for creating macros has gotten more explicit, and who talks
  about "macros" these days? The functionality is the same, though.
  A search/replace on all the script files fixed the renaming easily.
</p>
<pre>
  {* ...} =macro  # old syntax - no longer supported
  Lambda{...} =lambda
</pre>
<p>
  The Inner block expressions do not resemble code blocks in Java, because in reality they are automatically
  executing lambdas, with scope extending out to the calling environment. Lambdas and block expressions were
  an afterthought, something created because it was possible. There was no real need, apart from 
  simplifying the odd conditional assigment .....
</p>
<pre>
  if(addOne, value+1, value) =value
</pre>
<p>
  In the first versions
  of the doc, there were some really artificial examples of what "macros" and expression blocks 
  could be used for.
</p>
<p>
  Now, with local block expressions added in v1.3, and the "if" expression accepting dual syntax,
  code can be organized much more logically
  for Java/C/JS programmers.
</p>



<h2>2020-09-12 Closures and objects</h2>
<p>
  After creating v1.3.0 which rearranged two block expressions into three (Lambda, Inner and Local),
  I had pondered how to do closures and objects.
</p>
<p>
  These were created mainly created for fun, though they of course have uses.
</p>
<p>
  The solution ended up being very easy to implement, and is fairly elegant,
  as they really are about using the same mechanism, being that all running
  lambdas have a "self" variable pointing to some Dict object.
</p>


<h2>2020-09-12 A lexical analysis discovery</h2>
<p>
  As the Lib.Text.Lexer object was created, and I experimented with it, I discovered
  that what I had thought to be a limitation in the parser, was an error made by me.
</p>
<p>
  The problem was that CFT did not handle calling functions inside integer literals,
  except with a space between the number and the dot, like this:
</p>
<pre>
  $ 3 .bin
</pre>
<p>
  The problem was that my configuration for parsing floating point numbers
  was flawed. Basically it looked like this (converted to Lib.Text.Lexer syntax)
</p>
<pre>
  "0123456780"=digits
  Lib.Text.Lexer.Empty(digits) =intMatcher
  intMatcher.sub(digits,intMatcher)
  intMatcher.setIsToken  # so far all good

  intMatcher.sub(".") =afterDot
  afterDot.sub(digits, afterDot)
  afterDot.setIsToken
</pre>
<p>
  The problem here is that when the intMatcher finds a ".", and follows the link to 
  the afterDot node, that node has the is-token flag set, so even if there are no
  digits following the dot, the matcher believes it has matched a float. The result
  is that "3." is considered a valid float, and that the the text following now is "bin", 
  which is correctly recognized as an identifier, but the parser does not recognize it
  as a dotted call, as the dot has been incorrectly consumed. 
</p>
<p>
  The fix is simple. The "." must point to a node that does not have the is-token flag set,
  but instead has pointers for digits 0-9 to another node, which does, and which
  gobbles up any additional digits via a self-loop. 
</p>
<pre>
  "0123456780"=digits
  Lib.Text.Lexer.Empty(digits) =intMatcher
  intMatcher.sub(digits,intMatcher)
  intMatcher.setIsToken(3)

  intMatcher.sub(".") =afterDot  
  afterDot.sub(digits) =afterDotDigits  # new node
  afterDotDigits.setIsToken(4)
  afterDotDigits.sub(digits,afterDotDigits)
</pre>
<p>
  Lexing and parsing is fun, and I really enjoyed learning new things about my own code after 2+ years
  of assuming I had hit a limitation.
</p>
<p>
  I am going to enjoy writing the parser. CFT uses a "hard-coded" recursive descent
  parser, with Java classes calling each other. 
</p>
<p>
  This means that a parser that is configurable from CFT code has to be written from
  scratch. With the v1.3.0 branch safely merged into master, and closures and dictionaries
  as objects implemented, it's time to start 
  considering parsing again.
</p>



</body></html>