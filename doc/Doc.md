NOTE: This file is autogenerated from Doc.html.
There may be various formatting problems, particularly example code.

If you have problems, consider viewing the Doc.html file instead.


# CFT / ConfigTool

```
Last updated: 2020-11-13 RFO
v1.9.14
```
# Introduction


CFT is an interactive programmable environment for automation.


Automating tasks is done by creating functions, which are named sequences
of code. Functions call each other, as well as a library of global functions, and functions
inside system objects, such as:



- directories


- files


- lists


- dictionaries



CFT is tested on Linux and Windows, and easily integrates with external commands
on both, such as PowerShell, git, ssh. It should run anywhere that supports Java.


Development has been going on since May 2018, and on github since July 2020.

# Platform


CFT is written in Java and uses no external libraries. It has been tested on both Linux
and Windows.


For best result on Windows, it is recommended to use "Windows Terminal", as it understands
the ANSI escape sequences directly.


Alternatively, if using a CMD or PowerShell window, disable Curses by running Curses:Disable once.
The decision is then stored in the local database.

# Functionality


The CFT programming language is a glue between library functions and -objects, user input, and
running external programs.


It is command line based, but complex functions are created using editors.

The language is object oriented, with all values being objects. Here we call a
function "bin()" inside an integer object.

```
$ 1.bin
<String>
00000001
```

The ".bin" calls the function "bin" inside the integer object. Parantheses are optional when no parameters.

## Another example

```
$ Dir.files.length
<int>
12
```


- The "Dir" global function returns the current directory as a Dir-object


- We call the "files" function in the directory object, it returns a list object


- We call the "length" function in the list object, it returns an int object


# Getting help

## Show all global functions

```
$ help
```
## Show functions inside objects


To show all functions inside an object, create an instance of that object followed by the word help.
Specifically, the help statement takes the value on top of the stack and lists it's available
functions.

```
$ 1 help               # integer
$ 3.14 help            # float
$ "xxx" help           # string
$ List help
$ Dict help
$ Dir help
$ File("x.txt") help   # the file needs not exist
```
# Create functions


Everything you type in at the prompt is considered code, and executed.


Then, if you want, you can assign a name to the last line of code, and now you have a function.

```
$ Dir.files.length
<int>
12
$ /filesInDir
```

The code line that gives us the number of files in the current directory is now named "filesInDir", and can
be run again as follows:

```
$ filesInDir
<int>
12
```
# Show your functions


List all functions in current script

```
$ ?
```

To show the code of a function:

```
$ ? name
```

If the name doesn't match one function, it is used as a prefix to list a subset
of all functions.

# Save and load


Functions are saved into script files, via "colon" commands, which are system commands outside
the CFT language.

```
$ :save myscript
$ :load otherscript
```
# Edit script file


Instead of entering code via the command line, the script file can easily be opened in
an editor. To do this, the current script must be saved, then enter the following:

```
$ @e
```

This opens the script in an editor. On linux you will be asked which editor you prefer.
This is remembered within the session. To use a different editor, type @ee instead.


After changing a script in the editor, and saving, CFT automatically detects the change, and
reloads the script the next time you press ENTER.

# Shortcuts vs colon commands


Shortcuts are ways of running code, while colon commands are system commands.


View all colon commands:

```
$ :
```

View all shortcuts:

```
$ @
```

Shortcuts are defined in the CFT.props file.

# CFT as a shell


Commands like "ls" and "cd" exist, with globbing, as well as "more" and "edit" (which opens a file
in an editor), and they are meant for moving around the directory tree.

```
$ pwd
$ cd ..
$ ls *.txt
```

The shell 
**does not** include commands that move, delete or copy files and directories. This
is by choice.

## The "protect" mechanism


Performing changes, such as copying, deleting and creating files, is supposed to be scripted
with code, so no "command line" style functionality exists for this.


This of course doesn't exclude these actions from the command line, but the syntax changes
from regular "cp" and "rm" commands typical of unix shells.

```
$ <DirExpression>.file("xxx.txt").delete
```

The point here is that the "DirExpression" as well as functionality to provide sets of files
and similar, are CFT code, and CFT has a special provision to avoid deleting or modifying the wrong
files or directories: 
**the "protect" mechanism**.


Usually, when working with multiple files and directories, we create functions that return
these. The "protect" mechanism means we can do the following:

```
$ Dir("/someNFSDir/logs").protect
$ /LogDir
```

What this does is set an internal flag in the Dir object that the function creates, that prevents
operations like deleting or modifying the directory, as well as all Dir and File objects derived
from it, for example like this:

```
$ LogDir.file("log01.txt").delete
ERROR: [input:18] INVALID-OP delete : /someNfsDir/logs/log01.txt (PROTECTED: -) (java.lang.Exception)
```
## The "shell" command


One can also run the global "shell" command, perform changes, and then return via "exit":

```
$ shell
roar@pc01$ rm xxx.txt
roar@pc01$ exit
# Running bash completed
$
```
## Show content of file


Now if we want to list content of file "TODO.txt", we can enter

```
$ cat TODO.txt
$ more TODO.txt
```
## Open a file in editor

```
$ edit TODO.txt
```
# List basics


Lists are return value from many functions, such as getting the files in a directory.


Lists can also be created
with the global List() function, which takes any number of parameters, and creates a List object
from those values.

```
$ List                 # empty list
$ List(1,2,3,4)
$ Dir.files
$ "abcdef".chars
$ "one two three".split
$ "one:two:three".split(":")
```

Many functions are available on a List object. One frequently used is "nth", which
gets a specific element, defaulting to 0 if no argument.

```
$ List("a","b","c").nth
<String>
a
```

For details of available functions, use the help system:

```
$ List help
```
# Introduction to loops


Loops in CFT are mostly concerned with iterating over lists. Let's create a list:

```
$ Dir.allFiles(Glob("*.java"))
```

This line of code generates a list of all java files under the current directory or sub-directories.
When we are satisfied with the result of the code line, we give it a name.

```
$ /JavaFiles
```

We then iterate over the list of files returned, and count the number of lines in each, then
sum it all up, creating the "linecount" function.

```
$ JavaFiles->f out(f.read.length) | _.sum
<int>
18946
/linecount
```

The "arrow" followed by an identifier is the "for each" construct, with the identifier becoming
the "loop variable".  The out() statement is used to generate output from the loop.


The "pipe" character terminates the loop, and delivers the result from the loop (list of int) to the next part,
where the "_" (underscore) symbol picks it off the stack, then calls the sum() function on it,
returning a single int value.


**Note:** loop variables are not regular variables, and can not be reassigned.

## Filtering


Filtering list data is essential in CFT. Here is a simple example:

```
$ List(1,2,3,4,3,2,1)->
x assert(x>
2) out(x)
<List>
3
4
3
```

The assert() works like "if condition not satisfied, continue with next value"

# Local variables


Function code may use local variables for simplifying expressions.

```
$ a=3 b=2 a+b
<int>
5
```

Can also use "stack based" notation, where the assignment picks the current value
off the stack and stores it into a variable:

```
3=>a 2=>b a+b
5
```

Example:

```
List("java","txt")
/types
Dir.allFiles->f type=f.name.afterLast(".") assert(types.contains(type)) out(f)
/textfiles
```

This function lists all files of type .java and .txt

# Files

```
$ File("x.txt")
<obj: File>
x.txt   DOES-NOT-EXIST
```

The File() function requires a name, and returns a File object. As seen
above, the file needs not exist.


File objects created with a simple file name (no path), are always located in
the CFT home directory. This gives predictability for certain data files etc.


To access or create files in other directories, enter an absolute or relative
path in the parameter to File(), or use the file() function inside
some Dir object:

```
$ Dir.sub("src").file("x.txt")
```
## Page through a file


To page through text file

```
more x.txt
```
## Show bytes of file


To page through hex listing of file

```
File("x.txt").hex
```
## Encoding


Default encoding is "ISO_8859_1", but this can be changed, for example:

```
File("x.txt").encoding("UTF-8")
```
# Directories

```
$ Dir
<obj: Dir>
ConfigTool/ d:5 f:20
```

Calling the Dir function with no parameters returns a Dir object for the current directory.


The Dir
object offers multiple member functions, one of which is 
**.files()**, which produces a list of files in
the directory. Another is 
**.allFiles()** which return files from all subdirectories as well.

## Create a subdirectory

```
Dir.sub("someDir").create
```
## Parent directory


To get the parent directory of a Dir object:

```
Dir.sub("..")
```
## Get files in a directory

```
Dir.files
```
## Create a file in a directory

```
Dir.file("x.txt").create("something")
```
## Get immediate directories in a directory

```
Dir.dirs
```
## Get all files recursively under a directory

```
Dir.allFiles
```
## Get all directories recursively under a directory:

```
Dir.allDirs
```
## Delete a sub-directory


The sub-directory must be empty

```
Dir.sub("something").delete
```
## Set current directory


Apart from navigating interactively, to set current directory via code:

```
Dir.setAsCurrentDir
```
# The shell() function


The global shell() function starts a shell inside CFT. When you exit from it, you're back
in CFT.

```
$ shell
(starts bash or cmd or Powershell or something else)
exit
# Running /usr/bin/bash completed: 25529ms
$
```

The shell function is configured in the CFT.props file which must exist in the CFT
home directory.

```
shell = bash
winShell = powershell
```
# Core types



- String


- int - (Java long)


- float - (Java double)


- boolean


- List


- Dict



All values in CFT are objects, which may contain functions. Strings can be written using double
or single quotes.

## String literals


Strings are written in single or double quotes, and can be summed with '+', which allows
for all kinds of combinations.

```
$ "double quotes"
$ 'single quotes'
$ "'a'"
<String>
'a'
$ '"' + "'a'" + '"'
<String>
"'a'"
```

Also, backslash is not used as escape character, which means backslash is just another character,
simplifying those Windows paths.

## Dictionaries


Dictionaries are maps that store any value identified by names (strings).

```
$ x=Dict x.set("a",1) x.get("a")
<int>
1
```
### Properties as functions


For readability, values with names that are valid identifiers, and don't conflict with regular
member functions of Dict, can be referenced via dotted notation

```
Dict.set("a","b")
/d
d.a
<String>
b
```
### SymDict


A special global expression, SymDict is used to create a dictionary from a list of
symbols, which must be present as local variables, or parameterless functions. This
saves some typing. Example:

```
# Without SymDict()
a=1
b=2
dict=Dict.set("a",a).set("b",b)
# With SymDict
a=1
b=2
dict=SymDict(a,b)
```
# List iteration / filtering


Lists are essential for all processing with CFT.


Lists can be created manually using the global List() function.

```
$ List(1,2,3)
$ List("a","b","c")
```

A much used way for creating lists of strings, is to use the string function split(), which by default
splits a string on spaces. This means the following produce the same result.

```
$ List("a","b","c")
$ "a b c".split
```
## Iterating over list content


The iterator in CFT takes the form of an arrow followed by a loop variable. For a loop construct
to return output, we use the out() statement inside.

```
$ "1 2 3".split->x out("a"+x)
<List>
0: a1
1: a2
2: a3
```

The result is a list of strings, as displayed.

## Filtering with assert(), reject() and break() + out()


Using the assert() statement, we may abort processing for elements that do not meet a condition.

```
$ Dir.allFiles->f assert(f.name.endsWith(".java")) out(f)
```

The reject() statement is the inverse of assert(), and aborts processing for elements that meet
a certain condition.

```
$ List(1,2,3,2,1)->x reject(x>2) out(x)
<List>
1
2
2
1
```

The break() statement terminates ALL LOOPS if the condition is true.

```
List(1,2,3,2,1)->x break(x>2) out(x)
<List>
1
2
```
## The condOut() statement


In addition to controlling loops with assert/reject and break, there is the condOut()
statement, which takes a boolean condition as first parameter, and the value to
be sent out as second parameter. Can be useful some times.

```
$ List(1,2,3,2,1)->x condOut(x<2,"(") out("b") condOut(x<2,")") | _.concat
<String>
(b)bbb(b)
```
## List addition


Two lists can be added together with "+".

```
List(1,2) + List(3)
<List>
1
2
3
```

Also, elements can be added to a list with "+" as long as the list comes first.

```
List(1,2)+3
<List>
1
2
3
```
# List sorting


The List object has a single .sort() member function, which does the following:



- if all values are int, sort ascending on int value


- if all values are float, sort ascending on float value


- otherwise sort ascending on "string representation" of all values



Now, to sort other types of values, we use a "trick", which consists of wrapping each
value inside a special wrapper object, masking the original values as either int, float
or STring, then sort, and finally extract the actual value from the wrappers.


To sort a list of files on their size, biggest first, we do the following:

```
Dir.files->f
out(Int(f.lastModified,f))
| _.sort.reverse->x
out(x.data)
```

The first loop wraps each File object inside an Int object, which is created by
supplying two values to global function Int: the value to sort on, and the object itself.


Then the resulting list is "piped" to code that picks it off the stack, sorts and
reverses it, before iterating over the result, and for each object (now the Int objects),
outputs the original File object, available via the .data() function.

## Int(), Str() and Float()


Similarly there is a global Str() function for sorting on strings, and Float() for
sorting on floats. Together with Int() function, these produce Str, Float and Int objects,
which are actually subclasses of the regular "String", "float" and "int" value types, with
the additional function .data() to retrieve the original value.

## Converting between int and float


Both the "int" and "float" type contain two functions for converting to int and float:

```
2.f     becomes float 2.0
2.i     remains int   2
3.14.f  remains float 3.14
3.14.i  becomes int   3
```
# Savefiles - "scripts"

## Save


To save all named functions, enter the special command below

```
$ :save Test
```

This creates a file under the CFT home directory,
called savefileTest.txt.

## Load

```
$ :load Test
```
## Create new empty script


To create a new script from scratch, there is the colon command:

```
$ :new
```

## The @e shortcut


A common shortcut is @e, which opens current savefile in an editor:

```
$ @e
```

Shortcuts can be redefined in the CFT.props file.

## CFT.props - codeDirs


The CFT.props file contains the following line by default

```
codeDirs = . ; code.examples ; code.lib
```

The codeDirs field defines a search order when loading scripts.
The first directory is 
**always** used when you type ":save".


The code.examples contains some example code for various use, while code.lib contains
library code, used by most other scripts.


This means you are free to save a script using the name "Lib", and it will be written to
the code.work directory. Doing this means it will hide the version in the code.lib directory.
Which may be perfectly fine, as long as it is what you intended.

# Comments


The hash character '#' indicates that the rest of the line is a comment.

# Calling functions in other scripts


Sometimes we want to call a useful function in another script file. This is
implemented with with the following syntax:

```
Script:Function (...)
Example:
Lib:Header("This is a test")
```

Parameters are given as a list of values inside ()'s, which may be omitted if no parameters.

# Examining external scripts


The '?' interactive command has an extended syntax that allows you to list functions inside
another script, as well as listing the code of particular function.

```
$ ?Lib:                  # lists functions inside Lib
$ ?Lib:m                 # displays code of function 'm'
```
# Displaying all known scripts


The function Lib:Scripts displays all available scripts, sorted by the directories given
in the CFT.props file.


The shortcut @S calls this function.

# Nested loops


Loops are implemented using the "for each" functionality of "-> var". Loops may well be nested.

```
$ List(1,2,3)->x List(1,2,3)->y  out(x*y)
<List>
0: 1
1: 2
2: 3
3: 2
4: 4
5: 6
6: 3
7: 6
8: 9
```

In this case, the body of each loop is all code following the "-> var"
construct. But this can be changed using the "pipe" symbol, which "closes" all loops.

# Loop spaces - "pipes"


The body of any loop is the rest of the code of the function, or until a "pipe" symbol
is found. The pipe symbol ("|") more accurately partitions the code into a sequence of
**loop spaces**, which means acting as an end-point for
running loops.


The way a "pipe" works, is to wait for all current loops to terminate, then take the
return value from that loop space and putting it onto the stack for the next loop
space to work with (or do something else). Example:

```
$ Dir.files->f out(f.length) | =>sizes sizes.sum
```

This single line of code first contains a loop, which outputs a list of integers for
the sizes of all files in the current directory. Then the "pipe" symbol terminates that
loop space, and creates a new one, where we pick the result from the previous loop
space off the stack and assigns it to a local variable. We then apply the sum() function to it.


To save us some typing, the special expression "_" (underscore) pops the topmost value off
the stack.

```
$ Dir.files->f out(f.length) | _.sum
```

As we see from the above code, a loop spaces don't 
**need** containing loops. The
following is perfectly legal, although a little silly.

```
$ 2+3 | | | | =>x x | =>y y | _ _ _ |
```

Yes, it returns 5.

## Result value from a loop space


All bodies of code in CFT consist of one or more 
**loop spaces**. The result value
from any such body is the return value from the last loop space.

### If the loop space contains looping ...


If a loop space contains loop statements, the result value is a list of data generated
via calls to out() or report() statements. If no actual iteraions take place, or
filtering with assert(), reject() or break() means no data is generated via out() or report(),
then the result is an empty list.

### Otherwise ...


A loop space that doesn't contain loop statements, has as its return value the topmost
element on the stack after all code has executed. If there is no value on the stack,
the return value is 
**null**.

# Function parameters


Custom functions can also take parameters. This is done using the P() expression, which
identifies the parameter by position. Note that 
**parameter position is 1-based**.

```
$ P(1)=>a P(2)=>b a+b
```

This is a valid function, but entering it interactively fails, because it is immediately
parsed and executed, and there are no parameters. To overcome this, the P() expressions
take a second parameter, which is a default value.


The default value parameter to P() is important for several reasons.



- Allows the function code to execute while being developed interactively


- Allows for default values when function is called without parameters, or when called with null-values


- May act as documentation in the source


- Provides an elegant way of making functions interactive and non-interactive at the same time,
as the default expression is evaluated only when parameter is not given (or is null),
and may then ask the user to input the value.



Above example again, now with default values for parameters:

```
$ P(1,1)=>a P(2,2)=>b a+b
<int>
3
$ /f
$ f(5,10)
<int>
15
```
# User input


CFT contains the following for asking the user to enter input:

```
value = Input("Enter value").get
value = readLine("Enter value")
```

The difference is that Input remembers the last input values, and lets the user
press enter to use the last value, or may enter colon to select between previous
values. The readLine() is much simpler, and allows for empty input, as enter
doesn't mean "last value" as for Input.


The optional default value parameter to the P() expression for grabbing parameters to
functions, can be used to produce functions that ask for missing values.

```
P(1,Input("Enter value").get) =>value ...
```
# Block expressions


The traditional blocks inside curly braces are present in CFT as well, and are used for different
things.

## Local blocks


Local blocks are just for grouping code that runs in the same context as the code around it. Technically
they are considered expressions.

```
if (a>b) {
...
}
```
## Lambdas


A Lambda is an object (a value) that contains code, so it can be called, with parameters. The code
inside runs detached from the caller, and behaves exactly like a function.

```
myLambda = Lambda { P(1)+P(2) } myLambda.call(1,2)
```

Great for local functions inside regular functions, and for sending as parameters to other functions,
or lambdas.

## Inner blocks


An inner block is a cross between local blocks and the Lambda. An Inner block is executed
immediately, and has access to the local variables inside the function, but maintain a separate
context for loops and loop output. Technically, inner blocks are expressions, just as with local
blocks.


In other words: Inner blocks define their own loop space.

```
Inner {
someList->
x out(x+1)
} =>resultList
...
```

Inner blocks are a way of running loops isolated from the environment. Remember that loops by
default extend to the end of the function, or until hitting a "pipe". The third thing that
terminates loops are hitting the end of the current block.


Even the end of local blocks terminate loops, but they share the loop space of the surrounding code,
providing somewhat "complicated" outcomes.


## Block expressions summary


Local (plain) blocks for non-looping blocks of code, typically used with "if". Running in
the same loop space as outside the block, means it can call break() and out() as well as
assert() and reject() and affect the (innermost) loop of those outside the block.


Inner blocks for isolated processing loops inside other code. This means calling break() and
out() and assert() and reject() have no effect on loops outside the block.


Lambdas are "functions" as values.

# Conditionals - if expression


Conditional execution of code is done in two ways in CFT, with the first being how we
control processing loops with assert, reject and break.


Then there is the if-exression. It takes two forms, but is always considered an expression, not a statement. The
difference is that expressions always return a value, which statements need not.

### Inline form

```
if (condition, expr1, expr2)
if (condition, expr1)
```

The first selects between the two expressions, based on the condition, evaluating and returning
expr1 if condition is true, otherwise expr2. The second conditionally evaluates expr1, or if
the condition is false, returns null.

### Traditional form

```
if (condition) expr1 else expr2
if (condition) expr1
```
### Functionally identical


The two forms are functionally the same. To select between two simple expressions, the inline
form is probably most readable, while when using block expressions, the traditional form
usually feels more natural. Also note that block expressions allow us to call statements,
such as out() and break() as well as assignments.

```
# Example: produce a default value if null
if (value != null, value, "x") =>value
# Example: call statements inside blocks
i=1
loop
if (i>
10) {
break
} else {
i=i+1
}
```
## if-ladders


The implementation in CFT supports chaining multiple if after each other.

```
if (cond) {
...
} else if (condB) {
...
} else if (condC) {
...
}
```

Decoding some value x into a numeric code, we can enter the following

```
code = if (x=="a") 1 else if (x=="b") 2 else if (x=="c") 3 else 4
```
## Lazy evaluation

#### Lazy if


The if-expression uses lazy evaluation, which means that only the selected
value expression (if any) gets evaluated. This is the same as every other
language.

#### Lazy AND, OR - &amp;&amp; ||


Boolean expressions with logical AND and OR, are lazy, again as in
every other language.

#### Lazy P(N,defaultExpr)


The P() expression to access function parameters only evaluates the default
expression if parameter N is null.

# The error() function


The error() expression is another that contains a conditional part, and if true, throws
an exception with the string part, terminating current execution. Alternatively it can
be used without the condition, which means it always throws an exception.

```
error(1+1==2,"this should not happen")
if (1+1==2) {
error("oops again")
}
```
# Output to screen

```
println("a")
debug("b")
```
# Protecting files and directories


To save typing, one often create functions that just return some directory, or
some files.  The JavaFiles example above illustrates this.


The protect mechanism in CFT lets us attach a protect state to any Dir and File object,
which guarantees that:



- all files and directories derived from it are also protected


- blocks destructive modifications


## Example


Adding .protect to each file that the JavaFiles function generates, ensures that all
files returned from this function are blocked against accidental delete and modifications.

```
$ Dir.allFiles-> f assert(f.name.endsWith(".java")) out(f.protect)
$ /JavaFiles
```

Demonstration:

```
$ JavaFiles.nth.append("")   # Trying to append empty line to first file
ERROR: [input:16] INVALID-OP append : /home/roar/.../xyz.java (PROTECTED: -) (java.lang.Exception)
```

The .protect() function can also take a description string, which if present, is displayed in this error.

## A protected directory does not allow



- create


- delete


- copy file into dir - includes blocking File.uncompress when target dir is protected


## A protected file does not allow



- delete


- create


- append


- copyFrom (target)


- copyTo


- move (source or target)


## No guarantee


Calling .protect on a Dir object, before using it to locate files, will propagate the protected
state to all those files. However, creating a new Dir object for the same path, without calling
.protect() on it, and then accessing content via this, does not protect anything.


Note also that .protect can not detect for example using the path of a protected File object in
an external program, or even to create a new File object (which will not be protected). Example:

```
File(protectedFile.path)
```
## Unprotect


If there is an expression that returns some protected directory or some protected files, and we
are explicitly sure we want to modify it, we can use the .unprotect() function. It removes the
protect flag, but fails with an error if there is no such flag there when called.

# Running external programs

## Summary


The functions for running external programs are part of the Dir object, implicitly defining
working directory for the program.

```
$ Dir.run ( list|...)
$ Dir.runCapture ( list | ...)
$ Dir.runDetach ( list|...)
$ Dir.runProcess ( stdinFile, stdoutFile, stdErrFile, list|... )
```

The parameters written as "list|..." means either a List object, or a list of
String values, separated by comma.

## Dir.run()


This command is used for running external programs in the foreground. What this means is that if
the program requires user input, we can give it, and the CFT code will not continue until
the external process has terminated.

```
$ Dir.run("cmd","/c","git","pull","origin","master")
```

Many Windows programs require the "cmd","/c" in front of the actual program.
For proper operating systems (Linux) you naturally skip the two first elements of the command list.

## Dir.runCapture()


This works the same as Dir.run(), but returns a List of strings representing stdout from the
external program, to be processed further. Not suited for interactive use.

```
Dir.runCapture("which","leafpad") =>lines lines.length>0 && lines.nth.contains("leafpad")
/HasLeafpad
```
## Dir.runDetach()


Use to run external program in the background. The CFT code continues running after forking
off the background process. Nice for editors etc.

```
$ Dir.runDetach("leafpad", Sys.savefile.path)
```

This example runs the leapad editor in the background, with the path of the current savefile as
argument.

## Dir.runProcess


Runs external program, reading input lines from text file, and deliver stdout and stderr to
files. Returns an ExtProcess object, which is used to monitor, terminate or wait for the
external process to finish.


The complexities of creating and removing temporary files, is encapsuled in the library
function 
**Lib:runProcess**, which in turn is called from the simpler 
**Lib:run** function, which
also handles waiting for the external process to finish, before returning.


Both of the Lib functions take the same four parameters, but often only the first is used, as the
rest have useful defaults.


**Lib:run** is the notation for calling a function in another script.

## Lib:runProcess utility function


This is a CFT function in the Lib script, which hides the complexities of
calling Dir.runProcess (above).

```
Lib:runProcess(List("ls","-l)) => result
```

The result object is a Dict with various system info, representing the running
process. It has two closures of interest.


A 
**closure** is a callable object, which
runs code "inside" a dictionary, via a 
**lambda**. Closures and lambdas are invoked
via their .call(...) function.

```
result.isCompleted.call     # returns boolean
result.wait.call            # waits for process to finish, then returns another Dict
```

The result.wait closure, when called, returns a Dict with the following content:



- cmd - the command (list)


- stdin - the stdin lines (list)


- stdout - stdout lines (list)


- stderr - stderr lines (list)


- exitCode - int



To show the Lib:runProcess function code

```
$ ?Lib:runProcess
```

Warning: it's a bit complex

## Lib:run utility function

```
Lib:run (List("ls","-l")) => result
```

The implementation of Lib:run consists of calling Lib:runProcess and then
calling the wait closure, as seen above, returning the result from that call.


To show the Lib:run function code

```
$ ?Lib:run
```
## Work directory issues


For external programs that depend on running from a specific directly, either navigate to current directory
interactively, or just let your code call the .setAsCurrentDir() function on some Dir object before
calling Lib:run.

```
Dir("/home/user/xyz").setAsCurrentDir
Lib:run(...) => result
```
## Doing ssh


If you need to run SSH commands on remote targets, use the SSH library script, which
contains two major functions: run() and sudo(), These call Lib:run then filter the output
to stdout using a marker to eliminate the welcome text when logging in etc.


**Side note: ssh without password**

To set up ssh login without password, create and distribute an ssh key, then
copy it to the target host, as follows (in Linux shell).

```
$ ssh-keygen -t rsa
$ ssh-copy-id user@host
```
# Synthesis

## The problem


If we use "cd" and "ls" to move
to a directory, and want to create a function that works on files or subdirectories under
that location, we have to take care.


The issue is that we can not just say

```
Dir.allFiles->f ...
```

... because the Dir() function returns the current directory, which may change.

## Creating code from values


This is where the 
**syntesis** functionality comes in. The most often used variant takes
the form of two "colon commands".



- The :syn command syntesizes code from the last result.


- The :NN  (where NN is an integer) syntesizes the indicated element of the last result list. If
last result is not a list, an error is reported.


## Example using :syn

```
$ cd ..
# /home/roar
<obj: Dir>
roar/ d:61 f:33
$ cd project1
# /home/roar/project1
<obj: Dir>
project1/ d:0 f:0
$ :syn
synthesize ok
+-----------------------------------------------------
| .  : Dir("/home/roar/project1")
+-----------------------------------------------------
Assign to name by /xxx as usual
$ /DirProject1
```

When we use "cd" to change to a directory, it returns a Dir object. The shell remembers the last
result value, and the ":syn" attempts to create code representing that value in as direct a way as
possible. If this succeeds, it inserts the generated code line tino the "code history", as the
last command, which means it can now be assigned a name, for example "DirProject"


Calling function "DirProject" will now always generate a Dir object pointing to the same
directory, and is no longer dependening on current directory.

## Example using :NN


To synthesize a single element when the last result was a list, use :NN, as follows

```
$ ls
<List>
0: runtime/              | d:2 | f:12
1: CallScriptFunc.java   | 1k  | 1398  |             | 2020-02-28 22:38:09
2: CodeHistory.java      | 10k | 10980 | 2d_22:23:24 | 2020-06-07 12:57:49
3: CommandProcessor.java | 0k  | 365   |             | 2020-02-28 22:38:09
$ :2
synthesize ok
+-----------------------------------------------------
| .  : File("/home/roar/Prosjekter/Java/ConfigTool/src/rf/configtool/main/CodeHistory.java")
+-----------------------------------------------------
Assign to name by /xxx as usual
```

If the last value was not a list, the ":NN" command will fail with an error.

# Output format / Cfg


Output to screen is regulated via a Cfg object. It is a session object, that contains default
settings for number of lines and line width of the current window / terminal. It's default
mode of operation is to disable wrapping, which means long lines are cut, ending with a simple '+'
to indicate this.


To change the current size of the terminal window, we may use global function Cfg() to obtain
the Cfg object, and methods to set or view the properties.

## The @term shortcut


After the introduction of short cuts, the easiest way to set the terminal window width and
height, is to enter

```
$ @term
```

This works on Linux (using stty command) and on Windows (powershell).

## Line wrapping


By default, ouput line wrapping is off, which means that lines longer than the Cfg.w gets truncated
with a '+' to indicate there is more. It can be switched on/off via the Cfg object, but there is also a
colon command ":wrap" which toggles wrapping on or off.

# Templating


Templating is the task of merging data into text, or alternatively of selecting
blocks of text to form a custom result.


This is useful for producing configuration files, generating code, and similar.

## Merging text with Dict


To merge values into a template, we use a dictionary object (Dict) combined with the
merge() function of strings. This replaces occurrences of names in the dictionary
with their values (as strings).

```
$ Dict.set("name","Julius")
$ /data
$ "Dear name".merge(data)
<String>
Dear Julius
```
## Dict.mergeCodes()


The merge is based on a direct match. Often we like to mark our merge codes. The Dict
object has a function, ".mergeCodes()", which returns a new Dict object, where all names of fields
are rewritten into ${name}. Changing the template correspondingly, this eliminates the risk of
accidentally matching text not meant as merge codes.

```
$ Dict.set("name","Julius").mergeCodes
$ /data
$ "Dear ${name}".merge(data)
<String>
Dear Julius
```
### Custom merge codes


The Dict.mergeCodes() also take an optional two parameters, which are the pre and post
strings for creating the merge codes. Note that either none or both of these must be
given.

```
$ Dict.set("name","Julius").mergeCodes("[","]")
$ /data
$ "Dear [name]".merge(data)
<String>
Dear Julius
```
## PDict()


With many parameters to be merged into the template text, the special expression PDict() saves
us some typing. Instead of having to do this:

```
P(1) =>
 name
P(2) =>
 ip
Dict
.set("name",name)
.set("ip",ip)
.mergeCodes => data
```

... we can instead just say:

```
PDict("name","ip").mergeCodes => data
```

The PDict function takes a list of names, and map them to the function parameters
in sequence. Missing values result in "null", which in turn (when calling String.merge),
get replaced with empty strings.


If missing values are a problem:

```
PDict("name","ip").mergeCodes => data
error(data.hasNullValue,"Missing parameters!")
```
## Example using raw strings and Sequence()


**Raw strings** are a special notation for strings, that is as follows:

```
a = @ this is a "raw string" ...
```

The raw string starts following the "@ " prefix, and continues to the end of the line.


**Sequence()** and 
**CondSequence()** are built-in expressions that are similar to
List, in that they create list objects, but with a relaxed syntax, which means commas
between values are optional.


The CondSequence() is conditional, which means if the first parameter is false, it generates
an empty list. Since lists can be concatenated with "+", we can do this:

```
PDict("replSetName","clusterRole").mergeCodes=>data
isConfNode = (P(2)=="configsvr")
Sequence(
@  :
@  :
@ replication:
@   replSetName: '${replSetName}'
@
) + CondSequence(isConf,
@
@ # NOTE: config replica set node
@
) + CondSequence(!isConf,
@
@ # NOTE: data shard replica set node
@
)+Sequence(
@ sharding:
@   clusterRole: '${clusterRole}'
)
->
line out(line.merge(data))
/CreateMongodCfg
```
# Processing text


Here are different ways of working with text in CFT.



- Reading separate text files


- "here" documents in script files


- DataFile


- Sequence() and raw strings


## Reading text files


Any text file can be read and processed line by line as follows.

```
Dir.file("x.txt").read->
line ...
```
## Script file "here" documents


This is a special feature of script files, where a sequence of lines between two
marker lines, are translated to a List expression on the fly, as the script file is loaded.

```
<<<<<<<<<<<< Identifier
This is
some text
>>>>>>>>>>>> Identifier
/myTemplate
```

Calling the myTemplate function from the interactive shell, produces the following result

```
$ myTemplate
<List>
0: This is
1: some text
```

The markers need at least 3x of the '<' or '>' followed by space and a matching identifier.

## DataFile


The DataFile global function reads a special text file with individual sections identified
by a user selectable selector string, and names.


Example data file 'data.txt'

```
### A
This is
template A
### B
This is
template B
```

The code to use this file consists of creating the DataFile object, passing the separator
string as a parameter, then accessing the individual templates.

```
$ DataFile(File("data.txt"),"###")
$ /df
$ df.get("A")
<List>
This is
template A
```
### Include blank lines


The function DataFile.get() returns only non-blank lines. To get all lines, use function getAll().

### Filter away comments


Also, DataFile has support for comments in the template text, which can be automatically
removed. They are defined by another prefix string as follows:

```
$ DataFile(someFile,"###").comment("//")
$ /df
```

Now all lines starting with "//" are automatically stripped from any output.

## Sequence() and raw strings


**v1.7.0**

Raw strings start with '@' and consist of the rest of the line.
In addition, two expressions have been added, called Sequence() and CondSequence(). These
generate List elements, but with a relaxed syntax, making commas between values optional,
for max readability when creating a template.

```
Sequence(
@ header
)+CondSequence(<condition>
@ optional-part
)+Sequence(
@ footer
)
```

What happens here is that the Sequence() and CondSequence() expressions result in List
objects, which are then concatenated via the "+" operator.


The "@" type "raw" strings can be used in regular code as well. The behaviour is as follows:



- When "@" is followed by single space, that single space is removed from the string


- When "@" is followed by another "@", all characters following that sequence becomes the string


- When "@" is followed by anything else, all of the rest of the line becomes the string



The advantage of this notation over that of "here"-documents, is that it allows proper
indentation, for greatly improved readability in script code, and that it's easy to
add conditional blocks, while the "here"-document means we can paste original text
directly into the script code.

# Use as a calculator

## Expressions and "variables"


Having a running instance of CFT on the desktop means access to a capable calculator.

```
$ 24*60*60
<int>
86400
/x
x*365
<int>
31536000
```

As noted before, the symbol "x" does not refer to the value 86400, but to the code that
generates the value.

## Lib.Math


The global function Lib() creates a Lib object, which in turn contains functions that
create other objects, such as the Math object, which contains trigonometric functions.

## Lib.Convert


The Lib.Convert function returns another object, which contains code for lots of common
conversions. Use the help system to show all options.

```
$ Lib.Convert help
```
## Lib.Plot


The Lib.Plot function returns an object with functions for creating a primitive plot, for
visualizing data. Again, use the help system to examine options.


Note that Lib.Plot is a quick-and-dirty implementation. For better graphs, some external
package should be invoked.

```
File("/tmp/" + currentTimeMillis+".txt")
/tmpFile
f = tmpFile
Lib.Data.each(0,720)->i
f.append(""+Lib.Math.sin(i) + "," + Lib.Math.cos(i))
|
Lib.Plot.typeTimeline.readCSVFile(f).plot(File("out.png"))
f.delete
/DemoPlot
```

The above code generates an example plot as a png file in the current directory.

# Command line args


If CFT is invoked with command line arguments, the first is the name of the script,
that is, a savefile minus the "savefile" prefix and ".txt" ending.


Then follows zero
or more command lines, on string format. For values containing space or otherwise
have meaning to the shell, use quotes. Example:

```
./cft Projects Curr
```

This loads script Projects, then calls the Curr function inside.

```
./cft
./cft scriptName [commandLines]*
./cft -version
./cft -help
./cft -d scriptDir [scriptName [commandLines]*]?
```
# Working with pasted text lines from stdin


If you've got some text in the copy-paste buffer that you want to work with, the
readLines() global functions can be used. It takes one parameter, which is an end-marker, which must
occur alone on a line, to mark the end.


The readLines() function returns a list of strings, which you can turn into code and save under
some function name, using synthesis.

```
readLines("XXX")
(paste or enter text, then enter end-marker manually)
XXX
<list>
0: ...
1: ...
:syn
/someName
...
```
# Differing between Windows and Linux


Calling function Sys.isWindows() is used to differ between the two in code. It does this
by checking if (Java) File.separator is a backslash.

```
$ Sys.isWindows
<boolean>
false
```
# Predicate calls


Example: to decide if a string is an integer, without
resorting to either creating a built-in predicate function like .isInt, or even
using regular expression matching, there is the 
**predicate call** functionality,
where one calls a function in a special way, resulting in a boolean value that tells
if the call was ok or not.


All dotted calls are made into predicate calls, by adding a '?' questionmark between the dot
and the function name.
```
"sdf".?parseInt
<boolean>
false
"123".?parseInt
<boolean>
true
```
# Error handling


Exception handling in CFT is split into two parts, reflecting two types of
situations:



- CFT logical or data errors, called 
**soft errors**

- General errors, stemming from underlying Java code, network situations etc, called 
**hard errors**


## Soft errors


Soft errors are created by calling the error() function.


They can be specifically
caught with tryCatchSoft(), which returns a Dict containing either:

```
ok: true
result: ANY
or
ok: false
msg: string
```

Hard errors propagate right through tryCatchSoft().

## Hard errors


Hard errors are all kind of error situations arising from the Java code running CFT.


The tryCatch() expression catches both hard and soft errors, and returns a Dict containing

```
ok: true
result: ANY
or
ok: false
msg: string
stack: List of string
```

An example of a hard error is trying to access a variable or function that doesn't
exist.

# Get type of value


The global function getType() takes one parameter, and returns
the type name of that value, as a string

```
$ getType(3)
<String>
int
$ getType(Dict)
<String>
Dict
```
# List.push()


The push() function of the List object pushes a number of value from the list onto the stack
to be assigned in "logical" order, and allows us to supply a default value if list too short.

```
$ List("x","y").split.push(3,"*") =>a =>b =>c a+":"+b+":"+c
<String>
x:y:*
```
# Dict set with strings


Reading name-value assignments from a property file or similar, is best done via the .setStr()
function on the Dict object. It strips whitespace and accepts both colon and '='.

```
Dict.setStr("a : b")
/d
d.get("a")
<String>
b
```

To process a property file, assuming commented lines start with '#', we can do
this:

```
P(1) =>propFile
Dict =>d
propFile.read->line
reject(line.trim.startsWith("#"))
assert(line.contains(":") || line.contains("="))
d.setStr(line)
|
d
/GetProps
```
# Dict.get with default value


The Dict.get() method takes an optional default-value which is returned if no value
associated with the name, but in that case the default value is 
**also stored** in the
dictionary.

```
data=Dict
data.get("a",3)  # returns 3
data.keys        # returns list with "a"
data.get("a",5)  # returns 3 as it was set above
```
# List.nth() negative indexes


Using negative indexes to List.nth() counts from the end of the list. Using value -1 returns the
last element, -2 the second last, and so on.

```
List(1,2,3,4).nth(-1)
<int>
```
# Function parameters as List or Dict


In addition to grabbing one parameter at a time, using P(pos), we can also process the
parameter values as a list and as a dictionary.


The function parameter expression P() when used with no parameters, returns a list of
the parameter values as passed to the function.


The PDict() expression takes a sequence of names to be mapped to parameters by position,
resulting in a Dict object. Missing values lead to the special value null being stored
in the dictionary.

# The general loop statement


In addition to looping over lists, there is a general loop construct. It identifies no
loop variable, and loops forever, until break() is called. It also obeys assert()
and reject() as with list iteration.

```
a=0 loop break(a>3) out(a) a=a+1
<List>
0
1
2
3
```

If you forget to increment the variable a, or forget or create an invalid break(), then
the loop may never terminate, and CFT has to be killed with ^C

# Storing CFT data structures to file - syn() and eval()


A  persistent solution for storing data is to store a data structure to file. This is done using
the synthesis functionality, which is made available as a global function as well as the
"colon command" used before. This means we can write huge lists and sets of files and
directory objects to file, and restore it later, without going through possibly time
consuming computations.


To restore the structure, we use the global eval() function.
```
P(1)=>file
P(2,"data") =>data
file.create(syn(data))
/saveData
P(1)=>file
eval(file.read.nth)
/restoreData
```

This can be used to save arbitrarily big structures, as long as they are synthesizable.

# The CFT database


**v1.9.6**

CFT implements its own primitive database, as found in Lib.Db.Db2, and which is usually
interfaced via the Db2 script.

```
Db2:Set("myCollection", "field", "test")
```

The Db2 persists data to file, and handles all values that can be synthesized to code.


Also there is a Db2Obj script, which saves data objects identified by UUID's, which are
made by calling the Lib.Db.UUID function.

# Multitasking in CFT


**v1.9.8**

CFT offers the ability to run multiple processes of CFT code, via the SpawnProcess() expression.


It takes two parameters, a context dictionary and an expression. The named values from the
context dictionary become local variables when the expression is executed, which takes
place in a separate process.


The code runs in a virtualized environment. Output is buffered inside the Process object, and
if the code requires input, it will block, until we supply input lines via the Process
object.


Listing Process functions:

```
$ SpawnProcess(Dict,1) help
# close() - close stdin for process
# data() - returns the (original) context dictionary
# exitValue() - returns exit value or null if still running
# isAlive() - true if process running
# isDone() - true if process completed running
# output() - get buffered output lines
# sendLine(line) - send input line to process
# wait() - wait for process to terminate - returns self
```
## Example: pinging a list of hosts


The following example show how we can perform system monitoring efficiently using
SpawnProcess.


This example is about pinging a set of servers, to see which are up. We start by creating
a function for this, and testing it manually.

### Create and test regular ping function


It is okay to print out a lot of stuff, as all of that will be collected when
calling function inside a Process. We will log that to the database if
function returns false.

```
# Ping host, return boolean (true if ok)
# --
P(1)=>host
println("Pinging host " + host)
Lib:run(List("ping","-c","1",host), List, true) =>
 res
if (res.exitCode==0) {
true
} else {
println("FAILED with exitCode=" + res.exitCode)
Inner {
res.stdout->line println(line) |
res.stderr->line println("#ERR# " + line) |
}
false
}
/ping
```

After testing the function, we go on to create the function that manages the processes.

### Management function, with logging via Db2Obj database script


We now create a function Hosts, which returns a list of the hosts to check, and then
the function CheckPing, which iterates over these.

```
"s01.s s02.s s03.s s04.s s05.s s06.s s07.s".split
/Hosts
# Delete previous ping stats from database, then run ping on all
# hosts in parallel, collecting results and store in database.
# --
COLLECTION="stats"
# Clear out results from earlier runs, if any
# --
Db2Obj:DeleteObjects(COLLECTION, Lambda{P(1).value.op=="ping"})
# Iterate over hosts
# --
Hosts->host
# Start individual processes, each calling the ping function with a host
# --
data=Dict.set("host",host)
proc=SpawnProcess(data,ping(host))
out(proc)
| _->proc
# Wait for each process in turn, and collect results
# --
proc.wait
dbObj=Dict
.set("op","ping")
.set("host", proc.data.host)  # the data dict from SpawnProcess
.set("ok",proc.exitValue)
if (proc.exitValue==false) {
# failed
dbObj.set("output", proc.output)
}
# Log everything to database
# --
Db2Obj:AddObject(COLLECTION, dbObj)
/CheckPing
```

The CheckPing function iterates over the hosts, and for each calls SpawnProcess, with the
host stored in the context data Dict object. This generates a Process object, which is
is sent on with the out() statement.


After the PIPE we now are working with a list of Process objects, which we iterate over,
and for each, first wait for it finish, then pick values from it, building a dbObj Dict
with relevant information. THe field "op"="ping" is what is used to identify these
data, for the initial call to DbObj:DeleteObjects() where we delete any previous stats,
from earlier runs.

### Checking results (in database)


After this has run, we look at the data in the "stats" collection:

```
$ Db2Obj:ShowFields("stats",List("host","ok"))
<List>
0: 2020-11-05 22:48:44 | s01.s | true
1: 2020-11-05 22:48:44 | s02.s | true
2: 2020-11-05 22:48:44 | s03.s | true
3: 2020-11-05 22:48:47 | s04.s | false
4: 2020-11-05 22:48:47 | s05.s | true
5: 2020-11-05 22:48:47 | s06.s | true
6: 2020-11-05 22:48:47 | s07.s | false
```

Here we list fields "host" and "ok" from the objects. We see that hosts "s04.s" and "s07.s"
failed. We now check the output log for "s04.s".

```
$ Db2Obj:FindObjects("stats",Lambda{P(1).value.host=="s04.s"}).first.value.output
<List>
0: Pinging host s04.s
1: FAILED with exitCode=1
2: PING s04.s (10.0.11.41) 56(84) bytes of data.
3: From 10.0.0.84 (10.0.0.84) icmp_seq=1 Destination Host Unreachable
4:
5: --- s04.s ping statistics ---
6: 1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms
7:
```
## Advantages


The run time of this code should be that of the host that takes the longest
time to ping (or fail to ping).


Collecting stdout from the Process means that the code that does the work (like
our ping() function) can just print progress and status data via println(), which makes
the code easy to test separately.


Processes also offer full protection from exceptions of all kinds, as they
are caught and listed in full inside the Process.

## Flow control


In some cases, the number of processes can be huge, and we may need to limit the
number of active processes. This is done via a function in the Util script, that
returns an 
**object** which we use as follows. The names "Lxxx" are used to
help indicate that they contain lambdas (though strictly they are closures).

```
# -- Create monitor, decide max parallel processes
mon=Util:ProcessMonitor
limit=4
# -- when about to create new process
mon.Lwait.call (limit)
proc=SpawnProcess(...)
mon.Ladd.call(proc)
```

The mon.Lwait lambda waits until number of running processes comes below the limit,
before returning.


See separate sections on closures and objects.

# String .esc() and .unEsc()


As was mentioned initially, CFT doesn't use backslash as an escape character.
However, we still require a way of converting "difficult" strings to code,
via synthesis. For this purpose, the two functions String.esc() and String.unEsc() was
created.


One rarely needs to call these manually, but they are worth mentioning, as sometimes synthesis
of a string may result in code such as this:

```
"^q^aa^a^q".unEsc
```
## Escape codes


For an escaped string, the escape character is the ^ symbol.



- "Double quotes" ^q


- 'Single quotes' / Apostrophe ^a


- Newline ^n


- Carriage Return ^r


- Tab ^t


- The ^ symbol ^^



To gives a way of creating strings with newlines inside.

```
"this^nis^na test".unEsc
<String>
this
is
a test
```
# Automating interactive functions / Sys.stdin()


Functions may query the user with Input("prompt").get and readLine("prompt"). If we want
to automate such functions, we use function Sys.stdin() to buffer up any number of
input lines.

```
Sys.stdin("read-this") Input("Enter data").get
<String>
read-this
```

Note that both Input.get() and readLine() detect if there is buffered input, and
if so, do not display the prompt or other info. Particularly useful for Input.get(),
since buffering the empty string "" with Sys.stdin() means repeating the last value.

## Running colon commands from script code


Using the Sys.stdin() statement without being followed by Input.get() or readLine(), is just
another way of entering commands. This means colon commands are available from CFT code.

```
stdin("2+3")
<int>
5
```

This can be exploited to let a script modify itself, by redefining
functions, although that will be troublesome if those functions read input. A better
use is that of running colon commands, particularly loading scripts. This is used
frequently with shortcuts.

```
stdin(":load SomeScript","?")
```
# Clone any value


The common function clone() of all values returns a copy of the value, as long as the value
in question is synthesizable. If not, an error is returned.

```
a=List(1,2,3)
b=a.clone.add(4)  # b contains 1,2,3,4 while a remains unchanged
```
# Simple line editing


When using CFT mainly in interactive mode, a primitive line editor can be used to modify
the code of an existing function, by optionally cutting off text following a pattern, as well
as optionally adding text.


The syntax is as follows

```
$ !x!       # inserts code from function x as text, then executes it
$ !x! txt   # inserts code from function x, followed by " txt", then executes it
$ !x:p!     # inserts code from function x up to but not including pattern 'p'
$ !x:p! txt
```
### Develop complex code in steps

```
$ Dir.files
$ /x
$ !x!->f out(f)
$ /x!
$ !x:out!assert(f.name.endsWith(".txt")) out(f)
$ /x!
```

Note: this only applies to single-line functions.

# CFT.props - mCat, mEdit and mMore lambdas


The configuration fields mCat, mEdit and mMore ("m" for macro) define lambdas
that are called for interactive commands cat/edit/more. This means it is possible
to redefine what edit means. Currently, mEdit calls either "Lib:e". The
mMore lambda calls "Lib:m", while the mCat macro just calls .read on file parameter.

# CFT.props - shortcuts


The CFT.props text is self explanatory.

```
# Shortcuts
#
# The shortcuts are lines of code. If that code results in a macro, it is invoked with
# no parameters. Since we don't need parameters, there is really no need for macros
# here. The return value from a shortcut becomes the "last value", available
# via Sys.lastResult, as well as used by :syn etc
#
# Note that shortcuts only work when the prefix is at the start of the interactive
# input line.
# ---
shortcutPrefix = @
shortcut:r = Sys.stdin(":load Release","?")
shortcut:p = Sys.stdin(":load Projects","?")
# List available shortcuts when typing '@' only
# ---
shortcut: = File("CFT.props").read-gt;line assert(line.contains("shortcut:")) out(line)
```

This means that typing @r loads the Release script, then executes the '?' command, which
lists its content.

### Show all shortcuts


To list defined shortcut, just type

```
$ @
```

This is a shortcut itself, that traverses the CFT.props file and identifies and
displays the
shortcut definitions from it.

# Some example code

## Windows PowerShell


The following code is an effective way of using PowerShell from CFT, saving lots of typing.

```
# Run remote PowerShell script-block
host=P(1)
cmd=P(2)
fullCmd = List("powershell","invoke-command","-computername",host,"-scriptblock","{" + cmd + "}")
Dir.run(fullCmd)
/PSRun
# List services via PowerShell (interactive)
host = Input("Host").get
Input("Service name (including wildcards)").get =service
cmd = "get-service -name " + service  # no splitting
PSRun(host, cmd)
/PSGetService
```
## Windows CMD


Running commands using CMD in windows, mostly requires the "/c" flag.

```
Dir("...")
/DirProject
# Add, commit and push with git
DirProject.run("cmd","/c","git","add",".")
msg=Input("Commit message").get
DirProject.run("cmd","/c","git","commit","-m",msg)
DirProject.run("cmd","/c","git","push","origin","master")
/GitPush
```
# Lib.Text.Lexer


**v1.3.2**

The Lib.Text.Lexer objects adds
capability to match complex tokens with CFT, using the same Java tokenizer that is used when
parsing CFT script code.

## Motivation


Working with log data, it would be nice identifying data in log lines beyond
doing free text searches. The Lexer is the first step, and will in time be followed by
some more classes, including a basic recursive-descent parser.

## Concept


The concept is that of a tree of maps, each map maps single characters to other maps, and so on.
If map A contains mapping of digits 0-9 pointing at map B, and our parse process so far has led
us to map A, with next input character being 0,1,2,3..., then that character is "consumed", which is
fancy speak for matched, and the current map becomes B. The process then repeates.


If the current map has no mapping for the current next character, then one of the following happen:



- If the current map is marked with "this is a token", then parsing succeeds


- Otherwise, we backtrack, unconsuming previourly consumed characters, until finding a map that "is a token"

<lI>
Or ,if no map in our parse tree has the "this is a token" mark set, then parsing fails


## Implementation


In the CFT functions, such maps are called nodes. They are created via the
Lib.Text.Lexer.Node function.

```
$ Lib.Text.Lexer help
# Node(firstChars?) - create empty node, possibly identifying firstChars list
# getTokenStream() - get list of tokens identified via processLine as TokenStream object
# getTokens() - get list of tokens identified via calls to processLine
# processLine(rootNode,line,eolTokenType?) - processes line, adds to internal token list - returns self
```

The nodes in turn contain the following:

```
$ Lib.Text.Lexer.Node help
# addToken(token) - create mappings for token string, returns resulting Node
# match(Str) - returns number of characters matched
# setDefault(targetNode?) - map all non-specified characters to node, returns target node
# setIsToken(tokenType) - tokenType is an int - returns self
# sub(chars, targetNode) or sub(chars) or sub(targetNode) - add mapping, returns target Node
```

A simple example:

```
top=Lib.Text.Lexer.Node
x=top.sub("0123456789")   # new node
x.sub("0123456789",x)  # x points to itself for digits
x.setIsToken(1) # token type: non-negative numbers for regular tokens
top.match("300xx")  # returns 3, matching sequence '300'
```

The match() function is for testing only.

### .sub()


The sub() function of any node is used to connect pointers from one map to another. It takes
three forms:

```
(1)
someNode.sub("abc",someOtherNode)
# when at someNode and one of the characters ("abc") are next character in input
# string, then consume character, and move to that other node, which may of course
# be the same node or some other node
(2)
someNode.sub("abc")
# When no node parameter, an empty node is created, which "abc" points to from
# someNode. The new node is returned
(3)
someNode.sub(someOtherNode)
# When creating libraries of reusable nodes, they always must define a set of
# characters which are called "firstChars". These are the characters that indicate
# the start of some sort of data. For example for Lib.Text.Lexer.Identifier, the
# "firstChars" are "a-zA-Z_". It's the letters an identifier can start
# with. Similarly we can create our own library node functions, by supplying a
# firstChars list as parameter to Lib.Text.Lexer.Node
#
# So what happens is that inside someNode, pointers are added to someOtherNode for
# all characters in that node's firstChars.
```
## Reusable nodes - integer sequence


To create a reusable node, we need to specify the "firstChars" of a node, which are given
as parameter when creating an Node node. This means adding it as "sub" under some other node,
lets those characters point at it.

```
# Create reusable node for integers.
"0123456789"=>digits
Lib.Text.Lexer.Node(digits) =>x
x.sub(digits,x)
x.setIsToken(1)
x
/NodeInt
# Now we can for example match a IP v4 address
Lib.Text.Lexer.Node =top
a=NodeInt
b=NodeInt
c=NodeInt
d=NodeInt
top.sub(a)
a.sub(".").sub(b) # creates intermediary nodes for the dots
b.sub(".").sub(c)
c.sub(".").sub(d)
d.setIsToken(2)
top
/MatchIPAddress
# Test
"192.168.1.1 255.255.x 10.0.0.1 1.2.3 .4".split->word
report(word, MatchIPAddress.match(word))
# should return 11,0,8,0,0
/t1
```
## Processing single lines


To process all text in a line, we need to build a root node to which we add
pointers to sub-nodes for all valid tokens. For simplicity, let us match only
identifiers.


Since identifiers are separated by space, we also need to match
whitespace. Since we are not interested in whitespace, we assign whitespace
tokens a negative token type, as those get automatically ignored.

```
# Identifiers
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_" =>firstChars
firstChars+"0123456789" =>innerChars
ident = Lib.Text.Lexer.Node(firstChars)
ident.sub(innerChars,ident)
ident.setIsToken(1)
ident
/Identifiers
# Whitespace
" ^t^n^r".unEsc =>chars
Lib.Text.Lexer.Node(chars) =>ws
ws.sub(chars,ws)
ws.setIsToken(-1)
ws
/WhitesSpace
# Root node
Lib.Text.Lexer.Node =>root
root.sub(Identifiers)
root.sub(WhiteSpace)
/Root
```

With the Root node ready, we can now parse strings consisting of identifiers and space,
ignoring space.

```
# Test
Lib.Text.Lexer.processLine(Root,"this is a test").getTokens->
token
report(token.sourceLocation, token.str, token.tokenType)
/test
```

Now running the test we get

```
$ test
<List>
0: pos=1  | this | 1
1: pos=6  | is   | 1
2: pos=9  | a    | 1
3: pos=11 | test | 1
```
## Processing files


Processing files is easy, using File.read and iterating over those, calling .processLine
on the same Lexer object. If we want, we can let the lexer add "newline"-tokens at the end
of each line, by just defining a token type, here we use 100.

```
# Process file
Root =>root
Lib.Text.Lexer =>lexer
File("...").read->line
lexer.processLine(root,lexer,100)
|
lexer.getTokens->token
report(token.sourceLocation, token.str, token.tokenType)
/ProcessFile
```

The Lexer.processLine is smart enough to detect when lines are read from a file, as
lines read from file are not regular strings, but a subtype of String, which contain
filename and line number. This info is included in the sourceLocation available
for each token.

## Limitations


As there is at most one pointer per character in each node, we can not both recognize
identifiers AND certain keywords, such as "begin" and "end", separately. Unless of course
the keywords start with a different sequence of characters in front, that make them
unique from identifiers.


With the "symbols" we can easily recognize both "=" and "==" as symbols, because the second
is an extension of the first, and the "=" node is not configured to match any stream
of "=", such as identifiers are for letters and numbers.


This also means we can not both match integer and dates on numeric format, such as

```
2020   # integer
2020-09-12   # date
```
## Different uses


Parsing a programming language or JSON structure, requires us to identify every
token in the string. The lexer tree must house them all.


Parsing a log line piece by piece does not have this requirement. Different
lexer nodes may be used for each part of the line, some allowing for alternatives,
most just looking to match a fixed format string, for which regular expressions
would also be suited.

## Complex tokens


For the case where we want to identify parts of a log line, one token at a time,
individual token definitions may not co-exist under a shared root, but that is
exactly the point: we have clear expectations for what we look for, at any time.


The Node.addTokenComplex() function is not one that lives happily together with
others.

### Regular Node.addToken() example


With the normal .addToken() function, we can do something like this:

```
Lib.Text.Node =>grade
"A AA AAA B C".split->
x grade.addToken(x).setIsToken
```

Overlapping definitions, such as "A" and "AA" and "AAA" is not a problem for Node.addToken()

### Node.addTokenComplex() example


This function adds a token, where some of the characters in the token string map to
sets of characters, via a Dict object. This function does not have the freedom to
expand and reuse existing (overlapping) nodes, as with the regular .addToken() function.


It is meant for matching one thing only, and not for collecting all token definitions
under a shared root, as before.

```
Lib.Text.Node =>date
Dict.set("i","0123456789") =>mappings
date.setTokenComplex("iiii-ii-ii", mappings).setIsToken
date.match("2020-09-15xxx")  # returns 10 (characters matched)
date.match("2020-009-15xxx") # returns 0 (no match)
```

Feels like Regex character classes, no?

# Closures


**v1.3.1**

A closure is created by binding a Lambda to a Dict object. The Closure
has a .call function just like the Lambda, and invokes the lambda, with
the Dict object referenced via "self" variable.


Nice for event based callbacks.

```
Dict =>data
data.bind(Lambda{
self.set("received_value", P(1))
}) =>closure
closure.call("test")
data.get("received_value")  # returns "test"
```

For robustness and testing, when lambdas are run directly (not via closures)
there is also a "self" variable, which points at an empty Dict object.

## Another example


Here we create a Closure that when called strips N characters from the
start and end of a string.

```
P(1)=>n
Dict.set("n",n).bind(Lambda{
P(1)=>s
self.get("n")=>n
s.sub(n,s.length-n)
})
/Strip
```

Test:

```
$ Strip(2).call("this is a test")
<String>
is is a te
```
# Closures v2 - Objects


**v1.7.5**

Letting the dictionary .set function detect lambdas, they are automatically wrapped inside
closures, with "self" pointing to the dictionary in question.


This means we can now do this:

```
Dict
.set("i",1)
.set("incr",Lambda{
amount=P(1,1)
self.set("i",self.i+amount)
})
=>data
data.incr.call(10) # data.i is now 11
println(data.i)
/test
```
## Member lambdas calling each other


The mechanism of letting individual "member" lambdas have a shared idea of "self", also allows for this:

```
Dict
.set("i",1)
.set("incr",Lambda{
amount=P(1,1)
self.set("i",self.i+amount)
})
.set("incr50",Lambda{
self.incr.call(50)
})
=>data
data.incr50.call  # data.i is now 51
println(data.i)
/test
```

The incr50 lambda calls the incr lambda within the environment defined by the Dict object.

## Copy lambdas between dictionaries


The Dict.set function also detects when it is fed a closure, unwrapping the
Lambda inside, then wrapping it inside a new closure pointing back to
itself (via "self" variable in lambda).

# Reference: Colon commands


Colon commands are best described by entering a single colon at the CFT prompt.

```
$ :
Colon commands
--------------
:save [ident]?           - save script
:load [ident]?           - load script
:new                     - create new empty script
:sw [ident]?             - switch between loaded scripts
:delete ident [, ident]* - delete function(s)
:copy ident ident        - copy function
:wrap                    - line wrap on/off
:debug                   - enter or leave debug mode
:syn                     - synthesize last result
:<int>                   - synthesize a row from last result (must be list)
:quit                    - terminate CFT
```

Confusing colon commands with shortcuts? You're not alone.


Colon commands exist outside the language, and are fixed (written in Java), while shortcuts run CFT program
code, and are defined in the CFT.props file. So far all good.


The "problem" is that CFT code (and so shortcuts) can run colon commands via "abusing" the Sys.stdin() command.

# Reference: Synthesizable types



- boolean


- int


- float


- string


- null


- List


- Dir


- File


- FileLine


- Date


- Date.Duration


- Int


- Float


- Str


- Dict


- Glob


- Regex


- Lambda


# Comments and digressions

## Why Input("label").get?


Why can't the Input() function just ask the user for input? Why the .get()?


This is because it was envisioned more functions on the Input object, such as
programming it to reset its remembered values, or get values from other sources.


This never came to fruition, and with Input() being a pretty old function, Input("xxx") remains
creating an object, with a single .get() function inside. As a side note, it also has to be an
object in order to persist data in the session, though surely that's not a hard limitation.


At least it leaves us with the option of adding clever stuff later.


Another weakness or strength is that Input objects are mapped to persistent instances by
the input label. This can be confusing, but often also what we want.

## Function name AFTER code?

```
Dir.files
/showFiles
```

This stems back to the time of entering code line by line. Having to decide the name of a function before
seeing how much functionality you got crammed into one line, or if it at all worked,
made little sense. Instead you write some code
that does something useful, then decides what to call it.


This might at some point be changed, at least for script files, as it still feels backward, but this
is the reason.


The syntax with the slash and an identifier was inspired by PostScript.


Another issue is how to integrate or maintain the use of the P() function for
parameter processing, which feels superior to what one can do in a
more traditional format:

```
function X (a,b) { ... }
```
## Using Sys.stdin to run colon commands etc


That functionality an example of an "unexpected feature", as the Sys.stdin() was created to automate
functions that used
Input and readLine(). There was a moment of confusion when discovering what happened to input lines not consumed
by those interactive functions.

## 2020-09-12 Inner blocks??


The first block expression added to CFT, was what is now called the Inner block. Then immediately followed
macros, now called Lambdas. The local blocks were introduced in the v1.3 overhaul.


The previous "odd" syntax for creating macros has gotten more explicit, but who talks
about "macros" these days? The functionality is the same, though.


A search/replace on all the script files fixed the renaming easily.

```
{* ...} =>macro  # old syntax - no longer supported
Lambda{...} =>lambda
```

The Inner block expressions do not resemble code blocks in Java, because in reality they are automatically
executing lambdas, with scope extending out to the calling environment. Lambdas and block expressions were
an afterthought, something created because it was possible. There was no real need, apart from
simplifying the odd conditional assigment .....

```
if(addOne, value+1, value) =value
```

Now, with local block expressions added in v1.3, and the "if" expression accepting dual syntax,
code can be organized much more logically
for Java/C/JS programmers.

## 2020-09-12 Closures and objects


After creating v1.3.0 which rearranged two block expressions into three (Lambda, Inner and Local),
I had pondered how to do closures and objects.


These were created mainly created for fun, though they of course have uses.


The solution ended up being very easy to implement, and is fairly elegant,
as they really are about using the same mechanism, being that all running
lambdas have a "self" variable pointing to some Dict object.

## 2020-09-12 A lexical analysis revelation


As the Lib.Text.Lexer object was created, and I experimented with it, I discovered
that what I had thought to be a limitation in the parser, was a "user error" made by me.


The problem was that CFT did not handle calling functions inside integer literals,
except with a space between the number and the dot, like this:

```
$ 3 .bin
```

The problem was that my configuration for parsing floating point numbers
was flawed. Basically it looked like this (converted to Lib.Text.Lexer syntax)

```
"0123456780"=>digits
Lib.Text.Lexer.Empty(digits) =>intMatcher
intMatcher.sub(digits,intMatcher)
intMatcher.setIsToken  # so far all good
intMatcher.sub(".") =>afterDot
afterDot.sub(digits, afterDot)
afterDot.setIsToken
```

The problem here is that when the intMatcher finds a ".", and follows the link to
the afterDot node, that node has the is-token flag set, so even if there are no
digits following the dot, the matcher believes it has matched a float. The result
is that "3." is considered a valid float, and that the the text following now is "bin",
which is correctly recognized as an identifier, but the parser does not recognize it
as a dotted call, as the dot has been incorrectly consumed.


The fix is simple. The "." must point to a node that does not have the is-token flag set,
but instead has pointers for digits 0-9 to another node, which does, and which
gobbles up any additional digits via a self-loop.

```
"0123456780"=>digits
Lib.Text.Lexer.Empty(digits) =>intMatcher
intMatcher.sub(digits,intMatcher)
intMatcher.setIsToken(3)
intMatcher.sub(".") =>afterDot
afterDot.sub(digits) =>afterDotDigits  # new node
afterDotDigits.setIsToken(4)
afterDotDigits.sub(digits,afterDotDigits)
```

Lexing and parsing is fun, and I really enjoyed learning new things about my own code after 2+ years
of assuming I had hit a limitation.


I am going to enjoy writing the parser. CFT uses a "hard-coded" recursive descent
parser, with Java classes calling each other.


This means that a parser that is configurable from CFT code has to be written from
scratch. With the v1.3.0 branch safely merged into master, and closures and dictionaries
as objects implemented, it's time to start
considering parsing again.

## 2020-10-24 Objects ...


The v1.7.5 "dictionary-as-object" turned out really nice, letting lambdas stored inside Dict's
be wrapped into closures pointing at that dict. This eliminated the first syntax from v1.3.2 or
thereabouts, which included a separate ".invoke"-function.


The fact is that this is one of those features that came about, not from a grand plan, but
because it was possible and quite easy to implement, and only hours after upgrading to
the v1.7.5 syntax, I wrote the Lib:runProcess, which uses this and some other new features,
like the Process object.

## 2020-10-24 cleaning up - Java Parser


Decided to delete the Lib.Text.Parser that was to triumphantly (is that a word?) follow the
Lib.Text.Lexer. It got stuck, from lack of inspiration, and then I went ahead and created
a rudimentary JSON parser in pure CFT in under 150 lines.


Though grammars are fun, for now they will have to wait.

## 2020-10-24 loop spaces / the "pipe"


Having worked extensively through this document for the last days, it struck me as odd
that I did not earlier add musings about the "loop space" concept, which decidedly is
a bit ... odd?


This all stems from the "one-line-at-a-time" period, where scripts were entered from
the command line, and looooong before block expressions. Being a fairly compact
and efficient notation, and frequently used, loop spaces will not be purged from the language
just yet.


The "pipe" is completely optional, as Inner blocks can do all that "loop spaces" do (and more), but
at the cost of a bit more notation.

## 2020-11-12 Soft and hard errors


v1.8.x mainly focused on exception handling, separating CFT script errors from problems
from underlying Java code. Soft errors are those thrown by error() and Java errors are
hard, with one exception so far, as documented for that function (inside the TokenStream object
when matching tokens).


Some mechanism was needed after writing the first version of the JSON parser in CFT, and from
the realization that code libraries in CFT will need some way of throwing errors, that
can be caught separately from hard exceptions.


What actually took the most time, was figuring out what to name these two different categories
of errors.

## 2020-11-12 No more session values


As of v1.9 the session values via Val("name") and ValDef("name",value) have been removed from
the language. The reason is that as v1.9 is about adding multitasking, and none of the data
types are made thread safe, by eliminating session values, we eliminate concurrent updates.


The data stored in the database is synthesized and eval'ed, which means it is always
new values. This function is also used to create the "context" dictionary of values available
to the expressions to be run in separate processes, again ensuring no concurrent access
to CFT data structures.


At the same time the internal database was developed, as there is always need to remember
stuff. The difference is that databases don't null out between sessions. That is good and
bad news.

## 2020-11-12 CFT greatness


**v1.9.13**
### JSON parser


Today I modified the JSON parser written in CFT, to the point that it successfully
processed multiple random examples from the web. I created a "pretty-printer" too,
though it's not so pretty yet. I even fed output from the PP through the parser, and it
still agreed it was valid JSON.

### Util:ProcessMonitor


The second issue today was how SpawnProcess() can sometimes generate way too many
processes hammering away at the same time, for example doing apt upgrade on 30 VM's
on the same physical host.


I tried fitting something into the Java code, but it would be ugly and bulky, and so I abandoned
it. Then I started testing how to write it in CFT, as I have a script that needs
this, and ended up creating a neat
little function that returns an object, with callable lambdas for (1) wait until
no more than N processes are alive, and (2) register newly spawned process.


The finished code is 14 lines, and available as Util:ProcessMonitor. The function doc
is as long as the code :-)


The initial sense when moving to CFT, was that if only I had not removed support for
session values .... but it forced me making actual objects, which are much better.

### CFT code libraries growing


From my previous interpreted language project (called "GNT"), that was and is
actually being used in production at work, I remember
it being a special day when I realized that the amount of code written in the
language, far exceeded the amount of code for the interpreter.


Having worked extensively with the Hosts, SSH, KVM and PS scripts, to mention some
of the most important, that point is still a bit off into the future, but the
examples above indicate that the CFT script code base also keeps growing.

### Version 2 upcoming


I have implemented more than I envisioned for v2, except a tool for easily
browsing the databases (Db2 and Db2Obj). The templating possibilities begs
for letting CFT host a tiny web server, but the jury's still out on this.

## 2020-11-13 Script and code size


As a followup to yesterdays musings about size of code libraries, I had to check
the numbers.

```
Script code:      ~5k lines
Java code:        ~20k lines
Doc.html:         ~3800 lines
Dev.html:         ~3300 lines    # change history 2018-08
Functions:        ~290
Object types:     ~45
```

Functions means member functions of all object types (including values)

The object types are:

```
0: public class ObjRegex extends Obj {
1: public class ObjDataFile extends Obj {
2: public class ObjExtProcess extends Obj {
3: public class ObjDb2 extends Obj {
4: public class ObjData extends Obj {
5: public class ObjFile extends Obj {
6: public class ObjDir extends Obj {
7: public class ObjDateSort extends Obj {
8: public class ObjGlob extends Obj {
9: public class ObjDict extends Obj {
10: public abstract class ObjPersistent extends Obj {
11: public class ObjMath extends Obj {
12: public class ObjProcess extends Obj {
13: public class ObjFilterReader extends Obj {
14: public class ObjDuration extends Obj {
15: public class ObjConvert extends Obj {
16: public class ObjGrep extends Obj {
17: public class ObjClosure extends Obj {
18: public class ObjFilter extends Obj {
19: public class ObjSys extends Obj {
20: public class ObjPlot extends Obj {
21: public class ObjDate extends Obj {
22: public class ObjExp extends Obj {
23: public class ObjDb extends Obj {
24: public class ObjLib extends Obj {
25: public class ObjLineReader extends ObjPersistent implements CtxCloseHook {
26: public class ObjInput extends ObjPersistent {
27: public class ObjLexer extends Obj {
28: public class ObjLexerNode extends Obj {
29: public class ObjLexerTokenStream extends Obj {
30: public class ObjLexerToken extends Obj {
31: public class ObjText extends Obj {
32: public class ObjFiles extends Obj {
33: public abstract class Value extends Obj {
34: public class ObjGlobal extends Obj {
35: public class ObjCfg extends Obj {
0: public class ValueList extends Value {
1: public class ValueString extends Value {
2: public class ValueBlock extends Value {
3: public class ValueObjInt extends ValueInt {
4: public class ValueObjFloat extends ValueFloat {
5: public class ValueObjFileLine extends ValueString {
6: public class ValueObjStr extends ValueString {
7: public class ValueFloat extends Value {
8: public class ValueInt extends Value {
9: public class ValueNull extends Value {
10: public class ValueBoolean extends Value {
11: public class ValueObj extends Value {
```

