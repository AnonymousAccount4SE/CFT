

Lib.Data.each(0,99999)->x
	("0000"+x).last(5).chars.sort.concat => combo
	out(combo)
	| _.unique
/Comb


P(1,"12233")=>str
	dict=Dict
	str.chars->c
		dict.set(c,dict.get(c,0)+1)
	|
	oddCount=0
	dict.keys->key
		if (dict.get(key)%2==1) oddCount=oddCount+1
	|
	(oddCount<=1)

/isSymmetric




P(1,Input("Digits").get)=>str
P(2,str) => history
P(3,true) => verbose
	len=str.length
	max=0
	Lib.Data.for(0,len-1,1)->x
		Lib.Data.for(x+1,len,1)->y
			str.chars => chars
			xc=chars.nth(x).parseInt
			yc=chars.nth(y).parseInt
			Inner {
				Lib.Data.for(0,len,1)->i 
					assert(i != x && i != y)
					out(chars.nth(i))
				| _.concat
			} + "" + (xc+yc) => newCode
			if (newCode.length>1) {
				symmetry=isSymmetric(newCode)
				newHistory=history + "->" + newCode
				if (symmetry) {
					if (newCode.length>max) {
						max=newCode.length
						if (verbose) println(newHistory)
					}
				} else {
					if (newCode.length>=max) {
						xxx = maxSym(newCode,newHistory,verbose)
						if (xxx > max) max=xxx
					}
				}
			}
	|
	max
	
/maxSym


maxSym(null,null,true)
/m


count=0
Comb->c
	count=count+1
	if (count % 100 == 0) println(""+count)
	sym = isSymmetric(c)
	reject(sym)
	cnt=maxSym(c)
	reject(cnt > 2)
	println(c + " --- " + cnt)
/test

timeExpr(maxSym("293049"))
/t
