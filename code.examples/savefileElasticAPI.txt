# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2022 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
<<<< EOF
-------------------------------------------------------------
Simple script library for interfacing a running
ElasticSearch node (or cluster via one of its nodes),
through the REST API.

Initially asks for host+port on format xxx:NNN, then stores
this in database. 

To change to different host name, call MyHost(true)

#Note: the Util:CURL function has problems with JSON data
# on windows. Works fine on Linux / WSL

-------------------------------------------------------------
>>>> EOF
/Readme

# Get/set target hostname
# --
    P(1,false) => change

    Db2:Get("ElasticAPI","host") => name

    if (name==null || change) {
        println("Enter elasticsearch host[:port] (port defaults to 9200)")
        
        readLine("host:port") => name
        if(!name.contains(":")) name=name+":9200"
        Db2:Set("ElasticAPI","host",name)
    }
    name
/MyHost



# Change target hostname
# --
    MyHost(true)
/ChangeMyHost




# Create Kibana URL
# --
    MyHost.before(":") + ":5601/app/kibana"
/KibanaURL



# List indexes
    Util:CURL("http",MyHost,"GET","/_cat/indices?pretty",null,true)
/ListIndexes


# Create index
    P(1,Input("Create index name").get) => name

    Dict.set("settings",Dict
        .set("number_of_shards",1)
        .set("number_of_replicas",1)
    ) => data

    url = "/"+name+"?pretty"        
    Util:CURL("http",MyHost,"PUT", url, data, true)
/CreateIndex


# Add data WITH timestamp, in order to enable Index Lifetime Policies (ILP)
# --
	P(1,Input("Index name").get) => indexName

	Util:Counter("customer_id") => x
	data='{"name": "Roar", "timestamp": ' + currentTimeMillis + '}'
	Util:CURL("http",
		MyHost,
		"POST",
		"/" + indexName + "/_doc/"+x, 
		data,
		false
		)
		println(data)
/AddIndexData


# Check lifecycle progress
    Util:CURL("http",MyHost,"GET","/.ds-timeseries-*/_ilm/explain")
/LifecycleProgress


# Create or modify Index Lifecycle Policy - using minutes for testing
# NOTE: ILP can only be applied to Index that contains time field!!!
# --
    P(1,Input("Index Lifecycle Policy name").setCurrCond("RFTest").get) =>ilpName
    P(2,Input("Expiration minutes").get.parseInt)=>expirationMinutes
	
	rolloverMinutes=(expirationMinutes/3).i
	
	# Seems the rollover-part is not changed when running function
	# repeatedly, while the delete-part is.
	#
	# Deleting the policy from inside Kibana, then recreating it
	# with this function, we get it correct!

<<<<<<<< EOF
{
  "policy": {
    "phases": {
      "hot": {
        "min_age": "0ms",
        "actions": {
          "rollover": {
            "max_age": "<< rolloverMinutes >>m",
            "max_size": "2mb"
          }
        }
      },
      "delete": {
        "min_age": "<< expirationMinutes >>m",
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
>>>>>>>> EOF
	=> lines
	lines.mergeExpr->line out(line.trim) | _.concat(" ") => json
   
	# Show JSON
	Inner { JSON:PP(JSON:Parse(json))->line println(line) }

    url="/_ilm/policy/" + ilpName
    Util:CURL("http",MyHost,"PUT",url,json,false)
/CreateILP



# List ILP's
# --
	Util:CURL("http",MyHost,"GET","/_ilm/policy").stdout => json
	JSON:PP(JSON:Parse(json))
/ListILP


# Create Index Template - this is needed to connect indexes to ILM Policies
# https://www.elastic.co/guide/en/elasticsearch/reference/7.7/indices-templates.html
#
# Following this step, in kibana, go to Index Lifecycle policies, then 
# for our life cycle, select Action, then Add Policy to Index Template
#
# --
    P(1,Input("Index pattern").get) => indexPattern
	P(2,Input("Index template name").get) => templateName
<<< EOF
{
  "index_patterns": ["<< indexPattern >>"],
  "settings": {
    "number_of_shards": 1
  },
  "mappings": {
    "_source": {
      "enabled": false
    },
    "properties": {
      "host_name": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date",
        "format": "EEE MMM dd HH:mm:ss Z yyyy"
      }
    }
  }
}
>>> EOF
	_.mergeExpr->line out(line.trim) | _.concat(" ") => json

    println(json)
    println
    Util:CURL("http",MyHost,"POST","/_template/" + templateName + "?pretty",json,true)
        
/CreateIndexTemplate




# Delete dated indexes older than N days
# --
    P(1,30)=>keepDays
    P(2,60)=>scanSinceDays
    P(3,Lambda{P(1,Date)=>date error("Lambda not implemented")}) => LIndexName
        # The lambda takes a Date object, and should return an index name
        # for that day.
    P(4,false)=>enable
        # Leave false while testing, set to true to call DELETE

    Lib.Data.for(scanSinceDays,keepDays,-1)->daysAgo
        date = Date.sub(Date.Duration.days(daysAgo))
        indexName=LIndexName.call(date)
        if (enable) {
            result = Util:CURL("http",MyHost,"DELETE","/"+indexName,null,false)
            ok = true
            {result.stdout->line if(line.contains("index_not_found_exception")) ok=false}
            if (ok) 
                println("Deleted: " + indexName)
#       else
#           println("Not found: " + indexName)
        } else {
            println("indexName=" + indexName)
        }
/DeleteIndexes


# Delete day-indexes named on format <prefix><date>
# --
    P(1,Input("Get index prefix up to date string").get)=>prefix
    P(2,"yyyy.MM.dd")=>dateFormat
    P(3,30)=>keepDays
    P(4,60)=>scanSinceDays
    P(5,false)=>enable

    SymDict(prefix,dateFormat).set("LIndexName",
        Lambda {
            P(1)=>date
            self.prefix + date.setFormat(self.dateFormat).fmt
        }
    ) => obj
    DeleteIndexes(keepDays,scanSinceDays,obj.LIndexName,enable)
/DeletePrefixedDatedIndexes


# Delete day-indexes named on format main2-yyyy.MM.dd or similar
# --
    "main2-" => prefix
    "yyyy.MM.dd" => dateFormat
    30 => keepDays
    60 => scanSinceDays
    
    true => enable
    
    DeletePrefixedDatedIndexes(prefix, dateFormat, keepDays, scanSinceDays, enable)
/DeleteMain2


# Delete day-indexes named on format winlogbeat-6.4.2-yyyy.MM.dd or similar
# --
    "winlogbeat-6.4.2-" => prefix
    "yyyy.MM.dd" => dateFormat
    90 => keepDays
    180 => scanSinceDays
    
    true => enable
    
    DeletePrefixedDatedIndexes(prefix, dateFormat, keepDays, scanSinceDays, enable)
/DeleteWinlogbeat642
