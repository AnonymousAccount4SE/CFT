# Readme
<<<< EOF

Proof of concept for running background threads

The onLoad runs main in background, if not already running. The main function
is started via SpawnProcess, with the third parameter added in 2.9.3, which is
a lambda (or closure) that exists in the calling environment, and which is called
whenever there is output from the process, or it has terminated.

The main runs with a global instance of the ArchivingLambda, which might just as well
have been non-global, as all it does is save output to database.

The main in turn creates new processes for each job. These are run with a main-process 
lambda called ForwardingLambda, which sends output to the main-process environment.

To test, run function test(), which creates a job 4 seconds into the future. 

Then call GetOutput to show job output as forwarded via ForwardingLambda
and then stored into database via ArchivingLambda. 

Also depends on locks (Lib.Db.obtainLock)

Added the Stop function which makes the main loop terminate, which is helpful when
testing (running onLoad to restart the main loop)

--

The idea is to call Cron:onLoad from global onLoad setting in CFT.props, and to
modify the prompt code to call Cron:GetOutput before returning the prompt string.



>>>> EOF
->line 
	println("| " + line)
/Readme


# Get task list
# --
	Db2:Get(Sys.scriptName, "Tasks", List)
//GetTasks

# Save task list
# --
	P(1,List) => taskList
	Db2:Set(Sys.scriptName, "Tasks", taskList)
//SaveTasks


# Forwarding lambda (2.9.3) - forwards output from sub-process to stdout in current process
# --
	Lambda{
		P(1)=>proc 
		proc.output->line println(line) |
	} 
//ForwardingLambda


# Archiving lambda (2.9.3) - used with main loop
# --
	Lambda{
		P(1)=>proc
		list=proc.output
		if (proc.isDone) {
			list=list+("Returned " + proc.exitValue)
		} 
		Lib.Db.obtainLock("Cron.OUTPUT",1000)
		Db2:Get(Sys.scriptId,"Cron.OUTPUT",List)+list => list
		Db2:Set(Sys.scriptId,"Cron.OUTPUT",list)
		Lib.Db.releaseLock("Cron.OUTPUT")
	}
//ArchivingLambda
			

# Get archived output
# --
	Lib.Db.obtainLock("Cron.OUTPUT",1000)
	Db2:Get(Sys.scriptId,"Cron.OUTPUT",List) => list
	Db2:Set(Sys.scriptId,"Cron.OUTPUT",List) # empty list
	Lib.Db.releaseLock("Cron.OUTPUT")
	list->line println("|| " + line)
/GetOutput



GetOutput
/o


	

# Start background loop
# --
	Db2:Get(Sys.scriptName, "uuid", null) => x
	if (x==null || x != Sys.sessionUUID) {
		Db2:Set(Sys.scriptName, "run", true)
		Db2:Set(Sys.scriptName, "uuid", Sys.sessionUUID)
		SpawnProcess(Dict,main,ArchivingLambda)
	}
/onLoad


# Make main loop terminate
# (start it again with onLoad)
# --
	Db2:Set(Sys.scriptName, "run", false)
	Db2:Set(Sys.scriptName, "uuid", "")
/Stop


# Add task as lambda or closure
# --
	P(1,Date) => when
	P(2,Lambda{}) => lambdaOrClosure 
	P(3,"<no desc>") => desc
	
	dict=null
	lambda=null
	
	if(getType(lambdaOrClosure)=="Closure") {
		# Closures need to be stored as data and lambda separately, see DoWork
		dict=lambdaOrClosure.dict
		lambda=lambdaOrClosure.lambda
	} else {
		dict=Dict
		lambda=lambdaOrClosure
	}
		
	
	Lib.Db.obtainLock("Cron.tasks",8000)
	SaveTasks(GetTasks.add(SymDict(when,lambda,dict,desc)))
	Lib.Db.releaseLock("Cron.tasks")
/AddTask


# Main loop - run in background from onLoad if not already running
# --
	
	loop
		break(!Db2:Get(Sys.scriptName, "run", false))
		DoWork
		Sys.sleep(1000)
		#println("main-loop: " + Date.fmt)
//main


# Do work
# --
	Db2:Set(Sys.scriptName,"alive",Date)
	
	Lib.Db.obtainLock("Cron.tasks",5000)
	GetTasks->task
		if (task.when.before(Date)) {
			# The lambda stored in Db2 is stored inside a Dict, which makes it into a closure.
			# Calling the .lambda function of the closure restores the lambda! Calling .get() on
			# Dict object, to clarify.
			SpawnProcess(SymDict(task), { closure=task.dict.bind(task.get("lambda").lambda) closure.call }, ForwardingLambda)	
		} else {
			out(task)
		}
	| => newTaskList
	SaveTasks(newTaskList)
	Lib.Db.releaseLock("Cron.tasks")
//DoWork


# Show status
# --
	date = Db2:Get(Sys.scriptName,"alive")
	if (date != null && currentTimeMillis-date.get < 3000) {
		println("Running")
	} else {
		println("Inactive")
	}
	GetTasks->task
		println(""+task.when.fmt + " " + task.get("desc","<no description>"))
	|
/ShowStatus



ShowStatus
/s




# Add test task that runs 4 seconds from now
# --
AddTask(
	Date.add(Date.Duration.seconds(4)), Lambda{
		println("test-task")
	})
/test

	
	
# Example of stateful job, delivering a future reminder
# --
	P(1,Input("Enter reminder text").get) => text
	P(2,Input("Enter seconds delay").get.parseInt) => seconds
	date=Date.add(Date.Duration.seconds(seconds))
	closure=SymDict(text).bind(Lambda{
		println("Reminder: " + self.text)
	})
	AddTask(date, closure, "[reminder] " + text.first(20))
/reminder

	
# Example of regular job, waiting for a file to change
# Schedules itself at given interval in seconds until detecting file deleted or changed.
# --
	P(1)=>file
	P(2,10)=>intervalSeconds
	
	error(!file.exists,"File not found: " + file.path)
	
	lastModified=file.lastModified
	
	date=Date.add(Date.Duration.seconds(intervalSeconds))
	closure=SymDict(file,lastModified,intervalSeconds).bind(Lambda{
		if (!self.file.exists || self.file.lastModified != self.lastModified) {
			println("File " + self.file.path + " has changed")
		} else {
			Cron:watchFile(self.file, self.intervalSeconds)
		}
	})
	AddTask(date,closure,"[watchFile] " + file.path)
/watchFile


# Watch file demo - modify or delete file to trigger it
# --
	File("x.txt") => f
	f.create("something")
	watchFile(f)
/watchFileDemo



