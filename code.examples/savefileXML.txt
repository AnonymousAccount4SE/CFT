# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2022 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
<<<< EOF
XML parser written in CFT.
--------------------------

EXPERIMENTAL / 2021-04-28 RFO

Status: parses XML and checks for errors.

What works?
-----------
Handles strings (by unquoting them). Allows identifier values, seen as strings without quotes.
Unescapes strings and text (&lt; becomes '<' etc)
Handles comments and processing rules
    <!-- bla bla -->
    <? do this ?>
    
PrettyPrint (PP) implemented, 

2021-04-29 as of v2.4.5 we also support multi-line tokens (comments and processing rules)

>>>> EOF
/Readme





# test
# --
	Util:ShowDict(
		XMLNode("test")
	)
//node




# Build root lexer Node for tokens in XML
# --
    Lib.Text.Lexer.Node => root
    
    # WS = 1
    root.sub(" ^n^r^t".unEsc).setIsToken(1) => ws # whitespace
    ws.sub(" ^n^r^t".unEsc,ws)  # loop back
    
    # Specials = 2
    List("<",">","</","/>","=",":")->t root.addToken(t).setIsToken(2) |
    
    # Numbers = 3
    digits = "0123456789"
    root.sub(digits+"-"+"+").setIsToken(3) => integer
    integer.sub(digits,integer) # loop back
    integer.sub(".").sub(digits).setIsToken(3) => float 
    float.sub(digits,float) # loop back
    

    # Identifiers = 4
    identFirstChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    identInnerChars = identFirstChars + "0123456789"
    
    root.sub(identFirstChars).setIsToken(4) => ident
    ident.sub(identInnerChars, ident) # loop back

    # Strings = 5
    List('"',"'")->c 
        root.sub(c) => insideString
        insideString.setDefault(insideString)
        insideString.sub("\").setDefault(insideString)
        insideString.sub(c).setIsToken(5)
    |
    
    # XML specials = 10
    root.addToken("<?").setDefault => x
    x.setDefault(x)
    x.addToken("?>").setIsToken(10)  # processing instruction
    
    root.addToken("<!--").setDefault => x
    x.setDefault(x)
    x.addToken("-->").setIsToken(10)  # comment
    


    # Everything else = 99  
    root.setDefault.setIsToken(99)


    # return value is the root node
    root
//RootNode



# Example XML code
# ---
    Sequence(
        @    <!-- this is 
        @         a comment 
        @           2021/01/01 12:00:55 
        @    --><a:parent a="test" b=42 >
        @  
        @       <element "a"=5 b="test" c=ident d=23.5 e=+18 f=-9>2 + 3 &gt; 5</element>
        @   <? this is a test ?>
        @       <item>first item line
        @            second item line
        @       <title>Donald Duck &amp; Co</title>
        @       <emptyTag a=5/>
        @           <status>
        @             on-hold
        @           <count>2</count>
        @               <x a="1"> xxx </x>
        @       </status>
        @   	</item>
        @       <emptyTag a="a"/>
        @    </a:parent>
    )
/exampleXML


exampleXML
//ex


# Tokenize XML, then parse.
# Returns list of top-level objects, skipping text at outer level
# --
    P(1)=>xml
    P(2,false)=>debug

    if (xml==null) {
        println("Paste or enter XML, then terminate by '.' on single line")
        readLines(".") => xml
    }
    
    start=currentTimeMillis

    RootNode => root
    Lib.Text.Lexer => lexer
    
    xml->line 
        lexer.addLine(line) 
    |


    if (debug) Inner {
        lexer.getTokens(root)->t
            println("(" + t.tokenType + ") : " + t.str)
        |
    }

    lexer.getTokenStream(root) as LexerTokenStream => ts
    
    list=List
    loop
   		break(ts.EOF)
    	if (ts.peek=="<") {
    		obj=XMLNode
    		obj.parse(ts)
    		list.add(obj)
    	} else {
    		ts.next
    	}
    |
	list
/Parse


# XML node class
# --
	class XMLNode {
		P(1) as String? => tagName
		P(2,Dict) as Dict => attributes
		P(3,List) => content
		
		self.tagName=tagName
		self.attributes=attributes
		self.content=content
		
		# Get list of XMLNode from content
		# --
		self.contentNodes=Lambda{
			P(1) as String? => tag
			self.content->x
				x as? &XMLNode => isNode
				assert(isNode)
				assert(tag==null || x.tagName==tag)
				out(x)
		}
		
		
		## Parse from token stream
		## -----------------------
		
		self.parse=Lambda{
			P(1) as LexerTokenStream => ts

			ws=Lambda{ 
				P(1) as LexerTokenStream => ts 
				loop 
    				break(ts.EOF || ts.peekType != 1) 
    				ts.next
    		}

			# START TAG BEGIN + TAG NAME
			
			error(!ts.peek=="<",ts.sourceLocation + ": expected '<' starting a tag")
			ts.next
        	ws.call(ts)

        	error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
        	name=ts.peek
        	ts.next
        	
        	ws.call(ts)
        	
        	# Supporting tag names with XML name spaces: xxx:yyy
        	
        	if (ts.peek==":") {
        		name=name+":"
        		ts.next
        		ws.call(ts)
        		error(ts.peekType != 4, ts.sourceLocation + ": expected identifier following " + name)
        		name=name+ts.peek
        		ts.next
        		ws.call(ts)
        	}
        	
        	#println("STARTING tag " + name)
        	self.tagName=name
        	
        	
        	# TAG ATTRIBUTES
        	
        	Inner {
        		loop
        			ws.call(ts)
        			break(ts.peek==">" || ts.peek=="/>")

        				
		 			error (ts.peekType != 4 && ts.peekType != 5, 
		 				ts.sourceLocation + ": Expected identifier or string attribute name - got " + ts.peek)
		 				
		 			attrName=ts.peek
		 			if (ts.peekType==5) {
		 				# Strip quotes
		 				attrName=attrName.sub(1,attrName.length-1)
		 			}
		 			ts.next
		 			ws.call(ts)
		 			error(ts.peek != "=", 
		 				ts.sourceLocation + ": expected '=' for attribute " + attrName)

		 			ts.next
		 			ws.call(ts)
		 			error(ts.peekType != 4 && ts.peekType != 5 && ts.peekType() != 3, 
		 				ts.sourceLocation + ": Expected identifier, string or number value for attribtute " + attrName + " - got "+ ts.peek)
		 			attrValue=ts.peek

		 			if (ts.peekType==5) {
		 				# Strip quotes
		 				attrValue=attrValue.sub(1,attrValue.length-1)
		 			}

		 			ts.next
		 			ws.call(ts)
		 			
		 			self.attributes.attrName=attrValue	
        	}
        	
        	# START TAG END
        	
        	ws.call(ts)
        	hasContent=true
        	if (ts.peek==">") {
        		ts.next
        	} else if (ts.peek=="/>") {
        		hasContent=false
        		ts.next
        	} else {
        		error(ts.sourceLocation + ": expected '>' or '/>' closing tag " + name)
        	}
        	
        	
        	# CONTENT
        	if (hasContent) Inner {
        		text=""
        		loop
        			break(ts.peek=="</")
        			if(ts.peek=="<") {
        				self.content.add(text) 
        				text=""
        				node=XMLNode
        				node.parse(ts)
        				self.content.add(node)
      				}
      				# Everything else  			
        			text=text+ts.peek
        			ts.next
        		|
        		self.content.add(text)
 			}    
 			

			# CLOSING TAG
			if (hasContent) {
				ws.call(ts)
				error(ts.peek != "</", ts.sourceLocation + ": expected </ closing " + self.tagName)

            	ts.next
            	ws.call(ts)

            	error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")

            	name=ts.peek
            	ts.next
            	ws.call(ts)
            
            	if (ts.peek==":") {
                	name=name+":"
               		ts.next
                	ws.call(ts)
                
                	error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
                	name=name+ts.peek
                	ts.next
                	ws.call(ts)
            	}
            	error(self.tagName != name, ts.sourceLocation + ": Expected </" + self.tagName + "> - got </" + name + ">")
            	ts.match(">","expected '>' following '</"+name)
            	
   	 			#println("Got matching END-TAG to " + self.tagName)   			
            }
		

		} # self.parse
		
		## Pretty-print XML
		## ----------------
		self.PP=Lambda{
			P(1,"") as String => indent
			P(2,List) as List => result
			
			attributes=Inner{
				self.attributes.keys->attrName
					out(attrName + '="' + self.attributes.get(attrName) + '"')
				| _.concat(" ")
			}
			if (attributes.length>0) attributes=" "+attributes
			
			result.add(indent+"<"+self.tagName + attributes + if(self.content.length==0,"/>",">"))
			indent2=indent+"   "
			if (self.content.length>0) {
				Inner {
					self.content->x
						x as? &XMLNode => isNode
						if (isNode) {
							x.PP(indent2,result)
						} else {
							s=x.trim
							if (s.length>0) result.add(indent2 + s)
						}
				}
				result.add(indent+"</"+self.tagName+">")
			}
			
			result
		}
		
	}
/XMLNode






# Unescape special characters in string
# --
    P(1)=>s
    Util:UnescapeXMLString(s)
//UnescapeXMLString



# Escape special characters in string
# --
    P(1)=>s
    Util:EscapeXMLString(s)
//EscapeXMLString




# XMLNode.PP to show result from parse
# --
	node = Parse(exampleXML).first
	node.PP
/t1

# JSON:PP for all details after parse
# --
	node = Parse(exampleXML).first
	JSON:PP(node)
/t2


# Parse example, then pretty-print it. Parse the output, and pretty-print that.
# Compare the two outputs, should match
# --
	node = Parse(exampleXML).first
	result1=node.PP
	node = Parse(result1).first
	result2=node.PP
	#
	ok=result1.concat(" ")==result2.concat(" ")
	Lib:Header("Parse + PP1 + Parse + PP2 / PP1==PP2?")
	println(ok)
/t3


# Lookup test
# --
	node=Parse(exampleXML).first
	node.contentNodes("item").first.contentNodes("title").first.content.first
/lt1



    


Lib.Text.Lexer help
//LexerHelp


Lib.Text.Lexer.Node help
//NodeHelp


Lib.Text.Lexer.getTokenStream(Lib.Text.Lexer.Node) help
//TSHelp

