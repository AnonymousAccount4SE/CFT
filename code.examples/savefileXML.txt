# Readme
<<<< EOF
XML parser written in CFT.
--------------------------

EXPERIMENTAL / 2021-04-28 RFO

Status: parses XML and checks for errors.

What works?
-----------
Handles strings (by unquoting them). Allows identifier values, seen as strings without quotes.
Unescapes strings and text (&lt; becomes '<' etc)
Handles comments and processing rules
	<!-- bla bla -->
	<? do this ?>
	
PrettyPrint (PP) implemented, see test function 't'

2021-04-29 as of v2.4.5 we also support multi-line tokens (comments and processing rules)

>>>> EOF
/Readme



# Build root lexer Node for tokens in XML
# --
	Lib.Text.Lexer.Node => root
	
	# WS = 1
	root.sub(" ^n^r^t".unEsc).setIsToken(1) => ws # whitespace
	ws.sub(" ^n^r^t".unEsc,ws)  # loop back
	
	# Specials = 2
	List("<",">","</","/>","=",":")->t root.addToken(t).setIsToken(2) |
	
	# Numbers = 3
	digits = "0123456789"
	root.sub(digits+"-"+"+").setIsToken(3) => integer
	integer.sub(digits,integer) # loop back
	integer.sub(".").sub(digits).setIsToken(31) => float 
	float.sub(digits,float) # loop back
	

	# Identifiers = 4
	identFirstChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
	identInnerChars = identFirstChars + "0123456789"
	
	root.sub(identFirstChars).setIsToken(4) => ident
	ident.sub(identInnerChars, ident) # loop back

	# Strings = 5
	List('"',"'")->c 
		root.sub(c) => insideString
		insideString.setDefault(insideString)
		insideString.sub("\").setDefault(insideString)
		insideString.sub(c).setIsToken(5)
	|
	
	# XML specials = 10
	root.addToken("<?").setDefault => x
	x.setDefault(x)
	x.addToken("?>").setIsToken(10)  # processing instruction
	
	root.addToken("<!--").setDefault => x
	x.setDefault(x)
	x.addToken("-->").setIsToken(10)  # comment
	


	# Everything else = 99	
	root.setDefault.setIsToken(99)


	# return value is the root node
	root
//RootNode



# Example XML code
# ---
	Sequence(
		@    <!-- this is 
		@         a comment 
		@           2021/01/01 12:00:55 
		@    --><a:parent a="test" b=42 >
		@	 
		@       <element a=5 b="test" c=ident d=23.5 e=+18 f=-9>2 + 3 &gt; 5</element>
		@		<? this is a test ?>
		@       <element>another line of text
		@			<title>Donald Duck &amp; Co</title>
		@		</element>
		@       <emptyTag a="a"/>
		@    </a:parent>
	)
/exampleXML




# Tokenize XML, then parse 
# --
	P(1)=>xml
	P(2,false)=>debug

	if (xml==null) {
		println("Paste or enter XML, then terminate by '.' on single line")
		readLines(".") => xml
	}
	
	start=currentTimeMillis

	RootNode => root
	Lib.Text.Lexer => lexer
	
	xml->line 
		lexer.addLine(line) 
	|


	if (debug) Inner {
		lexer.getTokens(root)->t
			println("(" + t.tokenType + ") : " + t.str)
		|
	}

	ts=lexer.getTokenStream(root)
	ws(ts)
	
	list=List
	loop
		break(ts.EOF)
		ws(ts)
		break(ts.EOF)
		if (ts.peekType==10) {
			list.add(Dict.set("Special",ts.peek))
			ts.next
		} else 
		if (ts.peek=="<") {
			list.add(Obj(ts))
		} else {
			break(ts.EOF)
			list.add(ts.peek)
			ts.next
		}
	|

	list
/Parse







# Eat whitespace
# --
	P(1)=>ts
	loop break(ts.EOF || ts.peekType != 1) ts.next
//ws




# Unescape special characters in string
# --
	P(1)=>s
	Dict.set("&lt;","<")
		.set("&gt;",">")
		.set("&amp;","&")
		.set("&apos;","'")
		.set("&quot;",'"')
		=>data	
	s.merge(data)
/UnescapeXMLString



# Escape special characters in string
# --
	P(1)=>s
	Dict.set("<","&lt;")
		.set(">","&gt;")
		.set("'","&apos;")
		.set('"',"&quot;")
		=>data	
	s.replace("&","&amp;").merge(data)
/EscapeXMLString



# Match object <a ...> ... </a> 
# or <a ... />
#
# --
	P(1)=>ts

	dict=Dict
	
	ts.match("<","expected '<'")
	ws(ts)

	error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
	elementName=ts.peek	
	ts.next
	ws(ts)
	
	if (ts.peek==":") {
		elementName=elementName+":"   # name space
		ts.next
		ws(ts)
		error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
		elementName=elementName+ts.peek
		ts.next
		ws(ts)
	}
	
	dict.set("name",elementName)
	dict.set("attr", Dict)
	
	Inner {
		loop
			ws(ts)
			if (ts.peek==">") {
				ts.next
				dict.set("content",Content(ts, dict.name))  # list of strings and Dict's, until closing my name
				break
			} else if (ts.peek=="/>") {
				ts.next
				break
			} else {
				error(ts.peekType != 4, ts.sourceLocation + ": expected attribute name identifier")
				attrName=ts.peek
				ts.next
				ws(ts)
				ts.match("=","expected '=' following attribute name " + attrName)
				ws(ts)
				
				if (ts.peekType==3) { # int
					value=ts.peek.parseInt
				} else if (ts.peekType==31) { # float
					value=ts.peek.parseFloat
				} else if (ts.peekType==4) {  # identifier
					value=ts.peek
				} else if (ts.peekType==5) {  # string
					value=ts.peek
					value=value.sub(1,value.length-1)  # strip quotes
					value=UnescapeXMLString(value)
				} else {
					error(ts.sourceLocation + ": Invalid token: " + ts.peek)
				}
				ts.next
				ws(ts)
				dict.attr.set(""+attrName,value)
			}
	}
	dict
/Obj




# Returns list of content inside <x>...</x> - includes text and objects
# --
	P(1)=>ts
	P(2)=>currObjectName
	
	
	list=List
	
	Inner {
		text=""
		loop
			if (ts.peekType==10) {  # processing rule
				list.add(UnescapeXMLString(text))
				text=""
				list.add(Dict.set("Special",ts.peek))
				ts.next
			} else
			if (ts.peek=="</") {
				list.add(UnescapeXMLString(text))
				text=""
				
				ts.next
				ws(ts)

				error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")

				name=ts.peek
				ts.next
				ws(ts)
				
				if (ts.peek==":") {
					name=name+":"
					ts.next
					ws(ts)
					
					error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
					name=name+ts.peek
					ts.next
					ws(ts)
				}
				error(name != currObjectName, ts.sourceLocation + ": Invalid </"+name+"> - expected " + currObjectName)
				ts.match(">","expected '>' following '</"+name)

				list.add(UnescapeXMLString(text))
				text=""
				
				break
			} else if (ts.peek=="<") {
				list.add(text)
				text=""
				list.add(Obj(ts))
			} else {
				text=text+ts.peek
				ts.next
			}
	}
	list	
/Content




# Generate output
# --
	P(1)=>data   # Dict or List of (Dict | String)
	P(2,"")=>indent
	P(3,Lambda { println(""+P(1)) } )=>LOut
	
	data->element
		type=getType(element)
		if (type=="Dict") {
			if (element.has("Special")) {
				LOut.call(indent+element.get("Special").trim)
			} else {
				OutObject(element,indent,LOut)
			}	
		} else if (type=="String") {
			val=element.trim
			if (val != "") LOut.call(indent+EscapeXMLString(val))
		}
//OutContent



# Generate output
# --
	P(1)=>obj
	P(2)=>indent
	P(3,Lambda { println(""+P(1)) } )=>LOut
	
	firstTag="<"+obj.name
	obj.attr.keys->attrName
		value=obj.attr.get(attrName)
		if (getType(value)=="String") {
			value='"' + EscapeXMLString(value) + '"'
		} 
		firstTag=firstTag + " " + attrName + "=" + value
	|
	hasContent=true
	if (!obj.has("content") || obj.content.length==0) {
		firstTag=firstTag+"/>"
		hasContent=false
	} else {
		firstTag=firstTag + ">"
	}
	LOut.call(indent+firstTag)
	if (hasContent) {
		OutContent(obj.content,indent+"   ",LOut)
		LOut.call(indent+"</"+obj.name+">")
	}
//OutObject
	


# Pretty-print XML
# --
	P(1)=>data   # list of Dict
	
	Dict.set("list",List).set( "LAdd",Lambda{self.list.add(P(1))} ) => obj
	OutContent(data,"",obj.LAdd)
	
	obj.list
/PP
	
	
# Using local PP to show output
PP(Parse(exampleXML,false))
//t



# Using JSON:PP to show resulting structure
JSON:PP(Parse(exampleXML,false))
//t2


# Parse output from function 't' and present
PP(Parse(t))
//t3


# Time t3
a=currentTimeMillis
t3
b=currentTimeMillis
b-a
//tt


exampleXML
//e


Lib.Text.Lexer help
//LexerHelp


Lib.Text.Lexer.Node help
//NodeHelp


Lib.Text.Lexer.getTokenStream(Lib.Text.Lexer.Node) help
//TSHelp

