# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2022 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
<<<< EOF
XML parser written in CFT.
--------------------------

EXPERIMENTAL / 2021-04-28 RFO

Status: parses XML and checks for errors.

What works?
-----------
Handles strings (by unquoting them). Allows identifier values, seen as strings without quotes.
Unescapes strings and text (&lt; becomes '<' etc)
Handles comments and processing rules
    <!-- bla bla -->
    <? do this ?>
    
PrettyPrint (PP) implemented, 

2021-04-29 as of v2.4.5 we also support multi-line tokens (comments and processing rules)

>>>> EOF
/Readme



# XML node class
# --
	class XMLNode {
		P(1) as String => tagName
		P(2,Dict) as Dict => attributes
		P(3,XMLList) as &XMLList => content
		
		self.tagName=tagName
		self.attributes=attributes
		self.content=content

		self.setAttribute=Lambda{
			P(1) as String => name
			P(2) => value
			self.attributes.set(name,value)
		}
		self.getAttribute=Lambda{
			P(1) as String => name
			P(2) => defaultValue
			if (self.attributes.has(name)) self.attributes.get(name) else defaultValue
		}

	}
/XMLNode




# XML content list
# --
	class XMLList {
		P(1) as List? => content

		if (content != null) Inner {
			# Validate content
			content->x
				x as? String => a
				x as? &XMLNode => b
				error (!a && !b, "Invalid value, should be String and &XMLNode only, got : " + x)
			|
			self.list=content
		} else {
			self.list=List
		}
		self.addString=Lambda{
			P(1) as String => str
			list.add(str)
		}
		self.addNode=Lambda{
			P(1) as &XMLNode => node
			list.add(node)
		}
		self.getStrings=Lambda{
			list=List
			self.list->x
				if (getType(x)=="String") list.add(x)
			|
			list
		}
		self.getNodes=Lambda{
			P(1) as String? => tagName
			list=List
			self.list->x
				x as? &XMLNode => ok
				if(ok && (tagName==null || x.tagName==tagName)) list.add(x)
			|
			list
		}
	}
/XMLList



# test
# --
	Util:ShowDict(
		XMLNode("test")
	)
//node




# Build root lexer Node for tokens in XML
# --
    Lib.Text.Lexer.Node => root
    
    # WS = 1
    root.sub(" ^n^r^t".unEsc).setIsToken(1) => ws # whitespace
    ws.sub(" ^n^r^t".unEsc,ws)  # loop back
    
    # Specials = 2
    List("<",">","</","/>","=",":")->t root.addToken(t).setIsToken(2) |
    
    # Numbers = 3
    digits = "0123456789"
    root.sub(digits+"-"+"+").setIsToken(3) => integer
    integer.sub(digits,integer) # loop back
    integer.sub(".").sub(digits).setIsToken(31) => float 
    float.sub(digits,float) # loop back
    

    # Identifiers = 4
    identFirstChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    identInnerChars = identFirstChars + "0123456789"
    
    root.sub(identFirstChars).setIsToken(4) => ident
    ident.sub(identInnerChars, ident) # loop back

    # Strings = 5
    List('"',"'")->c 
        root.sub(c) => insideString
        insideString.setDefault(insideString)
        insideString.sub("\").setDefault(insideString)
        insideString.sub(c).setIsToken(5)
    |
    
    # XML specials = 10
    root.addToken("<?").setDefault => x
    x.setDefault(x)
    x.addToken("?>").setIsToken(10)  # processing instruction
    
    root.addToken("<!--").setDefault => x
    x.setDefault(x)
    x.addToken("-->").setIsToken(10)  # comment
    


    # Everything else = 99  
    root.setDefault.setIsToken(99)


    # return value is the root node
    root
//RootNode



# Example XML code
# ---
    Sequence(
        @    <!-- this is 
        @         a comment 
        @           2021/01/01 12:00:55 
        @    --><a:parent a="test" b=42 >
        @  
        @       <element a=5 b="test" c=ident d=23.5 e=+18 f=-9>2 + 3 &gt; 5</element>
        @   <? this is a test ?>
        @       <item>another line of text
        @       <title>Donald Duck &amp; Co</title>
        @           <status>
        @             on-hold
        @           <count>2</count>
        @               <x a=1>xxx</x>
        @       </status>
        @   </item>
        @       <emptyTag a="a"/>
        @    </a:parent>
    )
/exampleXML




# Tokenize XML, then parse.
# --
    P(1)=>xml
    P(2,false)=>debug

    if (xml==null) {
        println("Paste or enter XML, then terminate by '.' on single line")
        readLines(".") => xml
    }
    
    start=currentTimeMillis

    RootNode => root
    Lib.Text.Lexer => lexer
    
    xml->line 
        lexer.addLine(line) 
    |


    if (debug) Inner {
        lexer.getTokens(root)->t
            println("(" + t.tokenType + ") : " + t.str)
        |
    }

    ts=lexer.getTokenStream(root)
    ws(ts)
    
    list=List
    loop
        break(ts.EOF)
        ws(ts)
        break(ts.EOF)
        if (ts.peekType==10) {
            list.add(ts.peek)
            ts.next
        } else 
        if (ts.peek=="<") {
            list.add(Obj(ts))
        } else {
            break(ts.EOF)
            list.add(ts.peek)
            ts.next
        }
    |
    XMLList(list)
/Parse







# Eat whitespace
# --
    P(1)=>ts
    loop 
    	break(ts.EOF || ts.peekType != 1) ts.next
//ws




# Unescape special characters in string
# --
    P(1)=>s
    Util:UnescapeXMLString(s)
//UnescapeXMLString



# Escape special characters in string
# --
    P(1)=>s
    Util:EscapeXMLString(s)
//EscapeXMLString



# Match object <a ...> ... </a> or <a ... /> - returns XMLNode object
#
# --
    P(1)=>ts

    ts.match("<","expected '<'")
    ws(ts)

    error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
    elementName=ts.peek   
    ts.next
    ws(ts)
    
    if (ts.peek==":") {
        elementName=elementName+":"   # name space
        ts.next
        ws(ts)
        error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
        elementName=elementName+ts.peek
        ts.next
        ws(ts)
    }

	obj=XMLNode(elementName)

    Inner {
        loop
            ws(ts)
            if (ts.peek==">") {
                ts.next
                obj.content=Content(ts, elementName)
                #dict.set("content",Content(ts, dict.name))  # list of strings and Dict's, until closing my name
                break
            } else if (ts.peek=="/>") {
                ts.next
                break
            } else {
                error(ts.peekType != 4, ts.sourceLocation + ": expected attribute name identifier")
                attrName=ts.peek
                ts.next
                ws(ts)
                ts.match("=","expected '=' following attribute name " + attrName)
                ws(ts)
                
                if (ts.peekType==3) { # int
                    value="" + ts.peek.parseInt
                } else if (ts.peekType==31) { # float
                    value="" + ts.peek.parseFloat
                } else if (ts.peekType==4) {  # identifier
                    value=ts.peek
                } else if (ts.peekType==5) {  # string
                    value=ts.peek
                    value=value.sub(1,value.length-1)  # strip quotes
                    value=UnescapeXMLString(value)
                } else {
                    error(ts.sourceLocation + ": Invalid token: " + ts.peek)
                }
                ts.next
                ws(ts)
                obj.setAttribute(attrName, value)
            }
    }
    obj
//Obj




# Returns list of content inside <x>...</x> - includes text and objects as XMLList object
# --
    P(1)=>ts
    P(2)=>currObjectName
    
    
    list=List
    
    Inner {
        text=""
        loop
            if (ts.peekType==10) {  # processing rule
                
                text=text.trim
                if (text.length>0) {
                    list.add(UnescapeXMLString(text))
                }
                text=""
                
                # "Special"
                list.add(ts.peek)
                ts.next
            } else
            if (ts.peek=="</") {
                
                text=text.trim
                if (text.length>0) {
                    list.add(UnescapeXMLString(text))
                }
                text=""
                
                ts.next
                ws(ts)

                error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")

                name=ts.peek
                ts.next
                ws(ts)
                
                if (ts.peek==":") {
                    name=name+":"
                    ts.next
                    ws(ts)
                    
                    error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
                    name=name+ts.peek
                    ts.next
                    ws(ts)
                }
                error(name != currObjectName, ts.sourceLocation + ": Invalid </"+name+"> - expected " + currObjectName)
                ts.match(">","expected '>' following '</"+name)

                break
            } else if (ts.peek=="<") {
            
                text=text.trim
                if (text.length>0) {
                    list.add(UnescapeXMLString(text))
                }
                text=""
                
                list.add(Obj(ts))
            } else {
                text=text+ts.peek
                ts.next
            }
    }
    XMLList(list)
//Content




# JSON:PP(Parse(...)) using defaults
# (Shows all closures but not the object types)
# --
JSON:PP(Parse(exampleXML),false,true)
/t
    




# Generate output
# --
    P(1)=>data   # &XMLNode or &XMLList  or List of (Dict | String)
    P(2,"")=>indent
    P(3,Lambda { println(""+P(1)) } )=>LOut
    
    data as? XMLList => isList
    data as? XMLNode => isNode
    
    if (isNode) {
    	OutObject(data,ident,LOut)
    } else {
		data.list->element
		    type=getType(element)
		    println("OutContent: " + element)
		    if (type=="Dict") {
		        OutObject(element,indent,LOut)
		    } else {
		        val=element.trim
		        if (val != "") LOut.call(indent+EscapeXMLString(val))
		    }
	}
//OutContent



# Generate output
# --
    P(1) as &XMLNode
     =>obj
    P(2)=>indent
    P(3,Lambda { println(""+P(1)) } )=>LOut
    
    
    firstTag="<"+obj.tagName
    obj.attributes.keys->attrName
        value=obj.attributes.get(attrName)
        if (getType(value)=="String") {
            value='"' + EscapeXMLString(value) + '"'
        } 
        firstTag=firstTag + " " + attrName + "=" + value
    |
    hasContent=true
    if (!obj.has("content") || obj.content.list.length==0) {
        firstTag=firstTag+"/>"
        hasContent=false
        LOut.call(indent+firstTag)
    } else {
        firstTag=firstTag + ">"
    }
    if (hasContent) {
        lastTag="</"+obj.tagName+">"
        if (obj.content.list.length==1 && getType(obj.content.list.first)=="String") {
            LOut.call(indent+firstTag+obj.content.list.first.trim+lastTag)
        } else {
            LOut.call(indent+firstTag)
            OutContent(obj.content,indent+"   ",LOut)
            LOut.call(indent+lastTag)
        }
    }
//OutObject


# Pretty-print XML
# --
    P(1) as &XMLList => data
    
    obj=Dict.set("list",List)
    obj.bind(Lambda{self.list.add(P(1))} ) => closure
    	
    OutContent(data,"",closure)
    
    obj.list
/PP


PP(Parse(exampleXML))
/t2



# Test lookups
# --
    Parse(exampleXML) => obj
    XML:Get(obj,"a:parent") -> parent
        XML:Get(parent,"element") -> element
            XML:GetAttrNames(element)->attr
                println("-> " + attr + "=" + XML:GetAttr(element,attr))
//L1



# Test lookups
# --
    Parse(exampleXML) => obj
    XML:Get(obj,"a:parent") -> parent
        XML:Get(parent,"item") -> item
            XML:Get(item,"title")->title
                println("title=" + GetContent(title))
//L2



# Test lookups with space separated path of names
# --
    Parse(exampleXML) => obj
    XML:GetPath(obj,"a:parent item title") -> title
                println("title=" + GetContent(title))
//L3
    



exampleXML
//e


Lib.Text.Lexer help
//LexerHelp


Lib.Text.Lexer.Node help
//NodeHelp


Lib.Text.Lexer.getTokenStream(Lib.Text.Lexer.Node) help
//TSHelp

