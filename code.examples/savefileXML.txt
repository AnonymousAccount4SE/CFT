# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2022 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
<<<< EOF
XML parser written in CFT.
--------------------------

EXPERIMENTAL / 2021-04-28 RFO

Status: parses XML and checks for errors.

What works?
-----------
Handles strings (by unquoting them). Allows identifier values, seen as strings without quotes.
Unescapes strings and text (&lt; becomes '<' etc)
Handles comments and processing rules
    <!-- bla bla -->
    <? do this ?>
    
PrettyPrint (PP) implemented, 

2021-04-29 as of v2.4.5 we also support multi-line tokens (comments and processing rules)

>>>> EOF
/Readme





# test
# --
	Util:ShowDict(
		XMLNode("test")
	)
//node




# Build root lexer Node for tokens in XML
# --
    Lib.Text.Lexer.Node => root
    
    # WS = 1
    root.sub(" ^n^r^t".unEsc).setIsToken(1) => ws # whitespace
    ws.sub(" ^n^r^t".unEsc,ws)  # loop back
    
    # Specials = 2
    List("<",">","</","/>","=",":")->t root.addToken(t).setIsToken(2) |
    
    # Numbers = 3
    digits = "0123456789"
    root.sub(digits+"-"+"+").setIsToken(3) => integer
    integer.sub(digits,integer) # loop back
    integer.sub(".").sub(digits).setIsToken(3) => float 
    float.sub(digits,float) # loop back
    

    # Identifiers = 4
    identFirstChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    identInnerChars = identFirstChars + "0123456789"
    
    root.sub(identFirstChars).setIsToken(4) => ident
    ident.sub(identInnerChars, ident) # loop back

    # Strings = 5
    List('"',"'")->c 
        root.sub(c) => insideString
        insideString.setDefault(insideString)
        insideString.sub("\").setDefault(insideString)
        insideString.sub(c).setIsToken(5)
    |
    
    # XML specials = 10
    root.addToken("<?").setDefault => x
    x.setDefault(x)
    x.addToken("?>").setIsToken(10)  # processing instruction
    
    root.addToken("<!--").setDefault => x
    x.setDefault(x)
    x.addToken("-->").setIsToken(10)  # comment
    


    # Everything else = 99  
    root.setDefault.setIsToken(99)


    # return value is the root node
    root
//RootNode



# Example XML code
# ---
    Sequence(
        @    <!-- this is 
        @         a comment 
        @           2021/01/01 12:00:55 
        @    --><a:parent a="test" b=42 >
        @  
        @       <element a=5 b="test" c=ident d=23.5 e=+18 f=-9>2 + 3 &gt; 5</element>
        @   <? this is a test ?>
        @       <item>another line of text
        @       <title>Donald Duck &amp; Co</title>
        @       <emptyTag a=5/>
        @           <status>
        @             on-hold
        @           <count>2</count>
        @               <x a="1"> xxx </x>
        @       </status>
        @   	</item>
        @       <emptyTag a="a"/>
        @    </a:parent>
    )
/exampleXML


exampleXML
//ex


# Tokenize XML, then parse.
# Returns list of top-level objects, skipping text at outer level
# --
    P(1)=>xml
    P(2,false)=>debug

    if (xml==null) {
        println("Paste or enter XML, then terminate by '.' on single line")
        readLines(".") => xml
    }
    
    start=currentTimeMillis

    RootNode => root
    Lib.Text.Lexer => lexer
    
    xml->line 
        lexer.addLine(line) 
    |


    if (debug) Inner {
        lexer.getTokens(root)->t
            println("(" + t.tokenType + ") : " + t.str)
        |
    }

    lexer.getTokenStream(root) as LexerTokenStream => ts
    
    list=List
    loop
   		break(ts.EOF)
    	if (ts.peek=="<") {
    		obj=XMLNode
    		obj.parse(ts)
    		list.add(obj)
    	} else {
    		ts.next
    	}
    |
	list
/Parse


# XML node class
# --
	class XMLNode {
		P(1) as String? => tagName
		P(2,Dict) as Dict => attributes
		P(3,List) => content
		
		self.tagName=tagName
		self.attributes=attributes
		self.content=content
		self.parent=null
		
		self.path=Lambda{
			Inner {
				node=self
				loop
					break(node==null)
					out(node.tagName)
					node=node.parent
			}.reverse
		}
		
		self.dump=Lambda{
			P(1,"")=>indent

			println(indent+self.tagName)
			self.attributes.keys->attrName
				println(indent+"   "+attrName+"="+self.attributes.get(attrName))
			|
			self.content->x
				x as? &XMLNode => isNode
				if (isNode) {
					x.dump(indent+"   ")
				} else Inner {
					x.split->word out(word.trim) | _.concat(" ") => str
					println(indent+"     " + str)
				}
			|
		}
		
		self.pathStr=Lambda{
			self.path.concat(" -> ")
		}	

		self.setAttribute=Lambda{
			P(1) as String => name
			P(2) => value
			self.attributes.set(name,value)
		}
		self.getAttribute=Lambda{
			P(1) as String => name
			P(2) => defaultValue
			if (self.attributes.has(name)) self.attributes.get(name) else defaultValue
		}
		
		## Parse from token stream
		## -----------------------
		
		self.parse=Lambda{
			P(1) as LexerTokenStream => ts

			ws=Lambda{ 
				P(1) as LexerTokenStream => ts 
				loop 
    				break(ts.EOF || ts.peekType != 1) 
    				ts.next
    		}

			# OPENING TAG
			
			error(!ts.peek=="<",ts.sourceLocation + ": expected '<' starting a tag")
			ts.next
        	ws.call(ts)

        	error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
        	name=ts.peek
        	ts.next
        	
        	ws.call(ts)
        	if (ts.peek==":") {
        		name=name+":"
        		ts.next
        		ws.call(ts)
        		error(ts.peekType != 4, ts.sourceLocation + ": expected identifier following " + name)
        		name=name+ts.peek
        		ts.next
        		ws.call(ts)
        	}
        	
        	#println("STARTING tag " + name)
        	self.tagName=name
        	
        	#println(self.pathStr)
        	
        	
        	# TAG ATTRIBUTES
        	
        	Inner {
        		loop
        			ws.call(ts)
        			break(ts.peek==">" || ts.peek=="/>")
        			
		 			error (ts.peekType != 4 && ts.peekType != 5, 
		 				ts.sourceLocation + ": Expected identifier or string attribute name - got " + ts.peek)
		 				
		 			attrName=ts.peek
		 			ts.next
		 			ws.call(ts)
		 			error(ts.peek != "=", 
		 				ts.sourceLocation + ": expected '=' for attribute " + attrName)

		 			ts.next
		 			ws.call(ts)
		 			error(ts.peekType != 4 && ts.peekType != 5 && ts.peekType() != 3, 
		 				ts.sourceLocation + ": Expected identifier, string or number value for attribtute " + attrName + " - got "+ ts.peek)
		 			attrValue=ts.peek
		 			ts.next
		 			ws.call(ts)
		 			
		 			self.setAttribute(attrName, attrValue)	
        	}
        	
        	# START TAG END
        	
        	ws.call(ts)
        	hasContent=true
        	if (ts.peek==">") {
        		ts.next
        	} else if (ts.peek=="/>") {
        		hasContent=false
        		ts.next
        	} else {
        		error(ts.sourceLocation + ": expected '>' or '/>' closing tag " + name)
        	}
        	
        	
        	# CONTENT
        	if (hasContent) Inner {
        		text=""
        		loop
        			break(ts.peek=="</")
        			if(ts.peek=="<") {
        				self.content.add(text) 
        				text=""
        				node=XMLNode
        				node.parent=self
        				node.parse(ts)
        				self.content.add(node)
      				}
      				# Everything else  			
        			text=text+ts.peek
        			ts.next
        		|
        		self.content.add(text)
 			}    
 			

			# CLOSING TAG
			if (hasContent) {
				ws.call(ts)
				error(ts.peek != "</", ts.sourceLocation + ": expected </ closing " + self.tagName)

            	ts.next
            	ws.call(ts)

            	error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")

            	name=ts.peek
            	ts.next
            	ws.call(ts)
            
            	if (ts.peek==":") {
                	name=name+":"
               		ts.next
                	ws.call(ts)
                
                	error(ts.peekType != 4, ts.sourceLocation + ": expected identifier")
                	name=name+ts.peek
                	ts.next
                	ws.call(ts)
            	}
            	error(self.tagName != name, ts.sourceLocation + ": Expected </" + self.tagName + "> - got </" + name + ">")
            	ts.match(">","expected '>' following '</"+name)
            	
   	 			#println("Got matching END-TAG to " + self.tagName)   			
            }
		

		} # self.parse
	}
/XMLNode






# Unescape special characters in string
# --
    P(1)=>s
    Util:UnescapeXMLString(s)
//UnescapeXMLString



# Escape special characters in string
# --
    P(1)=>s
    Util:EscapeXMLString(s)
//EscapeXMLString




# JSON:PP(Parse(...)) using defaults
# (Shows all closures but not the object types)
# --
	node = Parse(exampleXML).first
	node.dump
	
/t
    





# Generate output
# --
    P(1)=>data   # &XMLNode or &XMLList  or List of (Dict | String)
    P(2,"")=>indent
    P(3,Lambda { println(""+P(1)) } )=>LOut
    
    data as? XMLList => isList
    data as? XMLNode => isNode
    
    if (isNode) {
    	OutObject(data,ident,LOut)
    } else {
		data.list->element
		    type=getType(element)
		    println("OutContent: " + element)
		    if (type=="Dict") {
		        OutObject(element,indent,LOut)
		    } else {
		        val=element.trim
		        if (val != "") LOut.call(indent+EscapeXMLString(val))
		    }
	}
//OutContent



# Generate output
# --
    P(1) as &XMLNode
     =>obj
    P(2)=>indent
    P(3,Lambda { println(""+P(1)) } )=>LOut
    
    
    firstTag="<"+obj.tagName
    obj.attributes.keys->attrName
        value=obj.attributes.get(attrName)
        if (getType(value)=="String") {
            value='"' + EscapeXMLString(value) + '"'
        } 
        firstTag=firstTag + " " + attrName + "=" + value
    |
    hasContent=true
    if (!obj.has("content") || obj.content.list.length==0) {
        firstTag=firstTag+"/>"
        hasContent=false
        LOut.call(indent+firstTag)
    } else {
        firstTag=firstTag + ">"
    }
    if (hasContent) {
        lastTag="</"+obj.tagName+">"
        if (obj.content.list.length==1 && getType(obj.content.list.first)=="String") {
            LOut.call(indent+firstTag+obj.content.list.first.trim+lastTag)
        } else {
            LOut.call(indent+firstTag)
            OutContent(obj.content,indent+"   ",LOut)
            LOut.call(indent+lastTag)
        }
    }
//OutObject


# Pretty-print XML
# --
    P(1) as &XMLList => data
    
    obj=Dict.set("list",List)
    obj.bind(Lambda{self.list.add(P(1))} ) => closure
    	
    OutContent(data,"",closure)
    
    obj.list
/PP


PP(Parse(exampleXML))
/t2



# Test lookups
# --
    Parse(exampleXML) => obj
    XML:Get(obj,"a:parent") -> parent
        XML:Get(parent,"element") -> element
            XML:GetAttrNames(element)->attr
                println("-> " + attr + "=" + XML:GetAttr(element,attr))
//L1



# Test lookups
# --
    Parse(exampleXML) => obj
    XML:Get(obj,"a:parent") -> parent
        XML:Get(parent,"item") -> item
            XML:Get(item,"title")->title
                println("title=" + GetContent(title))
//L2



# Test lookups with space separated path of names
# --
    Parse(exampleXML) => obj
    XML:GetPath(obj,"a:parent item title") -> title
                println("title=" + GetContent(title))
//L3
    



exampleXML
//e


Lib.Text.Lexer help
//LexerHelp


Lib.Text.Lexer.Node help
//NodeHelp


Lib.Text.Lexer.getTokenStream(Lib.Text.Lexer.Node) help
//TSHelp

