# Readme
# --
<<<<<< EOF

Toying with identifying ways to unify particle energies, by dividing each
value repeatedly, or actually, multiplying by factor in range 0-1, until value
inside a given range, then calculate variance.

Values near 1 are invalid, as they creep the value down in smaller and smaller
increments, making all values line up nicely, so mostly run with range 0.05 to 0.8

Found that the smallest variance is for factor 0.6966728 (variance 204 when normalizing 0-1000)

Functions

   - "r" - set range
   - "s" - search range, looking for minimum variance
   - "h" - show histogram for current range
   - "rand" - get lowest variance for random data sets of same length as real data

Currently focused on quarks only.

2021-11-18: For range 0-0.8
	The random data produces a lowest variance of around 700 (average)
  	The real data provides lowest variance of 204
  	The random data provides variance lower than this for about 15-25% of the random data sets

>>>>>> EOF
->line
	println("| " + line)
/Readme

P(1)*1000 
/K

P(1)*1000000
/M

P(1)*1000000000
/G

# Define range
# --
	readLine("Start value").parseFloat=>start
	readLine("End value").parseFloat=>end
	if (start < 0.05) start=0.05
	if (end > 0.95) end=0.95

	SymDict(start,end) => data
	Db2:Set(Sys.scriptId,"range",data)
/SetRange



# Get range
# --
	Db2:Get(Sys.scriptId,"range") => result
	if (result==null) {
		SetRange
		result=GetRange
	}
	result
/GetRange



# Data
# --
	P(1,false)=>random
	
	Sequence(
		M(2.2)   # up
		G(1.28)  # charm
		G(173.1) # top
		M(4.7)   # down
		M(96)    # strange
		G(4.18)  # bottom
	) => actualValues
	
	
	if (random) {
		Inner {
			actualValues->x  # to produce same number
				if (Lib.Util.random < 0.5) {
					G(Lib.Util.random*10)
				} else {
					M(Lib.Util.random*10)
				} => v
				out(v)
		}
	} else {
		actualValues
	}

/Data

# Sin(45) = Sqrt(2)/2
# --
	0.707106781186
/factor


# Normalize value
# --
	P(1,100000) => value
	P(2,0.5)=> factor
	P(3,1000) => range

	loop
		break(value<range)
		value=value*factor
	|
	value
/NormalizeValue


# Process data set
# --
	P(1,0.5)=>factor
	P(2,Data)=>data
	data->value
		out(NormalizeValue(value, factor))
/Normalize


# Calculate variance of set
# --
	P(1,List(1,2,3))=>data
	sum=0
	data->x sum=sum+x |
	avg=sum/data.length
	varianceSum=0
	data->x 
		diff=if(x>avg, x-avg, avg-x)
		varianceSum=varianceSum + (diff*diff)
	|
	# return value
	varianceSum / data.length
/Variance



# Fix presentation of floats
# --
	P(1,3.14159265) => value
	P(2,5) => numDecimals
	s=""+value
	pos=s.indexOf(".")
	if (pos >= 0) {
		s=s.sub(0,pos+1+numDecimals)
	}
	s
/fix





# Find lowest variance for current range
# --
	P(1,false)=>random
	
	lowestVariance = 999999
	lowestVarianceFactor = 0

	highestVariance=0
	highestVarianceVactor=0

	STEPS=30000
	theData=Data(random)

	range=GetRange
	Lib.Data.for(range.start, range.end, (range.end-range.start)/STEPS)->factor
		data = Normalize(factor,theData)
		var = Variance(data)
		if (var < lowestVariance) {
			lowestVariance=var
			lowestVarianceFactor=factor
		}
		if (var > highestVariance) {
			highestVariance=var
			highestVarianceFactor=factor
		}
		println("factor=" + fix(factor,12) + " variance=" + fix(Variance(data),12))

	|
	println("--")
	println("LOW  factor="+fix(lowestVarianceFactor,12) + " variance=" + fix(lowestVariance,12))
	println("HIGH factor="+fix(highestVarianceFactor,12) + " variance=" + fix(highestVariance,12))

	lowestVarianceFactor
/Search




# Show for specific factor
# --
	P(1,readLine("Enter factor").parseFloat) => factor
	if (factor > 1) factor=1/factor
	if (factor < 0.05) factor=0.05
	if (factor > 0.95) factor=0.95

	data = Normalize(factor)
	data->x
		println(x)
	|
	println
	println("Factor=" + factor)
	println("Variance=" + Variance(data))
	true
/Show
	


# Visualize
# --
	range=GetRange
	LINES=Term.h
	Lib.Data.for(range.start, range.end, (range.end-range.start)/LINES)->factor
		data = Normalize(factor)
		var = Variance(data)
		out(AValue("",var,SymDict(factor)))
	| => values

	WIDTH=Term.w-11
	max=0
	values->v if(v.v>max) max=v.v |
	factor=WIDTH/max
	values->v
		len=(v.v*factor).i
		Lib.Data.yes(len,"#").concat => bar
		fStr=(""+v.meta.factor+"00000000").sub(0,8)
		println(fStr + " " + bar)
/Histogram



# Examine random data sets
# --
	P(1,204)=>realDataVariance
	P(2,100)=>maxCount
	
	count=0
	
	countUnderRealValue=0
	loop
		break(count >= maxCount)
		count=count+1
		
		if (count % 100 == 0) println("[" + count + "]")
		theData=Data(true)
		
		STEPS = 1000
		
		lowest=99999999
		range=GetRange
		Inner {
			Lib.Data.for(range.start, range.end, (range.end-range.start)/STEPS)->factor
				data=Normalize(factor, theData)
				var=Variance(data)
				if (var<lowest) lowest=var
		} 
		#println("count="+count + " lowestVar=" + fix(lowest,3))
		if (lowest<realDataVariance) {
			countUnderRealValue=countUnderRealValue+1
			println("[" + count + "] Under real data variance value: " + fix(countUnderRealValue/count*100,2) + "%")
		}
		out(lowest)
	| => data
	
	sum=0
	lowest=9999999999
	data->value
		if (value<lowest) lowest=value
		sum=sum+value
	|
	println("Average=" + sum/data.length)
/CheckRandomData



SetRange
/r

Search
/s

Search(true)
/sr

Histogram
/h


CheckRandomData
/rand
