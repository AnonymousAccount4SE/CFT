# Generate pixelated letters using squares
# Returns ref for additional text
# --
	P(1,"TXT")=>str
	P(2)=>world
	P(3)=>ref
	P(4,10)=>pixelSize
	P(5,Lib.Color(255,0,0)) => color
	
	thickness=pixelSize/3
	
	
	# ref is pointing along direction of text, centered in height
	
	bSize=pixelSize*0.8
	b1=world.Brush.box(bSize,bSize,color)

	
	lines=Letters7x5:GetText(str)
	Lib.Data.each(0,6)->lineNo
		line=lines.nth(lineNo)
		Lib.Data.each(0,line.length-1)->charNo
			ch=line.chars.nth(charNo)
			if (ch != " ") {
				pos=ref.up(3.5*pixelSize)
					.down(lineNo*pixelSize)
					.fwd(charNo*pixelSize)
					.down(0.5*pixelSize)
					.fwd(0.5*pixelSize)
					.turnRight(90)
					.back(thickness/2)
				b1.penDown(pos)
				b1.penDown(pos.fwd(thickness))
				b1.penUp
			}
	|
	ref.fwd((lines.first.length+2)*pixelSize)
/Letters3d

		
# Target dir
# --
	Dir("/home/roar/anim").create
/TargetDir


# Subdir
# --
	TargetDir.sub("letters").create
/SubDir

# Subdir
# --
	TargetDir.sub("letters").create
/SubDir

# Test
# --
	
	Lib.Data.for(0,360,1)->rot
		Lib.DDD.World => world
		ref = Lib.DDD.Ref.setScaleFactor(1000)
		ref = ref
			.fwd(5-Lib.Math.sin(rot*2)*0.7)
			.left(2+Lib.Math.sin(rot*3)*0.4)
			.turnRight(60)
			.rollLeft(Lib.Math.sin(rot)*30)


		str="CFT RULES"
		Inner {
			Lib.Data.for(0,str.length,1)->charPos
				offset=rot+charPos*2
				red=(Lib.Math.cos(offset*2)*127+127).i
				green=(Lib.Math.cos(offset+180)*60+127).i
				blue=(Lib.Math.sin(offset+90)*127+127).i
				color=Lib.Color(red,green,blue)
				ref=DDDLetters:Letters3d(str.chars.nth(charPos),world,ref,0.1,color)
		}

		#ref = DDDLetters:Letters3d("GNT ",world,ref,0.1,color)
		#ref = DDDLetters:Letters3d("RULES",world,ref,0.1,Lib.Color(255,255,0))
		
		rotStr=("0000"+rot).last(3)
		
		println("rot="+rotStr)
		f=SubDir.create.file("letters_" + rotStr +".png")
		world.render(f)
/test


# Create mp4 movie (requires ffmpeg)
# --
	SubDir.run("ffmpeg -i letters_%3d.png result.mp4".split)
/makeMovie
