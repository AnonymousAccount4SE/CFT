# Readme
<<<<<< EOF
Forth-inspired language intended for micro controllers.

This is a "test implementation" of a compiler.

Defining functions is outside the language, as in CFT, for example

=b =a a 1 + b 1 + *
/+1mul

We need to compile code libraries into byte format, and put those
sequences into PROG_MEM structures in the interpreter code, which is
written in C. 

To test functions, we compile them and generate a hex-string format to send to 
the uC via serial, inspecting feedback via serial (and additional log device).

If ok, we name the function, and it gets added to the code library on the
next build, but also it gets added to the uC in RAM.

Ideally we want CFT to communicate directly with the uC, as well as modifying 
the .hh and .cpp files for the project, so that it can be recompiled and deployed
to get updated use of PROG_MEM.

Both a base library and all application functions are created this way.

>>>>>> EOF
/Readme


# Upper bits of 16 bit int
# --
	P(1,12553) => i
	if (getType(i)=="String") i=i.parseInt
	i.bin(16).first(8).parseInt(2)
/High

# Lower bits of 16 bit int
# --
	P(1,12553) => i
	if (getType(i)=="String") i=i.parseInt
	i.bin(16).parseInt(2)
/Low


# Ref object - represents a yet unresolved label
# --
	P(1) as String => label
	
	self.label=label
/class Ref


# Label object 
# --
	P(1) as String => label
	
	self.label=label
/class Label




 	
# Op-codes - the definition
# Each op-code is 1 byte.
#
# The PUSH command takes in-op-code 7 bit value and pushes it on the stack.
# It is the only OP-code that starts with a 1-bit.
# 
# Compiler must build code. Using (n) notation for values inside OP-code
#
# Example: push -0xFFFF (invalid sign, but worst case)
#
# PUSH(0x7F) 
# PUSH(1) 
# LSHIFT  
# PUSH(1) 
# ADD 
# PUSH(8)
# LSHIFT # got "high byte" of int
# PUSH(0x7F) 
# PUSH(1) 
# LSHIFT
# PUSH(1) 
# ADD  # "low byte"
# BIT_OR
# INV_SIGN # flip sign

# A total of max 14 instructions

# --
    Dict
        .set('JMP',                  1)
        .set('ZJMP',                 2)  #  cond addr -		| JMP if zero
        .set('RETURN',               3)
        .set('EOF',                  4)  #               	| end-of-function
        .set('CALL',                 5)  #  addr            | call defined function
        .set('PC',                   6)  #               | get program counter
        .set('CSTACK',               7)  #               | call stack depth
        .set('STACK',                8)  #               | data stack depth

		.set('U14',					10)  # hi7 low7 - int | (hi7 << 7 | low7)

        .set('LREAD',               11)  #  pos - data   | local variable read
        .set('LWRITE',              12)  #  pos -        | local variable write
        .set('READ',                13)  #  addr - data    | read byte from memory address
        .set('READ2',               14)  #  addr - data    | read two bytes as int from memory address
        .set('WRITE',               15)  #  data addr -    | write byte to memory address
        .set('WRITE2',              16)  #  data addr -    | write two bytes int to memory address
        .set('DUP',                 17)
        .set('SWAP',                18)
        .set('POP',                 19)
        .set('GT',                  20)
        .set('LT',                  21)
        .set('GE',                  22)
        .set('LE',                  23)
        .set('NE',                  24)
        .set('EQ',                  25)
        .set('AND',                 26)
        .set('OR',                  27)
        .set('NOT',                 28)  # data - data    | binary invert bits
        .set('ADD',                 29)
        .set('SUB',                 30)
        .set('MUL',                 31)
        .set('DIV',                 32)
        .set('MOD',                 33)
        .set('LSHIFT',              34)
        .set('RSHIFT',              35)
        .set('BIT_AND',             36)
        .set('BIT_OR',              37)
        .set('NEGATE',              38)  #  data - data    | invert number sign
/OpCodes




# Output object contains of
# - strings (comments)
# - opcodes and data (bytes as int)
# - Ref and Label objects
#
# Before generating binary output, Ref's must match up with Label's positions
# in the code, completing those JMP's 
# --
	self.opCodes=OpCodes
	
	self.code=List
		# Strings are comment, ints are code
	
	self.str=Lambda{
		P(1) as String => s
		self.code.add(s)
	}
	
	self.ref=Lambda{
		P(1) as &Ref => ref
		self.code.add(ref)
	}
	
	self.label=Lambda{
		P(1) as &Label => label
		self.code.add(label)
	}
	
	self.bin=Lambda{
		P(1) as int => i
		self.code.add(i)
	}
	
	self.op=Lambda{
		P(1) as String => opName
		error (!self.opCodes.has(opName),"Invalid opName " + opName)
		i=self.opCodes.get(opName)
		self.bin(i)
	}

	self.pushInt=Lambda{
		P(1) as int => i

		inv=false
		if (i<0) {
			i=-i
			inv=true
		}

		if (i<=127) {
			self.push7bit(i)
		} else if (i <= 16383) {
			# 14 bits
			digits=i.bin(14)
			a=digits.first(7).parseInt(2)
			b=digits.last(7).parseInt(2)
			self.push7bit(a)
			self.push7bit(b)
			self.op("U14")
		} else {
			# full 16 bits
			digits = i.bin(16)
			a = digits.first(6).parseInt(2)
			digits=digits.last(10)
			b = digits.first(5).parseInt(2)
			c = digits.last(5).parseInt(2)
			
			self.push7bit(a)

			#self.str("-> LSHIFT(10)")
			self.push7bit(10)
			self.op("LSHIFT") # a

			self.push7bit(b)

			#self.str("-> LSHIFT(5)")
			self.push7bit(5)
			self.op("LSHIFT") # b
		
			self.push7bit(c)   # c

			#self.str("-> BIT_OR BIT_OR")
			self.op("BIT_OR")
			self.op("BIT_OR")
		}

		if (inv) {
			self.op("NEGATE")
		}
	}

	self.push7bit=Lambda{
		P(1) as int => i
		
		#self.str("PUSH("+i + "=" + i.bin(8) + ")")
		digits="1"+(i.bin(8).last(7))
		# self.str("-> OP=" + digits)
		self.bin(digits.parseInt(2))
	}
		
	self.show=Lambda{
		P(1,true) as boolean => includeBinary
		self.code->x
			x as? String => isString
			x as? &Ref => isRef
			x as? &Label => isLabel
			x as? int => isInt

			if (isString) {
				println(x)
			} else if (isRef) {
				# ignore
			} else if (isLabel) {
				# ignore
			} else if (isInt) {
				if (includeBinary) {
					s=("   " + x).last(3)
					bin=x.bin(8)
					if (bin.first(1) == "0") {
						bin=""
					} else {
						bin="  " + bin
					}
					println("   " + s + bin)
				}
			} else {
				error("Unexpected value in self.code: " + x)
			}
		|

	}

	self.getBinary=Lambda{
		# Step 1: resolve label positions
		
		byteCount=0
		labels=Dict
		self.code->x
			x as? String => isString
			x as? &Ref => isRef
			x as? &Label => isLabel
			x as? int => isInt
			
			if (isString) {
				# ignore
			} else if (isRef) {
				byteCount=byteCount+3
			} else if (isLabel) {
				labels.set(x.label,byteCount)
			} else if (isInt) {
				byteCount=byteCount+1
			} else {
				error("Unexpected value in self.code: " + x)
			}
		|
			
		# Step 2: generate binary output
		OpCodes.get("U14") => u14

		self.code->x
			x as? String => isString
			x as? &Ref => isRef
			x as? &Label => isLabel
			x as? int => isInt
			
			if (isString) {
				# ignore
			} else if (isRef) {
				label=x.label
				error(!labels.has(label),"No label " + label)
				i=labels.get(label)
				# 7+7 bits, each embedded in op-code starting with 1 ("PUSH")
				("1" + i.bin(14).first(7)).parseInt(2) => op1
				("1" + i.bin(7)).parseInt(2) => op2
				out(op1)
				out(op2)
				out(u14)  # special instruction creating U14 integer from 2 x 7-bit bytes
			} else if (isLabel) {
				# ignore
			} else if (isInt) {
				out(x)
			} else {
				error("Unexpected value in self.code: " + x)
			}
	}
		
/class Output



Util:ShowDict(Output,true)
/h


# Get unique id
# --
	Util:Counter(Sys.scriptId + "_counter", 1000)
/id



# context object for if conditional
# --
	P(1) as &Output => output
	self.output=output
	self.endLabel=":endIf_" + id
	
	self.output.str("ZJMP " + self.endLabel)
	self.output.ref(Ref(self.endLabel))
	self.output.op("ZJMP")
	
	self.close = Lambda {
		self.output.str(self.endLabel)
		self.output.label(Label(self.endLabel))
	}
/class CtxCond

# context object for loop
# --
	P(1) as &Output => output
	
	self.output=output
	self.loopLabel=":loop_start_" + id
	self.endLabel=":loop_end_" + id
	
	self.output.str(self.loopLabel)
	self.output.label(Label(self.loopLabel))
	
	self.condBreak = Lambda {
		self.output.str("NOT ZJMP " + self.endLabel + " # break")
		self.output.op("NOT")
		self.output.op("ZJMP")
		self.output.ref(Ref(self.endLabel))
	}
	self.close = Lambda {
		self.output.str("JMP " + self.loopLabel)
		self.output.op("JMP")
		self.output.ref(Ref(self.loopLabel))
		
		self.output.str(self.endLabel)
		self.output.label(Label(self.endLabel))
	}
/class CtxLoop



# Mapping to instructions
# --
	Dict
		.set(">","GT")
		.set("<","LT")
		.set(">=","GE")
		.set("<=","LE")
		.set("!=","NE")
		.set("==","EQ")
		.set("+","ADD")
		.set("-","SUB")
		.set("*","MUL")
		.set("-","DIV")
		.set("%","MOD")
#		.set(":byte","TYPE_BYTE")
#		.set(":int","TYPE_INT")
#		.set(":?","TYPE_ANY")
		.set("&&","AND")
		.set("||","OR")
		.set("&","BIT_AND")
		.set("|","BIT_OR")
#		.set("!","NOT")
		.set("<<","LSHIFT")
		.set(">>","RSHIFT")
	=>dict

	# Allow instructions in lower case
	OpCodes.keys->key
		dict.set(key.toLower, key)
	|
	dict
/Instr


# PROGMEM compiled functions
# --
	self.data=Db2:Get(Sys.scriptId,"data",List)
	self.dict=Db2:Get(Sys.scriptId,"dict",Dict)

	self.add = Lambda{
		P(1) as String => name
		P(2) as List => code
		self.dict.set(name, self.data.length)
		self.data=self.data + code
		self.save
	}
	self.save = Lambda {
		Db2:Set(Sys.scriptId,"data",self.data)
		Db2:Set(Sys.scriptId,"dict",self.dict)
	}
	self.lookup = Lambda {
		P(1) as String => name
		if (self.dict.has(name), self.dict.get(name), null)
	}
	self.list = Lambda {
		self.dict.keys
	}
	self.clear = Lambda {
		self.data=List
		self.dict=Dict
		self.save
	}
/class CompiledFunctions
	

# Forth compiler
# --
	P(1,readLine("Enter code")) => line
	P(2,Output) => output
	
	Lib:Header(line)
	stack=Util:Stack   # context stack, for nested if's and loops
	
	instr=Instr
	
	localVariables=Dict
	compiledFunctions=CompiledFunctions
		
	line.split->part
		if (part=="if{") {
			stack.push(CtxCond(output))
		} else if (part=="loop{") {
			stack.push(CtxLoop(output))
		} else if (part=="}") {
			ctx=stack.pop
			error(ctx==null,"no current context: '}'")
			ctx.close
		} else if (part=="break") {
			ctx=stack.peek
			ctx as? &CtxLoop => isLoop
			if (isLoop) ctx.condBreak
		} else if (part.startsWith("=")) {
			name=part.sub(1)
			output.str("LWRITE " + name)
			pos=localVariables.keys.length
			localVariables.set(name,pos)
			output.pushInt(pos)
			output.op("LWRITE")
		} else {

			if (localVariables.has(part)) {
				output.str("LREAD " + part)
				output.pushInt(localVariables.get(part))
				output.op("LREAD")

			} else if (instr.has(part)) {
				opCode=instr.get(part)
				output.str(opCode)
				output.op(opCode)
			
			#} else if (OpCodes.has(part)) {
			#	output.str(part)
			#	output.op(part)
				
			} else {
				if (part.?parseInt) {
					output.str("PUSH " + part)
					output.pushInt(part.parseInt)
				} else {
					pos=compiledFunctions.lookup(part)
					error(pos==null,"Unknown function: " + part)
					output.str("CALL " + part + " (pos=" + pos + ")")
					output.str("->PUSH " + pos)
					output.pushInt(pos)
					
					output.op("CALL")
				}
			}
		}	
	|
	output.str("EOF (end-of-function)")
	output.op("EOF")
	output		
/Compile	




# Enter and run code, optionally naming it a function
# --
	P(1,readLine("Enter code line")) => code
	
	
	Compile(code) => output
	output.show
	code=output.getBinary
	println("#bytes = " + code.length)
	
	P(2,readLine("Enter function name, ENTER to abort")).trim => fname
	if (fname != "") {
		CompiledFunctions.add(fname,code)
	}
	
/run


# Test compilation only
# --
	P(1,readLine("Enter code line")) => code
	
	Compile(code) => output
	output.show(false)
	println
	println("### Number of bytes: " + output.getBinary.length)
/test


# Show functions
# --
	CompiledFunctions.list
/list


# Fixed code line
# --
	code = "=b =a a b + 10 < if{ a b doSomething }"
	test(code)
/t1


# Fixed code line
# --
	code = "1 =i loop{ i 1 + dup =i 10 >= break }"
	test(code)
/t2

# Advanced example
# --

# Wait for SPI_READY bit (19.5.2)
<<< EOF
	1 7 << =SPIF
	loop{
		SPSR read SPIF & break
	}
>>> EOF
	-> line out(line.trim) | _.concat(" ") => code
	run(code,"SPI_WAIT")
/t3

# Set bit in register
# (reg mask - )
# --
<<< EOF
	=mask =reg
	reg read 
		mask or 
			reg write
>>> EOF
	-> line out(line.trim) | _.concat(" ") => code
	run(code,"SET_BIT")
/t4

# Clear bit in register
# (reg mask - )
# --
<<< EOF
	=mask =reg
	reg read 
		mask not and
			reg write
>>> EOF
	-> line out(line.trim) | _.concat(" ") => code
	run(code,"CLR_BIT")
/t5


# Select compiled function by name
# --
	Lib:MenuSelect(CompiledFunctions.list, null, "Select function")
//SelectCompiledFunction


# Disassemble
# --
	P(1,SelectCompiledFunction) => funcName
	CompiledFunctions => cfunc
	cfunc.lookup(funcName) => pos
	cfunc.data => data

	# reverse the OpCodes dict to map from int to code
	dict=Dict
	opc=OpCodes
	Inner {
		opc.keys->key
			val=""+opc.get(key)
			dict.set(val,key)
	}
	

	loop
		instr=data.nth(pos)
		#println("instr=" + instr)
		if (instr.bin(8).startsWith("1")) {
			instr.bin(7) => bin
			report(pos,"PUSH",bin)
			#println(""+pos + ": PUSH " + bin)
		} else {
			opcode=dict.get(""+instr)
			report(pos,opcode)
			#println(opcode)
		}
		break(instr==4)  # EOF
		pos=pos+1
/dis


# Disassembler reveals JMP's (Labels and Refs) is broken, as the patching of
# Label positions into corresponding Ref's assumes two data bytes. We need
# to encode these as 
#
#	PUSH upper-7-bits
#   PUSH lower-7-bits
#   U14   # combine the two into U14 for JUMPS
#
# Implementing this in Output.pushInt(), and extending byte count for REF to 3.
# 
# Nice not to use opcode 0, as it detects bad number processing!


# ----------------


# atmega328p registers
# --
<<< EOF
00 R0
01 R1
02 R2
03 R3
04 R4
05 R5
06 R6
07 R7
08 R8
09 R9
0a R10
0b R11
0c R12
0d R13
0e R14
0f R15
10 R16
11 R17
12 R18
13 R19
14 R20
15 R21
16 R22
17 R23
18 R24
19 R25
1a R26
1b R27
1c R28
1d R29
1e R30
1f R31

23 PINB
24 DDRB
25 PORTB
26 PINC
27 DDRC
28 PORTC
29 PIND
2a DDRD
2b PORTD
36 TIFR1
37 TIFR2
3b PCIFR
3c EIFR
3d EIMSK
3e GPIOR0
3f EECR
40 EEDR
41 EEARL
42 EEARH
43 GTCCR
44 TCCR0A
45 TCCR0B
46 TCNT0
47 OCR0A
48 OCR0B
4a GPIOR1
4b GPIOR2
4c SPCR
4d SPSR
4d SPDR
50 ACSR
53 SMCR
54 MCUSR
55 MCUCR
57 SPMCSR
5d SPL
5d SPH
60 WDTSCR
61 CLKPR
64 PRR
66 OSCCAL
68 PCICR
69 EICRA
6b PCMSK0
6c PCMSK1
6d PCMSK2
6e TIMSK0
6f TIMSK1
70 TIMSK2
78 ADCL
79 ADCH
7a ADCSRA
7b ADSCRB
7c ADMUX
7e DIDR0
7f DIDR1
80 TCCR1A
81 TCCR1B
82 TCCR1C
84 TCNT1L
85 TCNT1H
86 ICR1L
87 ICR1H
88 OCR1AL
89 OCR1AH
8a OCR1BL
8b OCR1BH
b0 TCCR2A
b1 TCCR2B
b2 TCNT2
b3 OCR2A
b4 OCR2B
b6 ASSR
b8 TWBR
b9 TWSR
ba TWAR
bb TWDR
bc TWCR
bd TWAMR
c0 UCSR0A
c1 UCSR0B
c2 UCSR0C
c4 UBRR0L
c5 UBRR0H
c6 UDR0
>>>> EOF
	=> lines

	dict=Dict # checking against duplicates
	lines->line
		reject(line.trim=="")
		line.split.first.parseInt(16) => addr
		line.split.last => name

		error(dict.has(name), "Duplicate: " + name)
		dict.set(name,1)

		Forth:run(""+addr, name)
/registers


# Init atmega328p
# --
	CompiledFunctions.clear

	# System registers
	registers

	# XYZ registers
	Forth:run("R26","XL")
	Forth:run("R27","XH")
	Forth:run("R28","YL")
	Forth:run("R29","YH")
	Forth:run("R30","ZL")
	Forth:run("R31","ZH")

	Lib:Header("SUMMARY")
	println("Code space: " + CompiledFunctions.data.length)
	println("Func names: " + (CompiledFunctions.dict.keys.concat.length) + " chars")
	println("Num functions: " + (CompiledFunctions.list.length))

/init328
