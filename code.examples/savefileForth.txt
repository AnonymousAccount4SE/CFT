# Readme
<<<<<< EOF
Forth-inspired language intended for micro controllers.

This is a "test implementation" of a compiler.

Defining functions is outside the language, as in CFT, for example

=b =a a 1 + b 1 + *
/+1mul

We need to compile code libraries into byte format, and put those
sequences into PROG_MEM structures in the interpreter code, which is
written in C. 

To test functions, we compile them and generate a hex-string format to send to 
the uC via serial, inspecting feedback via serial (and additional log device).

If ok, we name the function, and it gets added to the code library on the
next build, but also it gets added to the uC in RAM.

Ideally we want CFT to communicate directly with the uC, as well as modifying 
the .hh and .cpp files for the project, so that it can be recompiled and deployed
to get updated use of PROG_MEM.

Both a base library and all application functions are created this way.

>>>>>> EOF
/Readme


# Upper bits of 16 bit int
# --
	P(1,12553) => i
	if (getType(i)=="String") i=i.parseInt
	i.bin(16).first(8).parseInt(2)
/High

# Lower bits of 16 bit int
# --
	P(1,12553) => i
	if (getType(i)=="String") i=i.parseInt
	i.bin(16).parseInt(2)
/Low


# Ref object - represents a yet unresolved label
# --
	P(1) as String => label
	
	self.label=label
/class Ref


# Label object 
# --
	P(1) as String => label
	
	self.label=label
/class Label




 	
# Op-codes - the definition
# Each op-code is 1 byte.
#
# The PUSH command takes in-op-code 7 bit value and pushes it on the stack.
# It is the only OP-code that starts with a 1-bit.
# 
# Compiler must build code. Using (n) notation for values inside OP-code
#
# Example: push -0xFFFF (invalid sign, but worst case)
#
# PUSH(0x7F) 
# PUSH(1) 
# LSHIFT  
# PUSH(1) 
# ADD 
# PUSH(8)
# LSHIFT # got "high byte" of int
# PUSH(0x7F) 
# PUSH(1) 
# LSHIFT
# PUSH(1) 
# ADD  # "low byte"
# BIT_OR
# INV_SIGN # flip sign

# A total of max 14 instructions

# --
    Dict
        .set('JMP',                  1)
        .set('ZJMP',                 2)  #  cond addr -		| JMP if zero
        .set('RETURN',               3)
        .set('EOF',                  4)  #               	| end-of-function
        .set('CALL',                 5)  #  addr            | call defined function
        .set('PC',                   6)  #               | get program counter
        .set('CSTACK',               7)  #               | call stack depth
        .set('STACK',                8)  #               | data stack depth


        .set('LREAD',               11)  #  pos - data   | local variable read
        .set('LWRITE',              12)  #  pos -        | local variable write
        .set('READ',                13)  #  addr - data    | read byte from memory address
        .set('READ2',               14)  #  addr - data    | read two bytes as int from memory address
        .set('WRITE',               15)  #  data addr -    | write byte to memory address
        .set('WRITE2',              16)  #  data addr -    | write two bytes int to memory address
        .set('DUP',                 17)
        .set('SWAP',                18)
        .set('POP',                 19)
        .set('GT',                  20)
        .set('LT',                  21)
        .set('GE',                  22)
        .set('LE',                  23)
        .set('NE',                  24)
        .set('EQ',                  25)
        .set('AND',                 26)
        .set('OR',                  27)
        .set('NOT',                 28)
        .set('ADD',                 29)
        .set('SUB',                 30)
        .set('MUL',                 31)
        .set('DIV',                 32)
        .set('MOD',                 33)
        .set('LSHIFT',              34)
        .set('RSHIFT',              35)
        .set('BIN_AND',             36)
        .set('BIN_OR',              37)
        .set('NEGATE',              38)  #  data - data    | invert number sign


		#.set('PUSH',				127) # the last 7 bits are data
/OpCodes




# Output object contains of
# - strings (comments)
# - opcodes and data (bytes as int)
# - Ref and Label objects
#
# Before generating binary output, Ref's must match up with Label's positions
# in the code, completing those JMP's 
# --
	self.opCodes=OpCodes
	
	self.code=List
		# Strings are comment, ints are code
	
	self.str=Lambda{
		P(1) as String => s
		self.code.add(s)
	}
	
	self.ref=Lambda{
		P(1) as &Ref => ref
		self.code.add(ref)
	}
	
	self.label=Lambda{
		P(1) as &Label => label
		self.code.add(label)
	}
	
	self.bin=Lambda{
		P(1) as int => i
		self.code.add(i)
	}
	
	self.op=Lambda{
		P(1) as String => opName
		error (!self.opCodes.has(opName),"Invalid opName " + opName)
		i=self.opCodes.get(opName)
		self.bin(i)
	}

	self.pushInt=Lambda{
		P(1) as int => i

		inv=false
		if (i<1) {
			i=-i
			inv=true
		}

		if (i<=127) {
			self.push7bit(i)
		} else {
			digits = i.bin(16)
			a = digits.first(6).parseInt(2)
			digits=digits.last(10)
			b = digits.first(5).parseInt(2)
			c = digits.last(5).parseInt(2)
			
			self.push7bit(a)

			#self.str("-> LSHIFT(10)")
			self.push7bit(10)
			self.op("LSHIFT") # a

			self.push7bit(b)

			#self.str("-> LSHIFT(5)")
			self.push7bit(5)
			self.op("LSHIFT") # b
		
			self.push7bit(c)   # c

			#self.str("-> BIN_OR BIN_OR")
			self.op("BIN_OR")
			self.op("BIN_OR")
		}

		if (inv) {
			self.op("NEGATE")
		}
	}

	self.push7bit=Lambda{
		P(1) as int => i
		
		#self.str("PUSH("+i + "=" + i.bin(8) + ")")
		digits="1"+(i.bin(8).last(7))
		# self.str("-> OP=" + digits)
		self.bin(digits.parseInt(2))
	}
		
	self.show=Lambda{
		self.code->x
			x as? String => isString
			x as? &Ref => isRef
			x as? &Label => isLabel
			x as? int => isInt

			if (isString) {
				println(x)
			} else if (isRef) {
				# ignore
			} else if (isLabel) {
				# ignore
			} else if (isInt) {
				s=("   " + x).last(3)
				bin=x.bin(8)
				if (bin.first(1) == "0") {
					bin=""
				} else {
					bin="  " + bin
				}
				println("   " + s + bin)
			} else {
				error("Unexpected value in self.code: " + x)
			}
		|

	}

	self.getBinary=Lambda{
		# Step 1: resolve label positions
		
		byteCount=0
		labels=Dict
		self.code->x
			x as? String => isString
			x as? &Ref => isRef
			x as? &Label => isLabel
			x as? int => isInt
			
			if (isString) {
				# ignore
			} else if (isRef) {
				byteCount=byteCount+2
			} else if (isLabel) {
				labels.set(x.label,byteCount)
			} else if (isInt) {
				byteCount=byteCount+1
			} else {
				error("Unexpected value in self.code: " + x)
			}
		|
			
		# Step 2: generate binary output
		self.code->x
			x as? String => isString
			x as? &Ref => isRef
			x as? &Label => isLabel
			x as? int => isInt
			
			if (isString) {
				# ignore
			} else if (isRef) {
				label=x.label
				error(!labels.has(label),"No label " + label)
				i=labels.get(label)
				out(High(i))
				out(Low(i))
			} else if (isLabel) {
				# ignore
			} else if (isInt) {
				out(x)
			} else {
				error("Unexpected value in self.code: " + x)
			}
	}
		
/class Output



Util:ShowDict(Output,true)
/h


# Get unique id
# --
	Util:Counter(Sys.scriptId + "_counter", 1000)
/id



# context object for if conditional
# --
	P(1) as &Output => output
	self.output=output
	self.endLabel=":endIf_" + id
	
	self.output.str("ZJMP " + self.endLabel)
	self.output.op("ZJMP")
	self.output.ref(Ref(self.endLabel))
	
	self.close = Lambda {
		self.output.str(self.endLabel)
		self.output.label(Label(self.endLabel))
	}
/class CtxCond

# context object for loop
# --
	P(1) as &Output => output
	
	self.output=output
	self.loopLabel=":loop_start_" + id
	self.endLabel=":loop_end_" + id
	
	self.output.str(self.loopLabel)
	self.output.label(Label(self.loopLabel))
	
	self.condBreak = Lambda {
		self.output.str("NOT ZJMP " + self.endLabel + " # break")
		self.output.op("NOT")
		self.output.op("ZJMP")
		self.output.ref(Ref(self.endLabel))
	}
	self.close = Lambda {
		self.output.str("JMP " + self.loopLabel)
		self.output.op("JMP")
		self.output.ref(Ref(self.loopLabel))
		
		self.output.str(self.endLabel)
		self.output.label(Label(self.endLabel))
	}
/class CtxLoop



# Zero-argument instructions
# --
	Dict
		.set(">","GT")
		.set("<","LT")
		.set(">=","GE")
		.set("<=","LE")
		.set("!=","NE")
		.set("==","EQ")
		.set("+","ADD")
		.set("-","SUB")
		.set("*","MUL")
		.set("-","DIV")
		.set("%","MOD")
		.set(":byte","TYPE_BYTE")
		.set(":int","TYPE_INT")
		.set(":?","TYPE_ANY")
		.set("&&","AND")
		.set("||","OR")
		.set("&","BIT_AND")
		.set("|","BIT_OR")
		.set("!","NOT")
		.set("dup","DUP")
		.set("swap","SWAP")
		.set("pop","POP")
/Instr


# PROGMEM compiled functions
# --
	self.data=Db2:Get(Sys.scriptId,"data",List)
	self.dict=Db2:Get(Sys.scriptId,"dict",Dict)

	self.add = Lambda{
		P(1) as String => name
		P(2) as List => code
		self.dict.set(name, self.data.length)
		self.data=self.data + code
		self.save
	}
	self.save = Lambda {
		Db2:Set(Sys.scriptId,"data",self.data)
		Db2:Set(Sys.scriptId,"dict",self.dict)
	}
	self.lookup = Lambda {
		P(1) as String => name
		if (self.dict.has(name), self.dict.get(name), null)
	}
	self.list = Lambda {
		self.dict.keys
	}
	self.clear = Lambda {
		self.data=List
		self.dict=Dict
		self.save
	}
/class CompiledFunctions
	

# Forth compiler
# --
	P(1,readLine("Enter code")) => line
	P(2,Output) => output
	
	Lib:Header(line)
	stack=Util:Stack   # context stack, for nested if's and loops
	
	instr=Instr
	
	localVariables=Dict
	compiledFunctions=CompiledFunctions
		
	line.split->part
		if (part=="if{") {
			stack.push(CtxCond(output))
		} else if (part=="loop{") {
			stack.push(CtxLoop(output))
		} else if (part=="}") {
			ctx=stack.pop
			error(ctx==null,"no current context: '}'")
			ctx.close
		} else if (part=="break") {
			ctx=stack.peek
			ctx as? &CtxLoop => isLoop
			if (isLoop) ctx.condBreak
		} else if (part.startsWith("=")) {
			name=part.sub(1)
			output.str("LWRITE " + name)
			pos=localVariables.keys.length
			localVariables.set(name,pos)
			output.op("LWRITE")
			output.bin(pos)
		} else {

			if (localVariables.has(part)) {
				output.str("LREAD " + part)
				output.op("LREAD")
				output.bin(localVariables.get(part))

			} else if (instr.has(part)) {
				opCode=instr.get(part)
				output.str(opCode)
				output.op(opCode)
			
			} else if (OpCodes.has(part)) {
				output.str(part)
				output.op(part)
				
			} else {
				if (part.?parseInt) {
					output.str("PUSH " + part)
					output.pushInt(part.parseInt)
				} else {
					pos=compiledFunctions.lookup(part)
					error(pos==null,"Unknown function: " + part)
					output.str("CALL " + part + " (pos=" + pos + ")")
					output.str("->PUSH " + pos)
					output.pushInt(pos)
					
					output.op("CALL")
				}
			}
		}	
	|
	output.str("EOF (end-of-function)")
	output.op("EOF")
	output		
/Compile	




# Enter and run code, optionally naming it a function
# --
	P(1,readLine("Enter code line")) => code
	
	Compile(code) => output
	output.show
	code=output.getBinary
	println("#bytes = " + code.length)
	
	readLine("Enter function name, ENTER to abort").trim => fname
	if (fname != "") {
		CompiledFunctions.add(fname,code)
	}
	
/run


# Show functions
# --
	CompiledFunctions.list
/list


# Fixed code line
# --
	code = "=b =a a b + 10 < if{ a b doSomething }"
	test(code)
/t1


# Fixed code line
# --
	code = "1 =i loop{ i 1 + dup =i 10 >= break }"
	test(code)
/t2

