# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


# Readme for script
<<< EOF

--------------------------------------------------
PowerShell utilities
--------------------------------------------------

>>> EOF
/Readme


# Run PowerShell command on remote host, such as "get-service -name *"
#
# To invoke a remote PowerShell script:  
#   ". c:\temp\myscript.ps1 ..."
# To invoke remote external program: 
#   "& git status"
# To invoke cmd features: 
#   "& cmd /c dir"
# --
P(1) =>host 
P(2,"get-service") =>code
P(3,List) => stdin
P(4,false) => acceptError
P(5,false) => verbose
    if (verbose) {
        println("[" + host + "] Executing " + code)
    }
    List("powershell","invoke-command","-computername",host,"-scriptblock","{" + code + "}") =>cmd
    Lib:run(cmd, stdin, acceptError)
/Call



# Run PowerShell command on remote host. Works like Call, but interactively
# --
P(1) =>host 
P(2,"get-service") =>code
    println("[" + host + "] Executing " + code)
    List("powershell","invoke-command","-computername",host,"-scriptblock","{" + code + "}") =>cmd
    Dir.run(cmd)
/CallInteractive



# Run a Powershell script on remote host
# The script is created locally and run remotely via Invoke-Command.
# --
	P(1, Input("Enter remote host").get) =>host 
	P(2, List("cd c:\temp","dir")) => scriptCode
	P(2, false) => asAdmin

	# The Invoke-Command can run command from local ps1-file on remote server!

	Lib:TmpFile("script","ps1") => ps1file
		# The script to be invoked must be named *.ps1
		
	ps1file.create("")
	if (asAdmin) {
		ps1file.append("start-process powershell -verb runas")
	}
	ps1file.append(scriptCode)
	List("powershell","Invoke-Command","-ComputerName",host,"-FilePath",ps1file.path) => cmd
	Lib:run(cmd,List,true) => result
	ps1file.delete
	result
/RunScriptRemote



P(1, Input("Enter remote host").get) =>host 
P(2, Input("Enter service").get) =>service
    CallInteractive(host,"stop-service " + service)
/StopService

P(1, Input("Enter remote host").get) =>host 
P(2, Input("Enter service").get) =>service
    CallInteractive(host,"start-service " + service)
/StartService



P(1, Input("Enter remote host").get) =>host 
P(2, Input("Enter service").get) =>service
    CallInteractive(host,"get-service " + service)
/GetService




# Simple remote shell to multiple windows hosts via PowerShell.
# --
P(1,Input("Shell Host").get) => host
if (Val("sh.dirs")==null) {
	ValDef("sh.dirs",Dict)
}
currDirs = Val("sh.dirs")  # default directories
loop
	println
	readLine("[" + host + " " + currDirs.get(host,"c:\temp") + "] '.q' to quit, '?' for help") => mode
	break(mode==".q")

	if (mode=="?") {
		Sequence(
			@ Enter multiple commands separated by semicolon or type
			@
			@ '.h'  - change host
			@ '.d'  - set directory manually
			@ '.e'  - edit file
			@ '.u X'- show file minus comments (starting with '#' or X if given)
			@ '.'   - enter or paste multiple lines - end with '.'
			@ '.q'  - quit
		)->line println(line)
	} else if (mode==".h") {
		knownHosts = currDirs.keys.sort
		Lib:Header("Known hosts")
		Inner{knownHosts->h println("  " + h) }
		println
		Input("Enter shell Host (ENTER to keep " + host + ")").get => x
		if (x.trim != "") {
			host = x
			currDirs.get(host,"c:\temp")
		}
	} else if (mode==".d")  {
		readLine("New current directory") => dir
		currDirs.set(host, dir)
	} else if (mode==".e") {
		dir = Dir("\\" + host + "\" + convertPath(currDirs.get(host,"c:\temp")))
		file = Util:SelectFile(dir)
		if (file != null) {
			Lib:e (file)
		}
	} else if (mode.startsWith(".u")) {
		dir = Dir("\\" + host + "\" + convertPath(currDirs.get(host,"c:\temp")))
		comment="#"
		if (mode.split.length==2) comment=mode.split.nth(1)

		file = Util:SelectFile(dir)
		if (file != null) {
			println("--------------")
			Inner{
				Util:UncommentFile (file, comment)->line println(line) 
			}
			println("--------------")
		}
	} else {
		if (mode==".") {
			println("Enter code lines, then '.' to send")
			scriptLines = readLines(".")
		} else {
			scriptLines=mode.split(";")
		}
		currDir = currDirs.get(host,"c:\temp")
		scriptLines = List("cd '" + currDir + "'") + scriptLines + Sequence(
			@ Write-Host "----------Output-Stops-Here----------"
			@ $xxxxxx=Get-Location
			@ Write-Host "RemotePath: $xxxxxx"
		)


		PS:RunScriptRemote(host,scriptLines) => status

		# Process stdout
		Inner { 
			marker=false
			status.stdout->line 
				if(line.contains("---------Output-Stops-Here---------")) {marker=true}
				if (!marker) println("    " + line)
				if (marker && line.startsWith("RemotePath:")) {
					currDirs.set(host, line.after(":").trim)
				}
		}	
		# Process stdout				
		Inner { status.stderr->line println("ERR " + line) }
	}
/sh


# Convert path c:\xxx to c$\xxx etc
# --
P(1)=>path
	error(path.chars.nth(1) != ":" || path.chars.nth(2) != "\", "Invalid path, must start with c:\... or similar")
	path.chars.nth + "$" + path.sub(2)
/convertPath



# Check if host1 can access TCP port on host2, true if connect ok, false if not
# Note: slow
# --
	P(1,Input("Host1").get) => host1
	P(2,Input("Host2").get) => host2
	P(3,27017) => port

	cmd = "Test-NetConnection -ComputerName " + host2 + " -InformationLevel Detailed -Port " + port
	PS:RunScriptRemote(host1, List(cmd)) => x
	connectOk = false
	Inner {
		x.stdout->line
			assert(line.contains("TcpTestSucceeded"))
			connectOk = line.contains("True")
	}
	connectOk
/VerifyTCPConnect
