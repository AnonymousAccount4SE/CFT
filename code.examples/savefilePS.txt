# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


# Readme for script
<<< EOF

--------------------------------------------------
PowerShell utilities
--------------------------------------------------

>>> EOF
/Readme


# Run PowerShell command on remote host, such as "get-service -name *"
#
# To invoke a remote PowerShell script:  
#   ". c:\temp\myscript.ps1 ..."
# To invoke remote external program: 
#   "& git status"
# To invoke cmd features: 
#   "& cmd /c dir"
# --
P(1) =>host 
P(2,"get-service") =>code
P(3,List) => stdin
P(4,false) => acceptError
    println("[" + host + "] Executing " + code)
    List("powershell","invoke-command","-computername",host,"-scriptblock","{" + code + "}") =>cmd
    Lib:run(cmd, stdin, acceptError)
/Call



# Run PowerShell command on remote host. Works like Call, but interactively
# --
P(1) =>host 
P(2,"get-service") =>code
    println("[" + host + "] Executing " + code)
    List("powershell","invoke-command","-computername",host,"-scriptblock","{" + code + "}") =>cmd
    Dir.run(cmd)
/CallInteractive



# Run a Powershell script on remote host
# --
	P(1, Input("Enter remote host").get) =>host 
	P(2, List("cd c:\temp","dir")) => scriptCode

	# The Invoke-Command can run command from local ps1-file on remote server!

	Dir("c:\temp").file("tmp"+currentTimeMillis+".ps1") => ps1file
		# The script to be invoked must be named *.ps1
	ps1file.create(scriptCode)
	List("powershell","Invoke-Command","-ComputerName",host,"-FilePath",ps1file.path) => cmd
	Lib:run(cmd,List,true) => result
	ps1file.delete
	result
/RunScriptRemote



P(1, Input("Enter remote host").get) =>host 
P(2, Input("Enter service").get) =>service
    CallInteractive(host,"stop-service " + service)
/StopService

P(1, Input("Enter remote host").get) =>host 
P(2, Input("Enter service").get) =>service
    CallInteractive(host,"start-service " + service)
/StartService



P(1, Input("Enter remote host").get) =>host 
P(2, Input("Enter service").get) =>service
    CallInteractive(host,"get-service " + service)
/GetService




# Primitive remote shell to multiple windows hosts via PowerShell
# --
P(1,Input("Shell Host").get) => host
if (Val("sh.dirs")==null) {
	ValDef("sh.dirs",Dict)
}
currDirs = Val("sh.dirs")  # default directories
loop
	println
	readLine("[" + host + " " + currDirs.get(host,"c:\temp") + "] '.q' to quit, '.?' for help") => mode
	break(mode==".q")

	if (mode==".?") {
		Sequence(
			@ Enter multiple commands separated by semicolon or type
			@
			@ '.h'  - change host
			@ '.d'  - set directory manually
			@ '.'   - enter or paste multiple lines - end with '.'
			@ '.q'  - quit
		)->line println(line)
	} else if (mode==".h") {
		Input("Shell Host").get => host
		currDirs.get("host","c:\temp")
	} else if (mode==".d")  {
		readLine("New current directory") => dir
		currDirs.set(host, dir)
	} else {
		if (mode==".") {
			println("Enter code lines, then '.' to send")
			scriptLines = readLines(".")
		} else {
			scriptLines=mode.split(";")
		}
		currDir = currDirs.get(host,"c:\temp")
		scriptLines = List("cd '" + currDir + "'") + scriptLines + Sequence(
			@ Write-Host "----------Output-Stops-Here----------"
			@ $xxxxxx=Get-Location
			@ Write-Host "RemotePath: $xxxxxx"
		)


		PS:RunScriptRemote(host,scriptLines) => status

		# Process stdout
		Inner { 
			marker=false
			status.stdout->line 
				if(line.contains("---------Output-Stops-Here---------")) {marker=true}
				if (!marker) println("    " + line)
				if (marker && line.startsWith("RemotePath:")) {
					currDirs.set(host, line.after(":").trim)
				}
		}	
		# Process stdout				
		Inner { status.stderr->line println("ERR " + line) }
	}
/sh




# Check if host1 can access TCP port on host2, true if connect ok, false if not
# Note: slow
# --
	P(1,Input("Host1").get) => host1
	P(2,Input("Host2").get) => host2
	P(3,27017) => port

	cmd = "Test-NetConnection -ComputerName " + host2 + " -InformationLevel Detailed -Port " + port
	PS:RunScriptRemote(host1, List(cmd)) => x
	connectOk = false
	Inner {
		x.stdout->line
			assert(line.contains("TcpTestSucceeded"))
			connectOk = line.contains("True")
	}
	connectOk
/VerifyTCPConnect
