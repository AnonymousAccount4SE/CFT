# Readme
# --
<<<< EOF
This script is for background jobs control, as started by
the '&' expression, which has the following syntax

& expr

or 

& expr, name

where name is an identifier or a string, to identify the process.

/StartHeavyTasks
>>>> EOF
->line println("| " + line)
/Readme


# Get all jobs
# --
	Inner {
		Sys.Jobs.namesCompleted->name out("COMPLETED " + name)
	} + Sys.Jobs.namesRunning
/AllJobs



# Get running job names
# --
	Sys.Jobs.namesRunning
/Running


# Return completed job names (for integration into prompt)
# --
	Sys.Jobs.namesCompleted
/Completed


# Get single result from first terminated process
# --
	completed = Sys.Jobs.namesCompleted
	error(completed.length==0, "No completed jobs")

	name=completed.first
	proc=Sys.Jobs.getCompleted(name)

	Lib:Header(name)
	output=proc.output
	if (output.length > 0) Inner {
		output->line println(line)
	} @rel

	Sys.Jobs.deleteCompleted(name)
	
	proc.exitValue
/Get


# Clear all completed jobs
# --
	Sys.Jobs.namesCompleted->name Sys.Jobs.deleteCompleted(name)
/Clear


# Select job to do interactive follow-up on
# --
	Lib:MenuSelect(Sys.Jobs.namesRunning,null,"Select job") => name
	println("Selected job: " + name)
	println("In the input loop below, enter .q to abort")

	result=null

	proc=Sys.Jobs.getRunning(name)
	error(proc==null,"No running process " + name)
	loop
		println("proc=" + proc)
		Inner { proc.output->line println(line) }
		if (proc.isDone) {
			println("(Job has terminated)")
			result=proc.exitValue
			Sys.Jobs.deleteCompleted(name)
			break
		}
		readLine => line
		break(line==".q")
		proc.sendLine(line)
	|
	result
/ManageProcess