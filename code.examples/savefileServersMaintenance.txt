# Readme
<<< EOF
------------------------------------------------
Collection of functions for querying and 
managing servers remotely via SSH. For scripts
to work, the remote server must

- allow ssh without password
- allow sudo without password

To do this, see the SSH script and its Readme
function.

A single main function run() handles all cases.
------------------------------------------------
>>> EOF
/Readme


Input("SSH target on format username@server").get
/ReadSSHTarget


Val("showDebug")
/showDebug


P(1)=debug
	ValDef("showDebug", debug)
/setDebug



P(1)=target	# Check if server fails to respond on ping
	if(target.contains("@"), target.after("@"), target) =host
	Dir.runCapture("ping","-c","1",host)->line assert(line.contains("0 received")) out(line) | _.length>0 =failure
	!failure
/HostOk


P(1)=target P(2)=singleCommand # Run single command via ssh command line, returns output lines (stderr to screen)
	Dir.runCapture("ssh",target,singleCommand) =lines
	when(showDebug,{
		println(" : " + singleCommand)
		lines->line println("   ## " + line)
	})
	# Return value
	lines
/RemoteCommand



P(1)=name Dir("/tmp").file(name + currentTimeMillis)  # Create temp file under /tmp
/TmpFile



P(1)=target P(2,List)=commands  # Multiple commands in single ssh session via stdin, returns stdout and stderr lines

	# ensure commands is a list
	when(!commands.?nth, {
		List(commands) =commands
	})

	when(showDebug, {
		println("target=" + target)
		commands->x println(" : " + x)
	})
	
	"------ Starting " + Sys.version + " ------" =marker
	
	# prefix commands with recognizable line
	'echo "' + marker + '"' =echo
	List(echo) + commands =cmd

	TmpFile("in") =inFile
	TmpFile("out") =outFile
	TmpFile("err") =errFile
	
	inFile.create(cmd)
	Dir.runProcessWait(inFile,outFile,errFile,"ssh",target)
	
	false =foundMarker
	outFile.read->line
		condOut(foundMarker,"(stdout) " + line)
		when(line.contains(marker), {true=foundMarker})
	| _=outLines
	
	List =errLines
	when (errFile.exists, {
		errFile.read->line out("(stderr) "+line) | _=errLines
	})

	outLines + errLines =outputLines
	
	{* P(1)=f when(f.exists, f.delete) } =Del
	
	Del.call(inFile)
	Del.call(outFile)
	Del.call(errFile)
	
	when(showDebug, {
		outputLines->line println("   ## " + line)
	})
	# return value
	outputLines
/RemoteCommandSet



P(1)=target P(2,List)=commands P(3,Dict)=codes # returns list of codes
	RemoteCommandSet(target, commands) =output
	List =result
	output->line 
		codes.keys->key
			when(line.contains(key), result.add(codes.get(key)))
	|
	# return value
	result.unique
/RemoteCommandSetCoded



P(1)=target P(2)=cmd P(3,null)=codes  ## 
	if (!cmd.?nth, List(cmd), cmd) =cmd  # now it's always a list
	if (codes != null,
		RemoteCommandSetCoded(target, cmd, codes)
		,
		RemoteCommandSet(target, cmd)
	)
/run


# Example on how to classify java support on remote server (interactive)
	ReadSSHTarget =target
	Dict
		# Maps output strings to result codes
		.set("not found","notfound")
		.set("OpenJDK","openjdk")
		.set('"11.0.', "v11")
		.set('"14.0.', "v14")
		=codes

	List("java -version")=commands
	
	call "ServersMaintenance:RemoteCommandSetCoded" (target, commands, codes) =result
	!result.contains("notfound") =hasJava
	println("Java status for " + target + " -> hasJava=" + hasJava + ", all codes = " + result.concat(" "))
/ExampleCodedResponse







