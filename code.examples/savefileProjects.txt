# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License




# Example projects.txt file
<<< EOF

Projects script
---------------
To use this script, create a file projects.txt
in the CFT home directory.

The ### marker is followed by a project name,
and identifies the settings for each project.

Single "#" at start of lines are comments.

Example:

projects.txt
---
### ActiveProjects

CFT

### CFT

Desc: CFT project

Dir: /home/xyz/CFT
Type: java
#Type: txt
IgnoreDir: build
IgnoreDir: ebuild 
IgnoreFile: .git 
---

There can be multiples of every line, including Dir.

>>> EOF
/Readme



# Set up screen dimensions
    Cfg.w(130) Cfg.h(25)
/Init

# projects.txt file contains all data
    (call "Lib:DirPrivate").file("projects.txt")=f
    error(!f.exists,"File " + f.path + " missing - run Readme() for details")
    DataFile(f,"###").comment("#")
/ProjectsFile

# List projects and select 
    Val("Project") =result
    ProjectsFile.get("ActiveProjects")->line out(line.trim) | _=names
    Lambda { P(1) } =showName
    loop
        println
        call "Lib:Header" ("Select project, curr=" + result)
        call "Lib:ShowOptions" (names, showName)
        call "Lib:SelectOptions" (names, showName, true) =resultList
        if(resultList.length>1, Inner{println("** not unique **") null=result} )
        if(resultList.length==1, Inner{resultList.nth =result} )
        break(result != null)
    |
    ValDef("Project", result)
/ChangeProject


if(Val("Project")==null, ChangeProject)
/CheckProject


# Read current project data into a Dict
    CheckProject
    Dict
        .set("Desc",List)
        .set("Dir",List)
        .set("Type",List)
        .set("IgnoreDir",List)
        .set("IgnoreFile",List)
        =dict

    Val("Project") =pName
    ProjectsFile.get(pName) =dataLines
    error(dataLines.length==0, "No data for project " + pName)

    dataLines->line
        line.before(":").trim =field
        line.after(":").trim =val
        dict.get(field,List).add(val)
    |
    dict
/CurrProject


# Produce list of files to search

    CheckProject
    CurrProject =pr

    Lambda { P(1)=d 
        true =keep 
        CurrProject.IgnoreDir->x 
            if(d.name==x,Inner{false =keep}) 
            break(!keep)
        |
        keep
    } =checkDir
    
    # Generate initial list of all directories in project
        pr.Dir->dirName 
            Dir(dirName)=startDir
            out(startDir)
            error(!startDir.exists, "Project dir " + dirName + " not found")
            startDir.allDirs->d out(d)
        | =allDirs
    
    # Filter out directories that don't pass checkDir macro call
        allDirs->d 
            assert(checkDir.call(d))
            out(d)
        | =allDirs

    # Identify files that have desired type
        allDirs->d
            d.files->f
                f.name.afterLast(".")=type
                assert(pr.Type.contains(type))
                out(f)
        | =allFiles

    # return value
    allFiles
/TextFiles






P(1,Grep)=grep
    CheckProject
    
    Lambda { P(1)=file 
        Val("FileFilter")=filter
        if(filter != null, file.name.contains(filter), true)
    } =filter

    # Count matches first
    TextFiles->tf 
        assert(filter.call(tf))
        out(grep.fileCount(tf)) 
    | _.sum =count
    # If too many hits, just cancel
    error(count>10000, "Search matches " + count + " lines - not shown")

    TextFiles->tf
        assert(filter.call(tf))
        grep.file(tf)->line 
            report(line.file.name, line.lineNumber, line)
/Search


# Limit search to file names containing a certain string
    readLine("Enter file filter string").trim=str
    if(str=="",null,str) =val
    ValDef("FileFilter",val)
/SetFileFilter


# Show info on current FileFilter (if defined)
    Val("FileFilter") =filter
    if(filter!=null, Inner{
        println
        println("** Filtering file names on: " + '"' + filter + '"')
        println
    })

/ShowFileFilter


# Clear current file filter
ValDef("FileFilter",null)
"File filter cleared"
/ClearFileFilter




# Search with one parameter
CheckProject
ShowFileFilter
Input("Search1").get =a
Search(Grep(a))
/S


# Search with two parameters
CheckProject
ShowFileFilter
Input("Search2a ... ").get =a
Input("... AND Search2b").get =b
Search(Grep.match(a).match(b))
/S2


# Search with three parameters
CheckProject
ShowFileFilter
Input("Search3a ... ").get=a
Input("... AND Search3b").get=b
Input("... AND Search3c").get=c
/S3

# Search with one positive and one negative parameter
CheckProject
ShowFileFilter
Input("Search1").get =a
Input("Search1n (reject)").get =b
Search(Grep(a).reject(b))
/SN

# Locate file by partial name
    P(1,"java")=fn
    CheckProject

    TextFiles->tf
        assert(tf.name.contains(fn))
        out(tf)
/FileLocator


# Display current project
    CheckProject
    
    CurrProject =pr
    println
    pr.Desc->d
        println("** " + d)
    |
    pr.Dir->d
        println("   " + d)
    |
    println("   " + pr.Type.concat(" "))
    println
    true
/Curr



# Interactive call to FileLocator, sorted presentation, newest first
    CheckProject
    
    Input("Enter part of file name").get =fn
    FileLocator(fn) =fileList
    fileList->file
        out(Int(file.lastModified, file))
    | _.sort->x 
        x.data =file 
        report(file.path, file.length, Date(file.lastModified).fmt)
    | =lines  # the report(...) outputs
    

    # Display report lines, and create line numbers
    0 =lineNo
    lines->line
        # Pad lineNo to 3 characters
        Inner{""+lineNo =s loop break(s.length>=3) " "+s =s | s} =lineNoStr
        
        println(lineNoStr + ": " + line)
        lineNo+1 =lineNo
    |
    println
    readLine("Enter number to edit, or blank to skip") =inp
    if(inp != "", Inner{
        call "Lib:e" (fileList.nth(inp.parseInt))
    })
    true
/FL

ChangeProject
/CP

TextFiles
/TF
