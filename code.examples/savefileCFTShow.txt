<<<<< TEXT
.h Intro

	# CFT: "ConfigTool"
	# Dev since May 2018, on git since 2020
	# GNU GPL 3.0 ("open source")
	# --


	# Script language

	# Shell



.h Unusual

	# - Function names follow code
	
	1+1
	/two

	# - Iteration with single arrow + out()

	List(1,2,3)->x out(x+10)

	# - PIPE ("|"): code spaces

	List(1,2,3)->x out(x+10) | _.sum

	# Function return values
	# - result from last code space

	# Code space result value
	# - if contains loops: list via out() or report()
	# - otherwise: top value from stack



.h Functions

	# - no classes
	# - no global state

	# - functions only
	# - system objects (~70)
	#    - int, String, List, Dir, File ...

	1+1
	/two

	two+two


	Dir.allFiles(Glob("*.java"))
	/JavaFiles

	JavaFiles.length
	/CountJavaFiles




.h Help

	# Interactive help

	help

	File("x") help

	List help

	3 help

	"" help

	

.h Loops

	# Iterate over content
	# Filter and modify

	Dir.files->f assert(f.name.endsWith(".txt")) out(f)
	/txtFiles

	Dir.files->f assert(f.lastModified > currentTimeMillis-86400*1000) out(f)
	/recentFiles

	help
	File("x") help




.h Iteration

	## Foreach loop: <stack value> -> ident

	List(1,2,3)->x out("a"+x)
	Dir.files->f out(f.path)
	Dir.files->f report(f.name, f.length)

	## Filtering

	Dir.files->f assert(f.name.endsWith(".md")) out(f)
	Dir.files->f assert(f.name.endsWith(".txt")) out(f)

	# or just 

	ls *.txt

	## Pipes

	Dir.allFiles("*.java")->f out(f.read.length) | _.sum



.h Search

	# Projects = Script for searching
	# Multiple projects, fast switching
	# --

	@
	@P

	?
	ch

	S
	FL

	EditConfig



.h Shell

	ls, lsd, lsf

	cat, more, edit

	ls
	:N
	edit/cat/more

	@fm

	@S
	@FL

	!dir
	shell



.h Templates

	:save Demo
	@e
	
	# Create notification
	# --
		P(1,"MyCollection") => collection
		P(2,readLine("Field"))=>field
		P(3,readLine("Value")) => value

		Sequence(
			@ printjson(
			@   db.<<collection>>.find(
			@     {"<<field>>": "<<value>>"}
			@   ).count()
			@ )
		).mergeExpr
	/MongoCount




>>>>> TEXT
//text



# Process line
# --
	P(1) => line
	P(2) => first
	if (line.startsWith(".h")) {
		if (!first) {
			readLine("Enter")
		}
		println(Curses:Clear)
		Inner {
			Letters7x5:GetText(line.sub(2).trim.toUpper)->line println(Curses:TxtGreen + line + Curses:Reset)
			|
			println
		}
	} else {
		println(line)
		Sys.sleep(10)
	}
//ProcessLine


# Show text
# --
	P(1,List) => lines
	first=true
	lines->line 
		ProcessLine(line, first)
		first=false
	|
	"Done"
//Show



# Show text
# --
	Show(text)
/t



