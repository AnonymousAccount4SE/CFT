# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2022 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

<<<<< TEXT
.h CFT

	Dev since May 2018, on git since 2020
    GNU GPL 3.0 ("open source")

	https://github.com/rfo909/CFT

    - Script language
	- Shell

	Written in Java
	"Functional"

	git clone https://github.com/rfo909/CFT.git
	cd CFT
	mvn package
	.\cft


.h FUNCTIONS

	1+1
	/two

	two

	two+two
	/four

	Dir.files.length
	/x

	cd ..
	x

	:save Test

	@e

	3.14
	/pi

	?


.h HELP

	# List functions in current script
	?

	# Show function code
	?two

	# Global functions
	help

	# Object functions
	Dir help
	Dir.files help
	Dir.files.first help

	# Expressions and statements
	_Expr
	_Stmt

	# List colon commands and shortcuts
	:
	@

	# List scripts
	@scr

	# Show details of another script
	?Lib:
	?Lib:TmpDir


.h Loops

    # Iterate over content, filter or modify

	List(1,2,3)->x out(x+10)

	# Count number of lines of java
	# --
		Dir.allFiles("*.java")->f out(f.read.length) | _.sum
	/javaLines


.h List / Dict

	List(1,2,3)
	"abcd".chars
	Dir.dirs
	Dir.files.first.read
	
	Dict.set("a",1).set("b",2)
	
	Dict.a=1 _.b=2 _.c=3
	/x

	Util:ShowDict(x)



.h FUNC PARAMS

	# Simple example
	# --
		a = P(1)
		b = P(2)
		a+b
	/sum

	# Defaults
	# --
		a = P(1,readLine("Value a").parseInt)
		b = P(2,readLine("Value b").parseInt)
		a+b
	/sum


	--- local variables

	a = 5
	5 => a



.h Shell

    ls, lsd, lsf

    cat, more, edit

    ls
    :N
    edit/cat/more

    @fm

    @S
    @FL

    !dir
    shell



.h Search

    # Projects = Script for searching
    # Multiple projects, fast switching
    # --

    @
    @P

    ?
    ch

    S
    FL

    EditConfig





.h Ext. programs

	Dir.run("cmd","/c","git","status")
	Dir.run("powershell","git","status")

	Lib:run(List("powershell","ls")
	/x

	Util:ShowDict(x)
	x.stdin
	x.stdout
	x.exitCode



.h Templates

	# Template demo
	# --
		a=1
		b=2

		<<< EOF
		this
		is
		a
		test
		a=<<a>>
		b=<<b>>
		>>> EOF
			.mergeExpr
	/t1


.h Templates 2

	# Template demo 2
	# --
		P(1)=>name
		lines = Sequence(
			@ this is
			@ a test
		) + CondSequence(name != null,
			@ name=<<name>>
		) + CondSequence(name==null,
			@ (no name)
		) + Sequence(
			@ --
			@ Footer
		)

		lines.mergeExpr
	/t2




.h Lambda

	# Select file
	# --
		labelLookup=Lambda{
			P(1) as File => file
			file.name
		}
		Lib:MenuSelect(Dir.files, labelLookup)
	/selectFile



.h Closures

	# Dictionary + lambda = closure
	# --
		Dict
		.set("count",0)
		.set("add",Lambda{
			self.count=self.count+1 
			self
		})
	/counter


	counter.add.add.count

	# Can pass the closure to another function
	# --
		x=counter
		someFunction(x.get("add")) 
		println("Called " + x.count + " times")
	/test

	


.h Classes

	# Simple class
	# --
		P(1) => name
		self.name=name
		self.present=Lambda{
			"my name is " + self.name
		}
	/class Test


	# Sub-class
	# --
		P(1)=>name
		P(2)=>age
		self.copyFrom(Test(name))
		self.age=age
		self.presentAge=Lambda{
			"the age is " + self.age
		}
	/class Sub




>>>>> TEXT
//text

# Process line
# --
    P(1) => line
    P(2) => first
	
    if (line.startsWith(".h")) {
        if (!first) {
            readLine("Enter")
        }
        println(Curses:Clear)
        Inner {
            Letters7x5:GetText(line.sub(2).trim.toUpper)->line 
				str=line #.replace("#","O")
				println(Curses:TxtGreen + str + Curses:Reset)
            |
            println
        }
    } else {
        println(line)
        #Sys.sleep(10)
    }
//ProcessLine


# Show text
# --
    P(1,List) => lines
    first=true
    lines->line 
        ProcessLine(line, first)
        first=false
    |
    "Done"
//Show



# Show text
# --
    Show(text)
/t



