# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2022 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

<<<<< TEXT
.h CFT

	Dev since May 2018, on git since 2020
    GNU GPL 3.0 ("open source")

	https://github.com/rfo909/CFT

    - Script language
	- Shell

	git clone https://github.com/rfo909/CFT.git
	cd CFT
	mvn package
	.\cft


.h FUNCTIONS

	1+1
	/two

	Dir.files.length
	/x

	cd ..
	x

	:save Test

	@e

	3.14
	/pi

	# Parameters (with default expr)
	# --
		a=P(1,Input("Enter a").parseInt)
		b=P(2,Input("Enter b").parseInt)
		a+b
	/sum

	?


.h HELP

	# List functions in current script
	?

	# Show function code
	?sum

	# Global functions
	help

	# Object functions
	Dir help
	Dir.files help
	Dir.files.first help

	# Expressions and statements
	_Expr
	_Stmt

	# List colon commands and shortcuts
	:
	@

	# List scripts
	@scr

	# Show details of another script
	?Lib:
	?Lib:TmpDir


.h Loops

    # Iterate over content, filter or modify

	List(1,2,3)->x out(x+10)

	# Count number of lines of java
	# --
		Dir.allFiles("*.java")->f out(f.read.length) | _.sum
	/javaLines


.h Shell

    ls, lsd, lsf

    cat, more, edit

    ls
    :N
    edit/cat/more

    @fm

    @S
    @FL

    !dir
    shell



.h Search

    # Projects = Script for searching
    # Multiple projects, fast switching
    # --

    @
    @P

    ?
    ch

    S
    FL

    EditConfig



.h Templates

	# Get IP address of windows host
	# --
		ip=null
		File("/etc/resolv.conf").read->line
			assert(line.startsWith("nameserver")) 
			ip=line.split.last
			break
		|
		error(ip==null,"No ip-address found")
		ip
	/GetIP

	# Create temporary shell script
	# --
		Sequence(
			@ #!/bin/bash
			@
			@ export DISPLAY=<<GetIP>>:0.0
			@ export LIBGL_ALWAYS_INDIRECT=1
			@ xterm &
			@ lxterminal &
			@ nautilus &
		).mergeExpr => code

		scriptFile=Lib:TmpFile("RunX","sh")
		scriptFile.create(code)

		Dir.run("chmod","+x",scriptFile.path)
		Dir.run(scriptFile.path)
		scriptFile.delete
	/Run


.h Lambda

	# Select file
	# --
		getLabel=Lambda{
			P(1) as File => file
			file.name
		}
		Lib:MenuSelect(Dir.files, getLabel)
	/selectFile

	

.h Closures

	# Dictionaries
	# --

	Dict .set("a",1) .set("b",2)

	Dict.a=1 _.b=2

	# Lambda stored in Dict becomes a closure
	# --
		Dict
		_.count=0
		_.add=Lambda{
			self.count=self.count+1 
			self
		}
	/counter

	counter.add.add.count
	Util:ShowDict(counter)

	# Can pass the closure to another function
	# --
		x=counter
		someFunction(x.get("add"))  ## x.add would call it 
		println("Called " + x.count + " times")
	/test

	

.h Classes

	# Simple class
	# --
		P(1) => name
		self.name=name
		self.showName=Lambda{
			"Name: " + self.name
		}
	/class Test


	Test("x").showName




>>>>> TEXT
//text

# Process line
# --
    P(1) => line
    P(2) => first
	
    if (line.startsWith(".h")) {
        if (!first) {
            readLine("Enter")
        }
        println(Curses:Clear)
        Inner {
            Letters7x5:GetText(line.sub(2).trim.toUpper)->line 
				str=line #.replace("#","O")
				println(Curses:TxtGreen + str + Curses:Reset)
            |
            println
        }
    } else {
        println(line)
        #Sys.sleep(10)
    }
//ProcessLine


# Show text
# --
    P(1,List) => lines
    first=true
    lines->line 
        ProcessLine(line, first)
        first=false
    |
    "Done"
//Show



# Show text
# --
    Show(text)
/t



