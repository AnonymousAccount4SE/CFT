# Readme
<<<<<<<<<<<<<<<< EOF
Script testing

2021-11-12 RFO
>>>>>>>>>>>>>>>> EOF
/Readme



# Run all TestX
# --
	Sys.functions.sort->f
		assert(f.startsWith("Test"))
		report(f,eval(f))
/RunAll









# Call Util:Counter() 
# --
	P(1,10)=>numCalls
	loop
		break(numCalls<0)
		numCalls=numCalls-1
		println("Got: " + Util:Counter("test"))
		
//t01_GetCounters

# Create separate threads, each calling GetCounters()
# The idea is that we check that each counter value is obtained
# only once!
#
# Note: needed to add "named lock" for transaction inside Util:Counter,
# which consists of a read and a write.  
# --
	P(1,20)=>numThreads
	i=0
	loop
		break(i>=numThreads)
		i=i+1
		out(SpawnProcess(SymDict(i),t01_GetCounters))
	| -> proc
		proc.wait
		proc.output->line out(line)
	| => allLines
	
	# result
	allLines.length == allLines.unique.length
/Test01_Verifying_Util_Counter_Threaded_test
	 
	 
	 
	 
	 
# Threads test 2
#   Let different threads try and obtain a lock, then verify that the
#   lock file contains different keys. Note creative use of obtainLock()
#   timeout, to ensure single calls to get lock per thread. 
#
# The first thread becomes owner of lock, the remaining will fail, but
# the test is about collecting the lockId's that are written to the
# lock file, one by each thread, verifying they are unique.   
# --
	LOCK="Tests04.Test02"
	
	Lib.Db.getLockFile(LOCK) => f
	if (f.exists) f.delete
	
	# Run 10 threads, but wait for each. Using timeout -1 to ensure
	# only a single attempt at obtaining the lock.
	
	Lib.Data.each(1,10)->i
		SpawnProcess(SymDict(LOCK),Lib.Db.obtainLock(LOCK,-1)).wait
		
	|
	
	# Read the attempts at obtaining the lock as lines from the lock file
	f.read => allLines
	
	# Delete lock file
	f.delete
	
	# result
	allLines.length == allLines.unique.length
/Test02_Verify_Threads_Get_Unique_LockFile_lockIds

		

