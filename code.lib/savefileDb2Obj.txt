# Readme
<<< EOF
Simple object oriented extension of the Db2 script.

Objects are stored and identified via UUID's.
Objects can be updated and deleted (set to null)
Objects can be sorted on date of last update, and located using a lambda.
>>> EOF
/Readme


"Obj."
/CollectionPrefix


# Get collections
# --
	Db2:Collections->name
		assert(name.startsWith(CollectionPrefix))
		out(name.sub(CollectionPrefix.length))
/Collections


# Input collection name
# --
	println("Known Object collections")
	Collections->name
		println("   "+name)
	|
	Input("Enter collection").get
/inputCollection
		


# Modify collection names 
# --
	P(1) => collection
	prefix=CollectionPrefix
	if (!collection.startsWith(prefix)) collection=prefix+collection
	collection
/FixCN



# Store some value wrapped inside a Dict with id and date + value - returns new Dict
# --
	P(1)=>collection
	P(2)=>value
	error(value != null && getType(value) != "Dict","Value must be Dict")
	
	uuid=Lib.Db.UUID
	data=Dict.set("id",uuid).set("date",Date).set("value",value)
	Db2:Set(FixCN(collection), uuid, data)
	data
/AddObject



# Get object by UUID
# --
	P(1)=>collection
	P(2)=>uuid
	Db2:Get(FixCN(collection),uuid)
/Get



# Overwrite object by uuid
# --
	P(1)=>collection
	P(2)=>uuid
	P(3)=>value
	error(value != null && getType(value) != "Dict","Value must be Dict")

	data=Dict.set("id",uuid).set("date",Date).set("value",value)
	Db2:Set(FixCN(collection),uuid,data)
/UpdateObject



# Delete object by uuid
# --
	P(1)=>collection
	P(2)=>uuid
	UpdateObject(collection, uuid, null)
/DeleteObject



# Find objects that satisfy given lambda
# --
	P(1)=>collection
	P(2,Lambda{P(1) true})=>lambdaCheck  # (value)->boolean
	Db2:Keys(FixCN(collection))->key
		obj=Db2:Get(FixCN(collection),key)
		assert(obj.value != null)
		assert(lambdaCheck.call(obj))
		out(obj)
/FindObjects



# Find objects where a given field has a certain (string) value
# --
	P(1,inputCollection)=>collection
	P(2,readLine("field"))=>field
	P(3,readLine("value (glob)"))=>value
	
	Glob(value,false).regex => regex
	
	
	
	# Creating an object, so the lambda has access to state (field and value via self)
	Dict
		.set("field",field)
		.set("regex",regex)
		.set("check", Lambda {
			P(1)=>obj
			obj.value.has(self.field) && self.regex.match(""+obj.value.get(self.field))
		})
		=> obj
	FindObjects(collection, obj.check)->x
		report(x.value.getMany(x.value.keys.sort))
/SimpleFind


# Get collection objects sorted by date
# --
	P(1,inputCollection)=>collection
	Db2:Keys(FixCN(collection))->key
		obj=Db2:Get(FixCN(collection),key)
		assert(obj.value != null)
		out(Int(obj.date.get,obj))
	| _.sort->x out(x.data)
/SortedObjectsByDate

	
	
# Show objects sorted by last update
# --
	P(1,inputCollection)=>collection
	SortedObjectsByDate(FixCN(collection))->obj
		report(obj.id, obj.date, obj.value)
/ShowObjects


# Interactive reporting function: Show object fields, sorted by last update
# --
	P(1,inputCollection)=>collection
	P(2,Input("Fields").get.split)=>fields
	
	SortedObjectsByDate(FixCN(collection))->obj
		data = List(obj.date) + obj.value.getMany(fields) 
		report(data)
/ShowFields



# Example use for FindObjects - find values in Object collections that are not objects
# at all, and delete them (should not happen)
# --
	Collections -> collection
		Lfilter = Lambda {
			P(1) => obj 
			getType(obj.value) != "Dict"
		}
		FindObjects(FixCN(collection), Lfilter) -> obj
			println("Deleting value " + getType(obj.value))
			DeleteObject(collection, obj.id)
/DeleteNonObjects


# Create some test data
# --
Dir.files -> f
	println(f.name)
	Dict
		.set("type","test")
		.set("name",f.name)
		.set("path",f.path)
		.set("size",f.length)
		=> data
	AddObject("test", data)
/CreateTestData
		

# Delete test data
# --
	collection="test"
	Lfilter=Lambda{P(1).value.type=="test"}
	FindObjects(collection,Lfilter) -> obj
		DeleteObject(collection, obj.id)
/DeleteTestData

