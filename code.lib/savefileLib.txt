# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


# Readme for script
<<< EOF

--------------------------------------------------
OS independent editor functionality

To edit a file: call "Lib:e" (File)
To page a file: call "Lib:m" (File)

For windows runs notepad, for Linux there is
choice. 
 
--------------------------------------------------

>>> EOF
/Readme


# Edit file
	P(1,Sys.savefile)=file
	EditHistoryAdd(file)
	if(Sys.isWindows, Dir.runDetach("cmd","/c","notepad",file.path), ShowLinuxEditor(file))
/e


# Edit file from history
EditFileFromHistory
/e2


# Page through file
	P(1,Sys.savefile)=file
	if(Sys.isWindows,
		Dir.run("cmd", "/c", "more", file.path),
		Dir.run("more", file.path)
	)
/m



# Update Cfg with terminal size (if possible)
	false =updated
	if (!Sys.isWindows,{
		# Linux
		Dir.runCapture("which","stty").nth.contains("/stty") =hasStty
		when(hasStty, {
			Dir.runCapture("stty","size").nth.split =list
			#debug("list=" + list)
			Cfg.h(list.nth(0).parseInt)
			Cfg.w(list.nth(1).parseInt)
			true =updated
		})
	},{
		# Windows (a bit slow)
		Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Width").nth.parseInt =w
		Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Height").nth.parseInt =h
		Cfg.w(w)
		Cfg.h(h)
		true =updated
	})
	if(updated, Cfg, null)
/GetTerminalSize
			


# Add to edit-history
	P(1)=file
	EditHistory.add(file) =list
	File(".editHistory").create(syn(list))
/EditHistoryAdd

# Get edit-history 
	# Get from file if exists
	File(".editHistory") =f
	List =list
	when (f.exists && f.read.length==1, {
		eval(f.read.nth) =list
		when(list==null, {List =list})
	}) 
	
	# Validate files exist, then remove duplicates
	list->f assert(f.exists) out(f) | _->f out(Str(f.path,f)) | _.unique->x out(x.data) | _=newList

	# Trim list down to N newest entries
	loop
		break(newList.length <= 20)
		newList.remove(0)
	|	
	# Update file
	File(".editHistory").create(syn(newList))
	newList
/EditHistory


# Show edit history, and select one to edit, or cancel (called from e2())
	EditHistory =data
	{* P(1).path } =macroGetElementName
	Header("Enter part of file name to edit")

	loop
		ShowOptions(data, macroGetElementName)
		println("")
		println("(Press enter to cancel)")
		SelectOptions(data, macroGetElementName, true) =result
		when(result.length==1, e(result.nth))
		break(result.length==1) # just started editor
		break(result.length==0) # User pressed Enter
		println("Not unique")
/EditFileFromHistory





# Select Linux editor and remember selection for next time, open file in editor
# --
 	P(1,Sys.savefile) =file
	List(
		Dict.set("label","sublime")
		    .set("action", {* P(1)=file Dir.runDetach("subl",file.path) }),
		Dict.set("label","gedit")
		    .set("action", {* P(1)=file Dir.runDetach("gedit",file.path) }),
		Dict.set("label","leafpad")
		    .set("action", {* P(1)=file Dir.runDetach("leafpad",file.path) }),
		Dict.set("label","nano")
		    .set("action", {* P(1)=file Dir.run("nano", file.path) })
	) =linuxEditors

	when (Val("linuxEditor")==null,{
		MenuSelect(linuxEditors, {* P(1).get("label")},"Select editor") =ed
		ValDef("linuxEditor", ed)
	})

	Val("linuxEditor").get("action").call(file)
/ShowLinuxEditor



# Clear selected Linux editor
	ValDef("linuxEditor",null)
/Clear




# Show a list of options
	P(1,List)=options
	P(2,{* "name"})=macroGetElementName
		options->x
		    println("- " + macroGetElementName.call(x))
/ShowOptions



# Select zero or more from list of options
# --
	P(1,List)=options
	P(2,{* "name"})=macroGetElementName
	P(3,false)=emptyMeansNone
		readLine("Enter exact or part of value?").trim =sel
		if (emptyMeansNone && sel=="", {
			# empty list
			List =result
		}, {
			# Look for exact match first, then if no hits, partial
			options->opt
				assert(macroGetElementName.call(opt)==sel)
				out(opt)
			| =result
			when (result.empty, {
				options->opt
					assert(macroGetElementName.call(opt).contains(sel))
					out(opt)
				| =result
			})
		})
		result
/SelectOptions



# Display text with line under
	P(1,"Title") =title
	println
	println(title)
	println( Lib.Data.yes(title.length,"-").concat )
/Header




P(1,List) =options P(2,{* "name"}) =macroGetElementName P(3) =title 
#
	null =selectedElement
	loop
		println("")
		if (title != null, Header(title), 0)

		ShowOptions(options, macroGetElementName)
		println("")
		SelectOptions(options, macroGetElementName) =result
		
		when (result.length==1, { result.nth =selectedElement})
		break(selectedElement != null)
		println("** No match or not unique")
	| selectedElement
/MenuSelect



P(1,"label")=label P(2)=currVal
    println("")
    (label + if(currVal," ["+currVal+"]","") + " : ") =prompt
    readLine(prompt) =line
    if (line.trim=="", currVal, line)
/ReadValue




P(1,"label")=label P(2)=currVal
	null =gotResult
	loop
		ReadValue(label,""+currVal) =val
		when (val.?parseInt,{val.parseInt =gotResult})
		break(gotResult != null)
		println("** Integer required")
	|
	gotResult
/ReadValueInt




P(1,"label")=label P(2)=currVal P(3,"yes")=trueVal P(4,"no")=falseVal
	null =gotResult
	loop
		if (currVal != null, if(currVal, trueVal, falseVal), null) =currStrVal
		ReadValue(label,currStrVal) =val
		when (val==trueVal, {true =gotResult})
		when (val==falseVal, {false =gotResult})
		break(gotResult != null)
		println("** Please enter '" + trueVal + "' or '"  + falseVal + "'")
	|
	gotResult
/ReadValueBoolean



