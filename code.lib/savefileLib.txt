# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


# Readme for script
<<< EOF

--------------------------------------------------
OS independent editor functionality

To edit a file: Lib:e (File)
To page a file: Lib:m (File)

For windows runs notepad, for Linux there is
choice. 
 
--------------------------------------------------

>>> EOF
/Readme


# Edit file
    P(1,Sys.savefile) =>file
    if(Sys.isWindows)
        Dir.runDetach("cmd","/c","notepad",file.path)
    else
        ShowLinuxEditor(file)
/e



# Page through file
    P(1,Sys.savefile) =>file
    if(Sys.isWindows)
        Dir.run("cmd", "/c", "more", file.path)
    else
        Dir.run("more", file.path)
/m


# Update Cfg with terminal size (if possible)
    false =>updated
    if(!Sys.isWindows) {
        # Linux
        Dir.runCapture("which","stty").nth.contains("/stty") =>hasStty
        if(hasStty, Inner{
            Dir.runCapture("stty","size").nth.split =>list
            #debug("list=" + list)
            Cfg.h(list.nth(0).parseInt)
            Cfg.w(list.nth(1).parseInt)
            true =>updated
        })
    } else {
        # Windows (a bit slow)
        Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Width").nth.parseInt =>w
        Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Height").nth.parseInt =>h
        Cfg.w(w)
        Cfg.h(h)
        true =>updated
    }
    if(updated, Cfg, null)
/GetTerminalSize
            


# Select Linux editor and remember selection for next time, open file in editor
# --
  P(1,Sys.savefile) =>file
    List(
        Dict.set("label","sublime")
            .set("action", Lambda { P(1)=>file Dir.runDetach("subl",file.path) }),
        Dict.set("label","gedit")
            .set("action", Lambda { P(1)=>file Dir.runDetach("gedit",file.path) }),
        Dict.set("label","leafpad")
            .set("action", Lambda { P(1)=>file Dir.runDetach("leafpad",file.path) }),
        Dict.set("label","nano")
            .set("action", Lambda { P(1)=>file Dir.run("nano", file.path) }),
        Dict.set("label","micro")
            .set("action", Lambda { P(1)=>file Dir.run("micro", file.path) })
    ) =>linuxEditors

    if(Val("linuxEditor")==null) {
        MenuSelect(linuxEditors, Lambda { P(1).get("label")},"Select editor") =>ed
        ValDef("linuxEditor", ed)
    }

    Val("linuxEditor").get("action").call(file)
/ShowLinuxEditor



# Clear selected Linux editor
    ValDef("linuxEditor",null)
    "Linux editor selection cleared"
/ClearEditor



Sys.homeDir.sub("private") =>d
if(!d.exists) d.create
d
/DirPrivate


# Create name of temp file under /tmp or under c:\temp if windows
P(1,"tmp") =>name 
    if (Sys.isWindows,
	Dir("c:\temp").file(name+currentTimeMillis),
    	Dir("/tmp").file(name + currentTimeMillis) )
/TmpFile


# Create temporary directory - remember to delete it when done
P(1,"tmp") => name
	if (Sys.isWindows,
		Dir("c:\temp\"+name+currentTimeMillis),
		Dir("/tmp/"+name+currentTimeMillis)
	) =>d
	if (!d.exists) {
		d.create
	}
	d
/TmpDir


# Copy directory tree. Both fromDir and toDir must exist
# --
P(1) => fromDir
P(2) => toDir
P(3,false) => verbose
	error(!fromDir.exists, "Invalid fromDir: " + fromDir.path)
	error(!toDir.exists, "Invalid toDir: " + toDir.path)
	error(fromDir.path==toDir.path, "fromDir == toDir")

	fromDir.files->f 
		if(verbose) {
			println("FROM: " + f.path) 
			println("TO  : " + toDir.path)
		}
		toDir.copy(f) 
	|
	fromDir.dirs->d 
		toDir.sub(d.name) => d2
		if(!d2.exists) d2.create
		copyDirTree(d,d2,verbose)
	|
/copyDirTree


# Delete directory tree, asks for interactive confirm
# Leaves root directory
# --
P(1)=>xdir
	Sequence(
		@
		@ ------------------------------------------
		@     Deleting directory tree confirm
		@ ------------------------------------------
		@
		xdir.path
		@
		@ ------------------------------------------
		@
	)->x println(x) |
	readLine("Are you really SURE? Type 'Yes'")=="Yes" =>ok
	error(!ok,"Aborting")
	
	xdir.allFiles->f f.delete |
	xdir.allDirs->d d.delete |
/DelTree



# Run external program and collect stdout, stderr and exitCode - returns intermediate Dict
# representing the running process, with a member closure called "wait", which in turn
# delivers a result Dict with the following fields:
# 		cmd, stdin, stdout, stderr, exitCode
#
# Run external program in background.
#
# Example of use:
#     runProcess(...)  => a
#     runProcess(...)  => b
#     a.wait.call => aResult
#     b.wait.call => bResult
# --
P(1,List("ls","-l")) => cmd
P(2,List) => stdinLines
P(3,false) => acceptErrors
P(4,false) => showDebug

    if (getType(cmd) != "List") {
        cmd=List(cmd) # wrap as list
    }
    if (getType(stdinLines) != "List") {
        stdinLines=List(stdinLines) # wrap as List
    }
    
    Lib:TmpFile("in") =>inFile
    Lib:TmpFile("out") =>outFile
    Lib:TmpFile("err") =>errFile
    
    inFile.create(stdinLines)
    process = Dir.runProcess(inFile,outFile,errFile,cmd)
    Dict
        .set("cmd", cmd)
        .set("acceptErrors", acceptErrors)
        .set("showDebug", showDebug)
        .set("stdin", inFile)
        .set("stdout", outFile)
        .set("stderr", errFile)
        .set("process", process)
        .set("isCompleted", Lambda {
        	!self.process.isAlive
        })
        .set("wait", Lambda{
        	loop 
        		break(!self.process.isAlive) 
        		Sys.sleep(5) 
        	|
        	result = Dict
        		.set("cmd", self.cmd)
        		.set("stdin", self.stdin.read)
        		.set("stdout", if(self.stdout.exists, self.stdout.read, List))
        		.set("stderr", if(self.stderr.exists, self.stderr.read, List))
        		.set("exitCode", self.process.exitCode)

        	Del = Lambda  {P(1)=>f if(f.exists) f.delete}
        	Del.call(self.stdin)
        	Del.call(self.stdout)
        	Del.call(self.stderr)
        	
    	    FAIL = false
		    if (result.exitCode != 0 && !self.acceptErrors) {
		        FAIL = true
		    }

		    if(self.showDebug || FAIL) {
		        Inner {  # "hide" loops inside inner block, so as not to affect return value of function
		            println("- cmd:")
		            result.get("cmd")->line println("    " + line) |

		            println("- exitCode = " + result.get("exitCode"))

		            println("- stdin:")
		            result.get("stdin")->line println("   # " + line) |

		            println("- stdout:")
		            result.get("stdout")->line println("   # " + line) |

		            println("- stderr:")
		            result.get("stderr")->line println("   # " + line) |
		            println
		        }
		    }
		    
		    error(FAIL,"run failed with error")
		    
		    # return value
		    result

        })  # Lambda "wait"
    =>result
    
    result

/runProcess


# Run external program and collect stdout, stderr and exitCode - returns Dict
# with fields cmd, stdin, stdout, stderr, exitCode
# --
P(1,List("ls","-l")) => cmd
P(2,List) => stdinLines
P(3,false) => acceptErrors
P(4,false) => showDebug

	runProcess (cmd,stdinLines,acceptErrors,showDebug) => processDict
	
	# return value
	processDict.wait.call

/run






# Show a list of options
    P(1,List) =>options
    P(2,Lambda { "name"}) =>macroGetElementName
        options->x
            println("- " + macroGetElementName.call(x))
/ShowOptions



# Select zero or more from list of options
# --
    P(1,List) =>options
    P(2,Lambda { "name"}) =>macroGetElementName
    P(3,false) =>emptyMeansNone
        sel=readLine("Enter exact or part of value?").trim
        if(emptyMeansNone && sel=="") {
            # empty list
            result=List
        } else Inner{
            # Look for exact match first, then if no hits, partial
            options->opt
                assert(macroGetElementName.call(opt)==sel)
                out(opt)
            | =>result
            if(result.empty) Inner{
                options->opt
                    assert(macroGetElementName.call(opt).contains(sel))
                    out(opt)
                | =>result
            }
        }
        result
/SelectOptions



# Display text with line under
    P(1,"Title") =>title
    println
    println(title)
    println( Lib.Data.yes(title.length,"-").concat )
/Header




P(1,List) =>options P(2,Lambda { "name"}) =>macroGetElementName P(3) =>title 
#
    null =>selectedElement
    loop
        println("")
        if(title != null, Header(title), 0)

        ShowOptions(options, macroGetElementName)
        println("")
        SelectOptions(options, macroGetElementName) =>result
        
        if(result.length==1, Inner{ result.nth =>selectedElement})
        break(selectedElement != null)
        println("** No match or not unique")
    | selectedElement
/MenuSelect



P(1,"label") =>label P(2) =>currVal
    println("")
    (label + if(currVal," ["+currVal+"]","") + " : ") =>prompt
    readLine(prompt) =>line
    if(line.trim=="", currVal, line)
/ReadValue




P(1,"label") =>label P(2) =>currVal
    null =>gotResult
    loop
        ReadValue(label,""+currVal) =>val
        if(val.?parseInt) {val.parseInt =>gotResult}
        break(gotResult != null)
        println("** Integer required")
    |
    gotResult
/ReadValueInt




P(1,"label") =>label P(2) =>currVal P(3,"yes") =>trueVal P(4,"no") =>falseVal
    null =>gotResult
    loop
        if(currVal != null, if(currVal, trueVal, falseVal), null) =>currStrVal
        ReadValue(label,currStrVal) =>val
        if(val==trueVal) {true =>gotResult}
        if(val==falseVal) {false =>gotResult}
        break(gotResult != null)
        println("** Please enter '" + trueVal + "' or '"  + falseVal + "'")
    |
    gotResult
/ReadValueBoolean





# If value is Dict, for each key found, return corresponding value (as list). Otherwise true if value found, false if not found
P(1,List) =>lines
P(2) =>value
    if(getType(value)=="Dict") Inner{
        # match keys and result corresponding values as list
        dict=value
        result=List
        lines->line
            dict.keys->key 
                if(line.contains(key)) {result.add(dict.get(key))}
        |
        result.unique
    } else Inner{   
        # check for single value
        lines->line assert(line.contains(value)) out(line) | _.length>0
    }
/LinesContain



# List available save files across all code directories
#
# --
	Sys.codeDirs.reverse->d
		Lib:Header(d.path)
		Inner {
			d.files(Glob("savefile*.txt"))->f 
				out(Str(f.name,f)) 
			| _.sort->x
				f=x.data
				println("   " + f.name.after("savefile").before(".txt"))
		}
/Scripts
