# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


# Readme for script
<<< EOF

--------------------------------------------------
OS independent editor functionality

To edit a file: Lib:e (File)
To page a file: Lib:m (File)

For windows runs notepad, for Linux there is
choice. 
 
--------------------------------------------------

>>> EOF
/Readme


# Edit file
    P(1,Sys.savefile) =>file
    if(Sys.isWindows)
        Dir.runDetach("cmd","/c","notepad",file.path)
    else
        ShowLinuxEditor(file)
/e



# Page through file
    P(1,Sys.savefile) =>file
    if(Sys.isWindows)
        Dir.run("cmd", "/c", "more", file.path)
    else
        Dir.run("more", file.path)
/m


# Update Cfg with terminal size (if possible)
    false =>updated
    if(!Sys.isWindows) {
        # Linux
        Dir.runCapture("which","stty").nth.contains("/stty") =>hasStty
        if(hasStty, Inner{
            Dir.runCapture("stty","size").nth.split =>list
            #debug("list=" + list)
            Cfg.h(list.nth(0).parseInt)
            Cfg.w(list.nth(1).parseInt)
            true =>updated
        })
    } else {
        # Windows (a bit slow)
        Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Width").nth.parseInt =>w
        Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Height").nth.parseInt =>h
        Cfg.w(w)
        Cfg.h(h)
        true =>updated
    }
    if(updated, Cfg, null)
/GetTerminalSize
            


# Select Linux editor and remember selection for next time, open file in editor
# --
  P(1,Sys.savefile) =>file
    List(
        Dict.set("label","sublime")
            .set("action", Lambda { P(1)=>file Dir.runDetach("subl",file.path) }),
        Dict.set("label","gedit")
            .set("action", Lambda { P(1)=>file Dir.runDetach("gedit",file.path) }),
        Dict.set("label","leafpad")
            .set("action", Lambda { P(1)=>file Dir.runDetach("leafpad",file.path) }),
        Dict.set("label","nano")
            .set("action", Lambda { P(1)=>file Dir.run("nano", file.path) }),
        Dict.set("label","micro")
            .set("action", Lambda { P(1)=>file Dir.run("micro", file.path) })
    ) =>linuxEditors

    if(Val("linuxEditor")==null) {
        MenuSelect(linuxEditors, Lambda { P(1).get("label")},"Select editor") =>ed
        ValDef("linuxEditor", ed)
    }

    Val("linuxEditor").get("action").call(file)
/ShowLinuxEditor



# Clear selected Linux editor
    ValDef("linuxEditor",null)
    "Linux editor selection cleared"
/ClearEditor



Sys.homeDir.sub("private") =>d
if(!d.exists) d.create
d
/DirPrivate


# Create name of temp file under /tmp
P(1) =>name 
    if (Sys.isWindows,
	Dir("c:\temp").file(name+currentTimeMillis),
    	Dir("/tmp").file(name + currentTimeMillis) )
/TmpFile




# Run external program and collect stdout, stderr and exitCode - returns Dict
# with fields cmd, stdin, stdout, stderr, exitCode
#
P(1,List("ls","-l")) => cmd
P(2,List) => stdinLines
P(3,false) => acceptErrors
P(4,false) => showDebug

    if (getType(cmd) != "List") {
        cmd=List(cmd) # wrap as list
    }
    if (getType(stdinLines) != "List") {
        stdinLines=List(stdinLines) # wrap as
    }
    
    TmpFile("in") =>inFile
    TmpFile("out") =>outFile
    TmpFile("err") =>errFile
    
    inFile.create(stdinLines)
    exitCode = Dir.runProcessWait(inFile,outFile,errFile,cmd)
    Dict
        .set("cmd", cmd)
        .set("stdin", stdinLines)
        .set("stdout",if(outFile.exists,outFile.read,List))
        .set("stderr",if(errFile.exists,errFile.read,List))
        .set("exitCode", exitCode)
    =>result
    
    Lambda { 
        P(1) =>f 
        if(f.exists) f.delete 
    } =>Del
    
    Del.call(inFile)
    Del.call(outFile)
    Del.call(errFile)

    FAIL = false
    if (result.get("exitCode") != 0 && !acceptErrors) {
        FAIL = true
    }


    if(!acceptErrors && (showDebug || FAIL)) {
        Inner {  # "hide" loops inside inner block, so as not to affect return value of function
            println("- cmd:")
            result.get("cmd")->line println("    " + line) |

            println("- exitCode = " + result.get("exitCode"))

            println("- stdin:")
            result.get("stdin")->line println("   # " + line) |

            println("- stdout:")
            result.get("stdout")->line println("   # " + line) |

            println("- stderr:")
            result.get("stderr")->line println("   # " + line) |
            println
        }
    }
    error(FAIL,"run failed with error")
    
    # return value
    result
/run






# Show a list of options
    P(1,List) =>options
    P(2,Lambda { "name"}) =>macroGetElementName
        options->x
            println("- " + macroGetElementName.call(x))
/ShowOptions



# Select zero or more from list of options
# --
    P(1,List) =>options
    P(2,Lambda { "name"}) =>macroGetElementName
    P(3,false) =>emptyMeansNone
        sel=readLine("Enter exact or part of value?").trim
        if(emptyMeansNone && sel=="") {
            # empty list
            result=List
        } else Inner{
            # Look for exact match first, then if no hits, partial
            options->opt
                assert(macroGetElementName.call(opt)==sel)
                out(opt)
            | =>result
            if(result.empty) Inner{
                options->opt
                    assert(macroGetElementName.call(opt).contains(sel))
                    out(opt)
                | =>result
            }
        }
        result
/SelectOptions



# Display text with line under
    P(1,"Title") =>title
    println
    println(title)
    println( Lib.Data.yes(title.length,"-").concat )
/Header




P(1,List) =>options P(2,Lambda { "name"}) =>macroGetElementName P(3) =>title 
#
    null =>selectedElement
    loop
        println("")
        if(title != null, Header(title), 0)

        ShowOptions(options, macroGetElementName)
        println("")
        SelectOptions(options, macroGetElementName) =>result
        
        if(result.length==1, Inner{ result.nth =>selectedElement})
        break(selectedElement != null)
        println("** No match or not unique")
    | selectedElement
/MenuSelect



P(1,"label") =>label P(2) =>currVal
    println("")
    (label + if(currVal," ["+currVal+"]","") + " : ") =>prompt
    readLine(prompt) =>line
    if(line.trim=="", currVal, line)
/ReadValue




P(1,"label") =>label P(2) =>currVal
    null =>gotResult
    loop
        ReadValue(label,""+currVal) =>val
        if(val.?parseInt) {val.parseInt =>gotResult}
        break(gotResult != null)
        println("** Integer required")
    |
    gotResult
/ReadValueInt




P(1,"label") =>label P(2) =>currVal P(3,"yes") =>trueVal P(4,"no") =>falseVal
    null =>gotResult
    loop
        if(currVal != null, if(currVal, trueVal, falseVal), null) =>currStrVal
        ReadValue(label,currStrVal) =>val
        if(val==trueVal) {true =>gotResult}
        if(val==falseVal) {false =>gotResult}
        break(gotResult != null)
        println("** Please enter '" + trueVal + "' or '"  + falseVal + "'")
    |
    gotResult
/ReadValueBoolean





# If value is Dict, for each key found, return corresponding value (as list). Otherwise true if value found, false if not found
P(1,List) =>lines
P(2) =>value
    if(getType(value)=="Dict") Inner{
        # match keys and result corresponding values as list
        dict=value
        result=List
        lines->line
            dict.keys->key 
                if(line.contains(key)) {result.add(dict.get(key))}
        |
        result.unique
    } else Inner{   
        # check for single value
        lines->line assert(line.contains(value)) out(line) | _.length>0
    }
/LinesContain

