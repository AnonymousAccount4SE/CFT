# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2022 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
# --
<<<< EOF
This script is for background jobs control, as started by
the '&' expression, which has the following syntax

& expr

or 

& expr, name

where name is an identifier or a string, to identify the process.


Foregrounding a job
-------------------
For jobs that require input, we use the ToForeground() function.
This starts a simple command loop, where output from the job is
displayed on screen, and we can send input to it. 

We can detach from the job by typing .quit, or if the job 
completes.

/StartHeavyTasks
>>>> EOF
->line println("| " + line)
/Readme


# Get all jobs
# --
    Inner {
        Sys.Jobs.namesCompleted->name out("COMPLETED " + name)
    } + Sys.Jobs.namesRunning
/AllJobs



# Get running job names
# --
    Sys.Jobs.namesRunning
/Running


# Return completed job names (for integration into prompt)
# --
    Sys.Jobs.namesCompleted
/Completed


# Get single result from first terminated process
# --
    completed = Sys.Jobs.namesCompleted
    error(completed.length==0, "No completed jobs")

    name=completed.first
    proc=Sys.Jobs.getCompleted(name)

    Lib:Header(name)
    output=proc.output
    if (output.length > 0) Inner {
        output->line println(line)
    } @rel

    Sys.Jobs.deleteCompleted(name)
    
    proc.exitValue
/Get


# Clear all completed jobs
# --
    Sys.Jobs.namesCompleted->name Sys.Jobs.deleteCompleted(name)
/Clear


# Bring running job to "foreground", to do interactive follow-up
# --
    Lib:MenuSelect(Sys.Jobs.namesRunning,null,"Select job") => name

    Lib:Header("Selected job: " + name)

	addDebug("name='" + name + "'")

    println("Below follows an input loop.")
    println("Output from the job is displayed, and you may enter input to it")
    println
    println("- To detach from job, type 'q'")
    println("- To send data to job, type a space followed by content: ' xxx'")
	println("- To refresh output from job, just press Enter")
    println
    println("Text following below the line, is output from the job.")
    println
    println("BEWARE: Input() contains state (last value) which may change")
    println("between presenting the default, and pressing Enter to use it!!")
    println
    readLine("ENTER to continue")
    println("--------------------------------------------------------------------")

    proc=Sys.Jobs.getRunning(name)
	
	dbKey=name.toHexString

    error(proc==null,"No running process " + name)
    loop
		Sys.sleep(800)
		Db2:Get(Sys.scriptId,dbKey,List) + proc.output => output
		output.last(100) => output
		
		Db2:Set(Sys.scriptId,dbKey,output)

        if (proc.isDone) {
            println("(Job completed)")
            break
        }
		Inner {
			output->line println(line)
		}

		println
        readLine("q to quit, .xxx to send data, Enter to refresh") => line
		break(line=="q")
		if (line.startsWith(" ")) {
			line=line.sub(1)
			proc.sendLine(line)
			output.add(line)
			Db2:Set(Sys.scriptId,dbKey,output)
		} 
		# else repeat loop, updating output from the process
    |
    "Done"
/ToForeground
