# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2023 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
# --
<<<< EOF
This script is for background jobs control, as started by
the '&' expression, which has the following syntax

& expr

or 

& expr, name

where name is an identifier or a string, to identify the process.


Foregrounding a job
-------------------
For jobs that require input, we use the ToForeground() function.
This starts a simple command loop, where output from the job is
displayed on screen, and we can send input to it. 

We can detach from the job by typing .quit, or if the job 
completes.

/StartHeavyTasks
>>>> EOF
->line println("| " + line)
/Readme



# When starting, check if time for a purge of old data from Db2 collection 
# associated with this script. Doing this by grabbing a lock that is not
# released again
# --
    sysKey=Sys.scriptId+"_system"

    Db2:Get(sysKey,"lastPurge",0) => lastPurge

    if (currentTimeMillis - lastPurge > 86400*1000) {
        if (Std.Db.?obtainLock(sysKey,10)) {
            println("Jobs:onLoad cleaning up Db2 old content")
            addDebug("Purging Db2 collection for Jobs script: " + Sys.scriptId)
            Db2:DeleteCollection(Sys.scriptId)
            Db2:Set(sysKey,"lastPurge", currentTimeMillis)
            ## NOT releasing the lock
            ###Std.Db.releaseLock(sysKey)
        }
    }
//onLoad


# Get all jobs
# --
	names = (Sys.Jobs.namesCompleted + Sys.Jobs.namesRunning)
	names->name
		Sys.Jobs.get(name) => job
		report(
			if(job.isDone,"COMPLETED",""),
			if(job.isBlockedOnInput,"<stdin>","-"),
			name)
/AllJobs



# Get running job names
# --
    Sys.Jobs.namesRunning
/Running


# Return completed job names (for integration into prompt)
# --
    Sys.Jobs.namesCompleted
/Completed


# Get single result from first terminated process
# --
    completed = Sys.Jobs.namesCompleted
    error(completed.length==0, "No completed jobs")

    name=completed.first
    proc=Sys.Jobs.getCompleted(name)

    Lib:Header(name)
    output=proc.output
    if (output.length > 0) Inner {
        output->line println(line)
    } @rel

    Sys.Jobs.deleteCompleted(name)
    
    proc.exitValue
/Get


# Clear all completed jobs
# --
    Sys.Jobs.namesCompleted->name Sys.Jobs.deleteCompleted(name)
/Clear


# Bring running job to "foreground", to do interactive follow-up
# --
	# identify jobs that are waiting for input
	Sys.Jobs.namesRunning=>namesRunning
	Inner {
		namesRunning->name
			proc=Sys.Jobs.get(name)
			assert(proc.isAlive && proc.isBlockedOnInput)
			out(name)
	} => names
	
	error (names.length==0, "No jobs blocked on input")

    Lib:MenuSelect(names,null,"Select job") => name

    Lib:Header("Selected job: " + name)

    #addDebug("foreground job name='" + name + "'")

    println("Below follows an input loop.")
    println("Output from the job is displayed, and you may enter input to it")
    println
    println("- To refresh, enter TAB + Enter")
	println("- To exit enter TAB + 'q' + Enter")
	println
    readLine("ENTER to continue")
    println("--------------------------------------------------------------------")

    proc=Sys.Jobs.getRunning(name)
    
    dbKey=name.toHexString
    
    TAB="^t".unEsc

    error(proc==null,"No running process " + name)
    loop
        Sys.sleep(800)
        
        Db2:Get(Sys.scriptId,dbKey,List) + proc.output => output
        output.last(100) => output
        
        Db2:Set(Sys.scriptId,dbKey,output)

        if (proc.isDone) {
            println("(Job completed)")
            break
        }
        println(Curses:Clear)
        Inner {
            output->line println(line)
        }

        println
        readLine => line
        if (line.startsWith(TAB)) {
        	break(line.sub(1)=="q")
        } else {
            proc.sendLine(line)
            output.add(line)
            Db2:Set(Sys.scriptId,dbKey,output)
        } 
        # else repeat loop, updating output from the process
    |
    "Done"
/ToForeground
