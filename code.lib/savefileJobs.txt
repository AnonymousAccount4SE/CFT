# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2023 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
# --
<<<< EOF
This script is for background jobs control, as started by
the '&' expression, which has the following syntax

& expr

or 

& expr, name

where name is an identifier or a string, to identify the process.


Foregrounding a job
-------------------
For jobs that require input, we use the ToForeground() function.
This starts a simple command loop, where output from the job is
displayed on screen, and we can send input to it. 

If there is no significant output from the job for a while and
it is not blocked on input, we enter command mode, where we can leave the
process (put it into background again). 

This can also be done by entering TAB + q + Enter in job input

>>>> EOF
->line println("| " + line)
/Readme



# When starting, check if time for a purge of old data from Db2 collection 
# associated with this script. Doing this by grabbing a lock that is not
# released again
# --
    sysKey=Sys.scriptId+"_system"

    Db2:Get(sysKey,"lastPurge",0) => lastPurge

    if (Std.Db.?obtainLock(sysKey,10)) {
        #println("Jobs:onLoad cleaning up Db2 old content")
        addDebug("Purging Db2 collection for Jobs script: " + Sys.scriptId)
        Db2:DeleteCollection(Sys.scriptId)
        Db2:Set(sysKey,"lastPurge", currentTimeMillis)
        ## NOT releasing the lock
        ###Std.Db.releaseLock(sysKey)
    }
//onLoad


# Get all jobs
# --
	names = (Sys.Jobs.namesCompleted + Sys.Jobs.namesRunning)
	names->name
		Sys.Jobs.get(name) => job
		report(
			if(job.isDone,"COMPLETED",""),
			if(job.isBlockedOnInputSince != null,"<stdin>","-"),
			name)
/AllJobs



# Get running job names
# --
    Sys.Jobs.namesRunning
/Running


# Return completed job names (for integration into prompt)
# --
    Sys.Jobs.namesCompleted
/Completed


# Get single result from first terminated process
# --
    completed = Sys.Jobs.namesCompleted
    error(completed.length==0, "No completed jobs")

    name=completed.first
    proc=Sys.Jobs.getCompleted(name)

    Lib:Header(name)
    output=proc.output
    if (output.length > 0) Inner {
        output->line println(line)
    } 

    Sys.Jobs.deleteCompleted(name)
    
    proc.exitValue
/Get


# Clear all completed jobs
# --
    Sys.Jobs.namesCompleted->name Sys.Jobs.deleteCompleted(name)
/Clear


# Extend saved output
# --
	P(1) as List => lines
	P(2) as String => dbKey
	
	Db2:Get(Sys.scriptId,dbKey,List) + lines => output
	output = output.last(100)
	Db2:Set(Sys.scriptId,dbKey,output)
//AddOutputLines


# Get output until either blocking on input or too long has passed
#
# Note that the "blocked on input" mechanism depends on being a timestamp,
# since sending an input line to the Job does not immediately restart it,
# so it remains in "blocked on input" for a good while. To avoid falsely
# re-detecting that, after sending input to the Job, we look for next
# blocked-on-input time greater than previous value (milliseconds).
# --
	P(1) as Process => proc
	P(2) as String => dbKey
	P(3) as int => lastBlockOnInputTime
	
	startTime=currentTimeMillis
	Inner {
		loop
		    Sys.sleep(100)
			outLines=proc.output
			if (outLines.length>0) {
				AddOutputLines(outLines,dbKey)
		    	Inner{
		    		outLines->line println(line)
		    	}
		    }
		    if (proc.isDone) {
		    	println("Job has terminated")
		    	break
		    }
		    block=proc.isBlockedOnInputSince
		    if (block != null && block > lastBlockOnInputTime) {
		   		break
		   	}
		   	
			break(currentTimeMillis - startTime > 3000)
	}
//WaitForInput       

		

# Bring running job to "foreground", to do interactive follow-up
# --
	# identify jobs that are waiting for input
	Sys.Jobs.namesRunning=>namesRunning
	Inner {
		namesRunning->name
			proc=Sys.Jobs.get(name)
			assert(proc.isAlive && proc.isBlockedOnInputSince != null)
			out(name)
	} => names
	
	error (names.length==0, "No jobs blocked on input")

    Lib:MenuSelect(names,null,"Select job") => name

    proc=Sys.Jobs.getRunning(name)
    error(proc==null,"No running process " + name)

    Lib:Header("Selected job: " + name)
	println("To abort, enter TAB + q + ENTER when process asks for input")
	println
	println("Or wait for command mode, if Job not blocking on input for 3 seconds")
	println
    
    readLine("Press Enter to continue")
    
    
    dbKey=name.toHexString
    
    TAB="^t".unEsc

	lastBlockOnInputTime=0
    loop
    	output=Db2:Get(Sys.scriptId,dbKey,List)
        println(Curses:Clear)
        Inner {
            output->line println(line)
        }
        
    	WaitForInput(proc,dbKey,lastBlockOnInputTime)

        if (proc.isDone) {
            #println("(Job completed)")
            break
        }
        if (proc.isBlockedOnInputSince != null) {
        	lastBlockOnInputTime=proc.isBlockedOnInputSince
        	#println("Job input")
        	line=readLine
        	if (line==TAB + "q") error("Aborting Job foreground processing")
        	proc.sendLine(line)
        	
        	AddOutputLines(List(line), dbKey)
        } else {
        	println("--------------------------")
        	println("No output or pending input")
        	println("--------------------------")
        	
			println("Press 'q' to quit, or just Enter to wait for more") 
			break(readLine.trim=="q")
		}	       		
	|
    "Done"
/ToForeground
