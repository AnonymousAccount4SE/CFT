# Readme
<<<<<<<<<<<< EOF

A descriptive format for describing attributes with hosts, for
managing automatic updates.

Processes Hosts.txt file on following format:

[Property=Value]
HOST
HOST
HOST [OverrideValue]?
 :
 

>>>>>>>>>>>> EOF
/Readme


# Data file
(Lib:DirPrivate).file("Hosts.txt")
/HostsFile

# Internal
    P(1,"[A=B]") =>line
    error(!line.startsWith("["), "not header line: " + line)
    line.after("[").before("]").split("=") =>parts
    parts.nth.trim =>a
    parts.nth(1).trim =>b
    # return value
    List(a,b)
/parseHeader



# Process Hosts file and store it in session state
    parseData = Lambda {
        P(1) =>line
        P(2) =>name
        P(3) =>value

		getHosts = Lambda{ 
			P(1) =>glob
			    "" =>regex
			    glob.chars->c
			        false =>done
			        regex = regex + if(c=='*', ".*", "["+c+"]")
			    |
			    Regex(regex) =>re
			    Val("data").keys.sort->hostName
			        assert(re.match(hostName))
			        out(hostName)
		}

        line.before("[").trim =>host
        line.after("[").before("]") =>override 

        if(override != "", override, value) =>overriddenVal
        
        if(host.contains("*"), Inner{
            # assign value for all hosts matching glob expression
            getHosts.call(host)->oneHost
                Val("data").get(oneHost,Dict).set(name, overriddenVal)
        }, Inner{
            # regular assign
            Val("data").get(host,Dict).set(name,overriddenVal)
        })
    } 

    println("INFO Processing file " + HostsFile.path)

    ValDef("data",Dict)
    
    null =>settingName
    null =>settingValue
    HostsFile.read->origLine
        origLine.trim =>line
        reject(line=="")
        reject(line.startsWith("#"))
        
        tryCatch({
	        if(line.startsWith("[")) {
	        	println("Parsing header " + line)
	            parseHeader(line).push(2,"") =>settingName =>settingValue
	        } else {
	            parseData.call(line,settingName,settingValue)
	        }
	    })=>st
	    if (!st.ok) {
	    	println("-------------------------------------")
	    	println(origLine.file.name + " line " + origLine.lineNumber + ": " + origLine)
	    	println("-------------------------------------")
	    	println(st.msg)
	    	error("Failed reading hosts file")
	    }
    |

/ProcessHostsFile



# Common function called internally
    false =>flag
    
    if(Val("time")==null) {
        true =>flag
    }
    
    if(Val("time") != null && Val("time") != HostsFile.lastModified) {
        true =>flag
    }
    
    if(Val("data")==null) {
        true =>flag
    }
    if(flag) {
        ProcessHostsFile
        ValDef("time",HostsFile.lastModified)
    }
    true
/CheckData

# Explore data interactively
    CheckData
    P(1,readLine("Search term")) =>searchTerm
    Val("data") =>root
    root.keys.sort->host
        root.get(host) =>data
        data.keys.sort->field
            ""+data.get(field) =>value
            assert(host.contains(searchTerm) || field.contains(searchTerm) || value.contains(searchTerm))
            report(host,field,value)
/Search

# Get host list
    CheckData
    Val("data").keys.sort
/GetHosts


# Get host list sorted via Glob expr
P(1,"*") =>glob
    "" =>regex
    glob.chars->c
        false =>done
        regex = regex + if(c=='*', ".*", "["+c+"]")
    |
    Regex(regex) =>re
    GetHosts->hostName
        assert(re.match(hostName))
        out(hostName)
/GlobHosts


# Get all known fields
    CheckData
    Val("data").keys->host
        Val("data").get(host).keys->field out(field)
    | _.unique.sort
/GetFields


# Get value for host + field
    CheckData
    P(1) =>host
    P(2) =>field

    error(!Val("data").has(host), "No config for host " + host)
    Val("data").get(host).get(field)
/GetValue


# Get value for host + field, then return true if it matches expected value
    CheckData
    P(1) =>host
    P(2) =>field
    P(3) =>expectedValue

    error(!Val("data").has(host), "Invalid host " + host)
    
    Val("data").get(host).get(field,null) == expectedValue
/Has


# Return true if host has value for field
    CheckData
    P(1) =>host
    P(2) =>field

    error(!Val("data").has(host), "Invalid host " + host)
    
    Val("data").get(host).get(field,null) != null
/HasField

# Shortcut
    Search
/S

# Shortcut
    CheckData
/C


# View host status
    Hosts:GetHosts =>hosts
    
    hosts->host
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =>target
        println("Checking host " + target)
        
        SSH:HostOk (target) =>hostOk
        SSH:VerifySudo (target) =>sudoOk
        
        Lambda {P(1) =>x if(x,"ok","<<FAIL>>")} =>show
        report("Host: " + host, "Ping: " + show.call(hostOk), "Sudo: "+show.call(sudoOk))
/ShowHostsStatus




# Verify all hosts have copy of SSH key
    Hosts:GetHosts =>hosts

    println("Distributing ssh key to all hosts!")
    readLine("Press Enter")
    
    hosts->host
        Hosts:GetValue (host, "SSHUser") =>sshUser
        if(sshUser==null, Inner{
            println("----- WARNING: " + host + " has no SSHUser")
        })
        assert(sshUser != null)

        sshUser + "@" + host =>target
        println
        println("----- " + target)

        Dir.run("ssh-copy-id",target)
/CheckSSHKeys



# Check if debian based host should be rebooted
        P(1) =>target
        SSH:sudo (target, "ls /var/run/reboot-required", true) =>result
        # true when file found (return code 0)
        result.get("exitCode") == 0
/DebianHostNeedsReboot



# Run update/upgrade
P(1,readLine("Enter part of host name, enter for all"))=>h
	Lib:DirPrivate.sub("APTUpdate").files->f 
		#assert(f.lastModified < Date.sub(Date.Duration.days(3)).get)
		f.delete 
	|
	
    Hosts:GetHosts =>hosts
    hosts->host
    	assert(host.contains(h))
        assert(Hosts:Has (host,"PackageManager","apt"))
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =>target
        println("Updating host " + target)
        tryCatch(APTUpdate:APTUpdateUpgrade (target, "   "))

        # Check if needs reboot and can be rebooted
        DebianHostNeedsReboot(target) =>needsReboot
        Hosts:Has (host, "Auto.reboot","yes") =>canBeRebooted

        if(needsReboot && canBeRebooted) {
                println("   *** Automatically rebooting " + host)
                SSH:sudo (target, "reboot", true)
                        # acceptErrors=true, as the reboot means immediate disconnect
        }

        if(needsReboot && !canBeRebooted) {
                println("   *** Host " + host + " should be rebooted - can not do this automatically")
        }
/UpgradeAPT


# Display hosts that should be rebooted
    Hosts:GetHosts->host
        assert(Hosts:Has (host,"OSFamily","Debian"))
        Hosts:GetValue (host, "SSHUser") =>sshUser

        sshUser+"@"+host =>target

        SSH:HostOkSSH (target) =>hostOk
        if (!hostOk) {
            println(target + ": -offline-")
            assert(false)
        }

        DebianHostNeedsReboot(target) =>x
        if(x,"NEEDS REBOOT","ok") =>status
        println(target + ": " + status)
        
/NeedReboot     


# Update or install CFT
P(1,"")=>hostPattern
    Date.Duration.minutes(30).get =>minTimeSinceLastRun
    
    Hosts:GetHosts =>hosts
    hosts->host
        assert(host.contains(hostPattern))
        assert(Hosts:Has (host,"Install.CFT","1"))
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)

        Db:Get (host, "CFT") =>lastDate
          if (lastDate != null) {
            Date.diff(lastDate).get =>timeSinceLastRun
            if (timeSinceLastRun < minTimeSinceLastRun) {
                println("Host " + host + " was last checked " + lastDate.fmt)
                assert(false) # next
            }
        }

        assert(SSH:HostOk (host))
        
        sshUser+"@"+host =>target
        println("Updating " + target)
        
        assert(SSH:HostOkSSH (target))

        tryCatch(Java:VerifyCFT (target, "   "))
        Db:Add (host, Date, "CFT")
/UpdateCFT


# View host status
P(1,"mpstat") => command
P(2,Lambda{true})  => lineFilter

    x = Input("Hosts glob filter").get
    hosts = GlobHosts(x)
    
    hosts->host
        
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =>target
        assert(SSH:HostOk (host))

        println("------ " + host)
        SSH:run (target, "which mpstat", true).get("exitCode") != 0 =>install
        if(install) {
            println("    (installing sysstat)")
            SSH:sudo (target, "apt-get -y install sysstat")
        }
        SSH:run (target, command).get("stdout")->line
        	assert(lineFilter.call(line))
            report(host,line)
/SysStat


SysStat("mpstat")
/MPStat

SysStat("iostat", Lambda{P(1).contains("vda")})
/IOStat

# Fix resolv.conf problem
	readLine("Softlinks /run/systemd/resolve/resolv.conf to /etc/resolv.conf, yes to continue") =>yesno
	error(yesno != "yes", "Aborted")
	
	Hosts:GetHosts =>hosts
	hosts->host
		assert(Hosts:GetValue(host, "OSFamily")=="Debian")
		       
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)

        target=sshUser+"@"+host

        println("--- " + host + ": checking resolv.conf")
        replace=false
        tryCatch(Inner {
        	SSH:sudo(target,"ls -l /etc/resolv.conf").get("stdout")=>stdout
        	stdout->line println("    " + line) |
        	replace = Lib:LinesContain(stdout,"stub-resolv.conf")
        })

 		if(replace) {
			println("    CHANGING to /run/systemd/resolve/resolv.conf")
			tryCatch(
				SSH:sudo (target, List("rm /etc/resolv.conf", "ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf"))
			)
		} 
/FixResolvConf


UpgradeAPT
UpdateCFT
/runAll
