# Readme
<<<<<<<<<<<< EOF

A descriptive format for describing attributes with hosts, for
managing automatic updates.

Processes Hosts.txt file on following format:

[Property=Value]
HOST
HOST
HOST [OverrideValue]?
 :
 

>>>>>>>>>>>> EOF
/Readme


# Data file
(Lib:DirPrivate).file("Hosts.txt")
/HostsFile

# Internal
    P(1,"[A=B]") =>line
    error(!line.startsWith("["), "not header line: " + line)
    line.after("[").before("]").split("=") =>parts
    parts.nth.trim =>a
    parts.nth(1).trim =>b
    # return value
    List(a,b)
/parseHeader


# Internal - create list of hosts based on expression with '*'
P(1) =>glob
    "" =>regex
    glob.chars->c
        false =>done
        if(c=='*', ".*", "["+c+"]") =>x regex+x =>regex
    |
    Regex(regex) =>re
    Val("data").keys.sort->hostName
        assert(re.match(hostName))
        out(hostName)
/GlobHosts




# Process Hosts file and store it in session state
    Lambda {
    # Internal
        P(1) =>line
        P(2) =>name
        P(3) =>value

        line.before("[").trim =>host
        line.after("[").before("]") =>override 

        if(override != "", override, value) =>overriddenVal
        
        if(host.contains("*"), Inner{
            # assign value for all hosts matching glob expression
            GlobHosts(host)->oneHost
                Val("data").get(oneHost,Dict).set(name, overriddenVal)
        }, Inner{
            # regular assign
            Val("data").get(host,Dict).set(name,overriddenVal)
        })
    } =>parseData

    println("INFO Processing file " + HostsFile.path)

    ValDef("data",Dict)
    
    null =>settingName
    null =>settingValue
    HostsFile.read->origLine
        origLine.trim =>line
        reject(line=="")
        reject(line.startsWith("#"))
        
        tryCatch({
	        if(line.startsWith("[")) {
	        	#println("Parsing header " + line)
	            parseHeader(line).push(2,"") =>settingName =>settingValue
	        } else {
	            parseData.call(line,settingName,settingValue)
	        }
	    })=>st
	    if (!st.ok) {
	    	println("-------------------------------------")
	    	println(origLine.file.name + " line " + origLine.lineNumber + ": " + origLine)
	    	println("-------------------------------------")
	    	println(st.msg)
	    	error("Failed reading hosts file")
	    }
    |

/ProcessHostsFile



# Common function called internally
    false =>flag
    
    if(Val("time")==null) {
        true =>flag
    }
    
    if(Val("time") != null && Val("time") != HostsFile.lastModified) {
        true =>flag
    }
    
    if(Val("data")==null) {
        true =>flag
    }
    if(flag) {
        ProcessHostsFile
        ValDef("time",HostsFile.lastModified)
    }
    true
/CheckData

# Explore data interactively
    CheckData
    P(1,readLine("Search term")) =>searchTerm
    Val("data") =>root
    root.keys.sort->host
        root.get(host) =>data
        data.keys.sort->field
            data.get(field) =>value
            assert(host.contains(searchTerm) || field.contains(searchTerm) || value.contains(searchTerm))
            report(host,field,value)
/Search

# Get host list
    CheckData
    Val("data").keys.sort
/GetHosts


# Get all known fields
    CheckData
    Val("data").keys->host
        Val("data").get(host).keys->field out(field)
    | _.unique.sort
/GetFields


# Get value for host + field
    CheckData
    P(1) =>host
    P(2) =>field

    error(!Val("data").has(host), "No config for host " + host)
    Val("data").get(host).get(field)
/GetValue


# Get value for host + field, then return true if it matches expected value
    CheckData
    P(1) =>host
    P(2) =>field
    P(3) =>expectedValue

    error(!Val("data").has(host), "Invalid host " + host)
    
    Val("data").get(host).get(field,null) == expectedValue
/Has


# Return true if host has value for field
    CheckData
    P(1) =>host
    P(2) =>field

    error(!Val("data").has(host), "Invalid host " + host)
    
    Val("data").get(host).get(field,null) != null
/HasField

# Shortcut
    Search
/S

# Shortcut
    CheckData
/C


# View host status
    Hosts:GetHosts =>hosts
    
    hosts->host
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =>target
        println("Checking host " + target)
        
        SSH:HostOk (target) =>hostOk
        SSH:VerifySudo (target) =>sudoOk
        
        Lambda {P(1) =>x if(x,"ok","<<FAIL>>")} =>show
        report("Host: " + host, "Ping: " + show.call(hostOk), "Sudo: "+show.call(sudoOk))
/ShowHostsStatus




# Verify all hosts have copy of SSH key
    Hosts:GetHosts =>hosts

    println("Distributing ssh key to all hosts!")
    readLine("Press Enter")
    
    hosts->host
        Hosts:GetValue (host, "SSHUser") =>sshUser
        if(sshUser==null, Inner{
            println("----- WARNING: " + host + " has no SSHUser")
        })
        assert(sshUser != null)

        sshUser + "@" + host =>target
        println
        println("----- " + target)

        Dir.run("ssh-copy-id",target)
/CheckSSHKeys



# Check if debian based host should be rebooted
        P(1) =>target
        SSH:sudo (target, "ls /var/run/reboot-required", true) =>result
        # true when file found (return code 0)
        result.get("exitCode") == 0
/DebianHostNeedsReboot



# Run update/upgrade
    Hosts:GetHosts =>hosts
    hosts->host
        assert(Hosts:Has (host,"PackageManager","apt"))
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =>target
        println("Updating host " + target)
        tryCatch(APTUpdate:APTUpdateUpgrade (target, "   "))

        # Check if needs reboot and can be rebooted
        DebianHostNeedsReboot(target) =>needsReboot
        Hosts:Has (host, "Auto.reboot","yes") =>canBeRebooted

        if(needsReboot && canBeRebooted) {
                println("   *** Automatically rebooting " + host)
                SSH:sudo (target, "reboot", true)
                        # acceptErrors=true, as the reboot means immediate disconnect
        }

        if(needsReboot && !canBeRebooted) {
                println("   *** Host " + host + " should be rebooted - can not do this automatically")
        }
/UpgradeAPT


# Display hosts that should be rebooted
    Hosts:GetHosts->host
        assert(Hosts:Has (host,"OSFamily","Debian"))
        Hosts:GetValue (host, "SSHUser") =>sshUser

        sshUser+"@"+host =>target

        SSH:HostOkSSH (target) =>hostOk
        if (!hostOk) {
            println(target + ": -offline-")
            assert(false)
        }

        DebianHostNeedsReboot(target) =>x
        if(x,"NEEDS REBOOT","ok") =>status
        println(target + ": " + status)
        
/NeedReboot     


# Update or install CFT
P(1,"")=>hostPattern
    Date.Duration.minutes(30).get =>minTimeSinceLastRun
    
    Hosts:GetHosts =>hosts
    hosts->host
        assert(host.contains(hostPattern))
        assert(Hosts:Has (host,"Install.CFT","1"))
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)

        Db:Get (host, "CFT") =>lastDate
          if (lastDate != null) {
            Date.diff(lastDate).get =>timeSinceLastRun
            if (timeSinceLastRun < minTimeSinceLastRun) {
                println("Host " + host + " was last checked " + lastDate.fmt)
                assert(false) # next
            }
        }

        assert(SSH:HostOk (host))
        
        sshUser+"@"+host =>target
        println("Updating " + target)
        
        assert(SSH:HostOkSSH (target))

        tryCatch(Java:VerifyCFT (target, "   "))
        Db:Add (host, Date, "CFT")
/UpdateCFT


# View host status
    readLine("Hosts filter") =>filter
    Hosts:GetHosts =>hosts
    
    hosts->host
        assert(host.contains(filter))
        
        Hosts:GetValue (host, "SSHUser") =>sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =>target
        assert(SSH:HostOk (host))

        println("------ " + host)
        SSH:run (target, "which mpstat", true).get("exitCode") != 0 =>install
        if(install) {
            println("    (installing sysstat)")
            SSH:sudo (target, "apt-get -y install sysstat")
        }
        SSH:run (target, "mpstat").get("stdout")->line
            report(host,line)
/MPStat



UpgradeAPT
UpdateCFT
/runAll
