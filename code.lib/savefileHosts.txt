# Readme
<<<<<<<<<<<< EOF

A descriptive format for describing attributes with hosts, for
managing automatic updates.

Processes Hosts.txt file on following format:

[Property=Value]
HOST
HOST
HOST [OverrideValue]?
 :
 

>>>>>>>>>>>> EOF
/Readme


# Data file
(call "Lib:DirPrivate").file("Hosts.txt")
/HostsFile

# Internal
    P(1,"[A=B]")=line
    error(!line.startsWith("["), "not header line: " + line)
    line.after("[").before("]").split("=") =parts
    parts.nth.trim =a
    parts.nth(1).trim=b
    # return value
    List(a,b)
/parseHeader


# Internal - create list of hosts based on expression with '*'
P(1)=glob
    ""=regex
    glob.chars->c
        false =done
        if(c=='*', ".*", "["+c+"]") =x regex+x=regex
    |
    Regex(regex) =re
    Val("data").keys.sort->hostName
        assert(re.match(hostName))
        out(hostName)
/GlobHosts




# Process Hosts file and store it in session state
    Lambda {
    # Internal
        P(1)=line
        P(2)=name
        P(3)=value

        line.before("[").trim =host
        line.after("[").before("]") =override 

        if(override != "", override, value) =overriddenVal
        
        if(host.contains("*"), Inner{
            # assign value for all hosts matching glob expression
            GlobHosts(host)->oneHost
                Val("data").get(oneHost,Dict).set(name, overriddenVal)
        }, Inner{
            # regular assign
            Val("data").get(host,Dict).set(name,overriddenVal)
        })
    } =parseData

    println("INFO Processing file " + HostsFile.path)

    ValDef("data",Dict)
    
    null=settingName
    null=settingValue
    HostsFile.read->origLine
        origLine.trim =line
        
        reject(line=="")
        reject(line.startsWith("#"))
        
        if(line.startsWith("[")) {
            parseHeader(line).push(2,"") =settingName=settingValue
        } else {
            parseData.call(line,settingName,settingValue)
        }
    |

/ProcessHostsFile



# Common function called internally
    false =flag
    
    if(Val("time")==null) {
        true =flag
    }
    
    if(Val("time") != null && Val("time") != HostsFile.lastModified) {
        true =flag
    }
    
    if(Val("data")==null) {
        true =flag
    }
    if(flag) {
        ProcessHostsFile
        ValDef("time",HostsFile.lastModified)
    }
    true
/CheckData

# Explore data interactively
    CheckData
    P(1,readLine("Search term"))=searchTerm
    Val("data")=root
    root.keys.sort->host
        root.get(host)=data
        data.keys.sort->field
            data.get(field)=value
            assert(host.contains(searchTerm) || field.contains(searchTerm) || value.contains(searchTerm))
            report(host,field,value)
/Search

# Get host list
    CheckData
    Val("data").keys.sort
/GetHosts


# Get all known fields
    CheckData
    Val("data").keys->host
        Val("data").get(host).keys->field out(field)
    | _.unique.sort
/GetFields


# Get value for host + field
    CheckData
    P(1)=host
    P(2)=field

    error(!Val("data").has(host), "Invalid host " + host)
    Val("data").get(host).get(field)
/GetValue


# Get value for host + field, then return true if it matches expected value
    CheckData
    P(1)=host
    P(2)=field
    P(3)=expectedValue

    error(!Val("data").has(host), "Invalid host " + host)
    
    Val("data").get(host).get(field,null) == expectedValue
/Has


# Shortcut
    Search
/S

# Shortcut
    CheckData
/C


# View host status
    call "Hosts:GetHosts" =hosts
    
    hosts->host
        call "Hosts:GetValue" (host, "SSHUser") =sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =target
        println("Checking host " + target)
        
        call "SSH:HostOk" (target) =hostOk
        call "SSH:VerifySudo" (target) =sudoOk
        
        Lambda {P(1)=x if(x,"ok","<<FAIL>>")} =show
        report("Host: " + host, "Ping: " + show.call(hostOk), "Sudo: "+show.call(sudoOk))
/ShowHostsStatus




# Verify all hosts have copy of SSH key
    call "Hosts:GetHosts" =hosts

    println("Distributing ssh key to all hosts!")
    readLine("Press Enter")
    
    hosts->host
        call "Hosts:GetValue" (host, "SSHUser") =sshUser
        if(sshUser==null, Inner{
            println("----- WARNING: " + host + " has no SSHUser")
        })
        assert(sshUser != null)

        sshUser + "@" + host =target
        println
        println("----- " + target)

        Dir.run("ssh-copy-id",target)
/CheckSSHKeys



# Check if debian based host should be rebooted
        P(1)=target
        call "SSH:sudo" (target, "ls /var/run/reboot-required", true) =result
        # true when file found (return code 0)
        result.get("exitCode") == 0
/DebianHostNeedsReboot



# Run update/upgrade
    call "Hosts:GetHosts" =hosts
    hosts->host
        assert(call "Hosts:Has" (host,"PackageManager","apt"))
        call "Hosts:GetValue" (host, "SSHUser") =sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =target
        println("Updating host " + target)
        call "APTUpdate:APTUpdateUpgrade" (target, "   ")

        # Check if needs reboot and can be rebooted
        DebianHostNeedsReboot(target) =needsReboot
        call "Hosts:Has" (host, "Auto.reboot","yes") =canBeRebooted

        if(needsReboot && canBeRebooted) {
                println("   *** Automatically rebooting " + host)
                call "SSH:sudo" (target, "reboot", true)
                        # acceptErrors=true, as the reboot means immediate disconnect
        }

        if(needsReboot && !canBeRebooted) {
                println("   *** Host " + host + " should be rebooted - can not do this automatically")
        }
/UpdateAPT


# Display hosts that should be rebooted
    call "Hosts:GetHosts"->host
        assert(call "Hosts:Has" (host,"OSFamily","Debian"))
        call "Hosts:GetValue" (host, "SSHUser") =sshUser

        sshUser+"@"+host =target

        call "SSH:HostOkSSH" (target) =hostOk
        if (!hostOk) {
            println(target + ": -offline-")
            assert(false)
        }

        DebianHostNeedsReboot(target)=x
        if(x,"NEEDS REBOOT","ok")=status
        println(target + ": " + status)
        
/NeedReboot     


# Update or install CFT
    Date.Duration.minutes(30).get =minTimeSinceLastRun
    
    call "Hosts:GetHosts" =hosts
    hosts->host
        assert(call "Hosts:Has" (host,"Install.CFT","1"))
        call "Hosts:GetValue" (host, "SSHUser") =sshUser
        assert(sshUser != null)

        call "Db:Get" (host, "CFT") =lastDate
          if (lastDate != null) {
            Date.diff(lastDate).get =timeSinceLastRun
            if (timeSinceLastRun < minTimeSinceLastRun) {
                println("Host " + host + " was last checked " + lastDate.fmt)
                assert(false) # next
            }
        }

        assert(call "SSH:HostOk" (host))
        
        sshUser+"@"+host =target
        println("Updating " + target)
        
        assert(call "SSH:HostOkSSH" (target))

        call "Java:VerifyCFT" (target, "   ")
        call "Db:Add" (host, Date, "CFT")
/UpdateCFT

