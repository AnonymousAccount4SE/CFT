# Readme
<<<<<< EOF
Parsing "Ansible" text format looking like this:

# This is a comment

[Auto.reboot=yes]
*.v 
s*.s   [no]



>>>>>> EOF
/Readme

# Parse text lines. Returns dictionary with 'data' pointing at the
# actual data structure, and then the following lambdas, which are
# used as follows:
#
#    LallHosts.call
#    LallFields.call
#    Lget.call(elementName,fieldName,defaultValue?)
#    Ldump.call
#
# The data dictionary has keys for all elements, and under each
# is a Dict with the settings for that element.
# --
	file = Lib:DirPrivate.file("Hosts.txt") 
	data = Dict
		
	currProp=null
	currPropValue=null

	LFilter = Lambda{
		P(1,List) => list
		P(2) => regex
		list->s assert(regex.match(s)) out(s)
	}
	LApply = Lambda {
		P(1) => data
		P(2) => entities
		P(3) => name
		P(4) => value

		entities->e
			#println(e + "." + name + "=" + value)
			data.get(e,Dict).set(name,value)
	}

	file.read->line
		reject(line.trim.startsWith("#"))
		reject(line.trim=="")
		if (line.trim.startsWith("[")) {
			# property definition with default value
			line.after("[").before("]").split("=").push(2) => currProp =>currPropValue 
		} else {
			# data line with optional exception
			line.before("[").trim => entity
			if (entity.contains("*")) {
				regex=Glob(entity,false).regex
			
				# keys of data dict are the entities that we filter
				entities=LFilter.call(data.keys,regex)
			} else {
				entities=List(entity)
			}

			# is there an exception?
			redef=line.after("[").before("]").trim
			if(redef != "") {
				LApply.call(data, entities,currProp, redef)
			} else {
				LApply.call(data, entities,currProp, currPropValue)
			}
										
		}
	|

	# Create return value with lambdas for analyzing the data
	# --
	Dict
		.set("data",data)
		.set("LallHosts",Lambda{
			self.data.keys
		})
		.set("LallFields", Lambda{
			self.data.keys->key 
				self.data.get(key).keys->field
					out (field)
			| _.unique.sort
		})
		.set("Lget", Lambda{
			P(1)=>host
			P(2)=>field
			P(3)=>defaultValue

			result=defaultValue

			if (self.data.has(host)) {
				e=self.data.get(host)
				if (e.has(field)) {
					x=e.get(field)
					if (x != null) result=x
				}
			}

			result
		})
		.set("Ldump",Lambda{
			self.data.keys->host
				self.data.get(host).keys->field
					value=self.data.get(host).get(field)
					out(List(host,field,value))
		})
/Parse



# Verify all hosts have copy of SSH key
# --
	data=Parse
	data.LallHosts.call->host
		sshUser=data.Lget.call(host,"SSHUser")
		assert(sshUser != null)
		target=sshUser+"@"+host
		println("------ " + target)
		Dir.run("ssh-copy-id",target)
/CheckSSHKeys
		


# Run APT Update / upgrade on hosts
# --
	data=Parse
	
	allHosts=data.LallHosts
	lget = data.Lget

	
	data.LallHosts.call->host

		pm=data.Lget.call(host,"PackageManager")
		assert(pm=="apt")

		sshUser=data.Lget.call(host,"SSHUser")
		assert(sshUser != null)

		target=sshUser+"@"+host
		println("Starting process for " + target)
		processData = SymDict(target)

		process = SpawnProcess(processData, {
			start=currentTimeMillis
			APTUpdate:run(target)
			end=currentTimeMillis
			println("### time=" + (end-start) + " ms")
		})
		out(process)
	| _-> process
		target=process.data.target
		exitValue=process.wait.exitValue
		output=process.output

		println("Saving data for " + target)
			
		obj=SymDict(target,exitValue,output)
		
		Db2Obj:AddObject("Ansible.APTUpdateUpgrade",obj)
/AptUpgrade


		
	
