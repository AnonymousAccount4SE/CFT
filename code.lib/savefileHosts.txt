''# Readme
<<<<<< EOF
Parsing "Ansible" text format looking like this:

# This is a comment

[Auto.reboot=yes]
*.v 
s*.s   [no]



>>>>>> EOF
/Readme

# Parse text lines. Returns dictionary with 'data' pointing at the
# actual data structure, and then the following lambdas, which are
# used as follows:
#
#    LallHosts.call
#    LallFields.call
#    Lget.call(elementName,fieldName,defaultValue?)
#    Ldump.call
#
# The data dictionary has keys for all elements, and under each
# is a Dict with the settings for that element.
# --
	file = Lib:DirPrivate.file("Hosts.txt") 
	data = Dict
		
	currProp=null
	currPropValue=null

	LFilter = Lambda{
		P(1,List) => list
		P(2) => regex
		list->s assert(regex.match(s)) out(s)
	}
	LApply = Lambda {
		P(1) => data
		P(2) => entities
		P(3) => name
		P(4) => value

		entities->e
			#println(e + "." + name + "=" + value)
			data.get(e,Dict).set(name,value)
	}

	file.read->line
		reject(line.trim.startsWith("#"))
		reject(line.trim=="")
		if (line.trim.startsWith("[")) {
			# property definition with default value
			line.after("[").before("]").split("=").push(2) => currProp =>currPropValue 
		} else {
			# data line with optional exception
			line.before("[").trim => entity
			if (entity.contains("*")) {
				regex=Glob(entity,false).regex
			
				# keys of data dict are the entities that we filter
				entities=LFilter.call(data.keys,regex)
			} else {
				entities=List(entity)
			}

			# is there an exception?
			redef=line.after("[").before("]").trim
			if(redef != "") {
				LApply.call(data, entities,currProp, redef)
			} else {
				LApply.call(data, entities,currProp, currPropValue)
			}
										
		}
	|

	# Create return value with lambdas for analyzing the data
	# --
	Dict
		.set("data",data)
		.set("LallHosts",Lambda{
			self.data.keys
		})
		.set("LallFields", Lambda{
			self.data.keys->key 
				self.data.get(key).keys->field
					out (field)
			| _.unique.sort
		})
		.set("Lget", Lambda{
			P(1)=>host
			P(2)=>field
			P(3)=>defaultValue

			result=defaultValue

			if (self.data.has(host)) {
				e=self.data.get(host)
				if (e.has(field)) {
					x=e.get(field)
					if (x != null) result=x
				}
			}

			result
		})
		.set("Ldump",Lambda{
			self.data.keys->host
				self.data.get(host).keys->field
					value=self.data.get(host).get(field)
					out(List(host,field,value))
		})
		.set("Lhas", Lambda{
			P(1)=>host
			P(2)=>field
			P(3)=>value
			ok=false
			if (self.data.has(host)) {
				e=self.data.get(host)
				if (e.has(field)) {
					if (e.get(field)==value) ok=true
				}
			}
			ok
		})
/Parse



# Verify all hosts have copy of SSH key
# --
	data=Parse
	data.LallHosts.call->host
		sshUser=data.Lget.call(host,"SSHUser")
		assert(sshUser != null)
		target=sshUser+"@"+host
		println("------ " + target)
		Dir.run("ssh-copy-id",target)
/CheckSSHKeys




# Test SSH (and dns)
# ---
	HostData=Hosts:Parse
	HostData.LallHosts.call.sort->host
		assert(HostData.Lget.call(host, "OS")=="linux")
		       
        HostData.Lget.call (host, "SSHUser") =>sshUser
        assert(sshUser != null)

        target=sshUser+"@"+host
        
        ctx=SymDict(target)
        proc=SpawnProcess(ctx,{
			ok = SSH:HostOkSSH(target)
	        status = if (ok,"OK","-")
	        println(target + ": " + status)
	        status
	    })
	    out(proc)
	| _->proc
		status = proc.wait.exitValue
		report(proc.data.target, status)
/HostsStatus
		


# Run APT Update + upgrade on one host
# --
	P(1,Input("target").get)=>target
	println("Calling APTUpdate:run for target="+target)
	APTUpdate:run(target,3)
/AptUpdate


# Run APT Update / upgrade on hosts
# --
	data=Parse
	
	allHosts=data.LallHosts
	lget = data.Lget


	mon=Util:ProcessMonitor
	
	data.LallHosts.call->host

		println("* " + host)

		pm=data.Lget.call(host,"PackageManager")
		assert(pm=="apt")
		println("*   pm==apt ok")

		sshUser=data.Lget.call(host,"SSHUser")
		assert(sshUser != null)
		println("*   sshUser != null ok")

		target=sshUser+"@"+host
		processData = SymDict(target)

		# Block until less than given number of active processes
		mon.Lwait.call(8)
		
		println("*   starting process for " + target)
		process = SpawnProcess(processData, {
			start=currentTimeMillis
			AptUpdate(target)
			end=currentTimeMillis
			println("### time=" + (end-start) + " ms")
		})
		mon.Ladd.call(process)
		
		out(process)
	| => processList

	Lib:Header("Press ENTER to await process results")
	readLine

	processList -> process
		
		target=process.data.target
		Lib:Header("Waiting for " + target)
		
		exitValue=process.wait.exitValue
		output=process.output

		println("exitValue=" + exitValue)
		Inner{
			output->line println("OUT: " + line)
		}
		type="APTUpdateUpgrade"
		
		obj=SymDict(target,exitValue,output,type)
		
		Db2Obj:AddObject("Ansible.APTUpdateUpgrade",obj)
/AptUpdateAll


		
	

# Decide if debian host should be booted
# --
	P(1)=>target
	SSH:run(target,"ls /var/run/reboot-required",true).exitCode == 0
/DebianHostNeedsReboot



# Display hosts that should be rebooted
	HostData = Hosts:Parse
	HostData.LallHosts.call.sort->host
        assert(HostData.Lhas.call (host,"OSFamily","debian"))
        HostData.Lget.call (host, "SSHUser") =>sshUser

        sshUser+"@"+host =>target
        HostData.Lhas.call (host, "Auto.reboot", "yes") =>allowReboot
        
		process = SpawnProcess(SymDict(host,target,allowReboot),{
	        SSH:HostOkSSH (target) =>hostOk
	        if (!hostOk) {
	            println(host + ": -offline-")
	        } else {
		        DebianHostNeedsReboot(target) =>x
		        
		        if (x && allowReboot) {
		        	println(host + ": rebooting now")
		        	SSH:sudo(target,"reboot",true)
		        } else {
			        println(host + ": " + if(x,"NEEDS REBOOT","ok"))
			    }
	    	}
    	})
    	out(process)
    | _->process
    	process.wait
    	process.output->line println(line)
    	    
/NeedReboot


# Update or install CFT
# --
	P(1)=>host
	P(2)=>sshUser

	println("host=" + host)
	println("sshUser=" + sshUser)

	tMark=Sys.scriptName+".lastrun."+host
	if (Util:HasTimedOut(tMark)) {
		println("# host " + host)

	    if (!SSH:HostOk (host)) {
	    	println("Host unreachable")
		} else {	    
		    sshUser+"@"+host =>target
		    println("Updating " + target)
		    
		    assert(SSH:HostOkSSH (target))

		    Java:VerifyCFT (target)
		    Util:SetTimeMark(tMark)
		}
	} else {
		println("Last checked at " + Util:GetTimeMark(tMark).fmt)
	}
/UpdateCFT


# Update CFT all
# --
	mon=Util:ProcessMonitor
	
	HostData=Hosts:Parse
	HostData.LallHosts.call.sort->host
		assert(HostData.Lhas.call(host,"Install.CFT","1"))
		sshUser=HostData.Lget.call (host,"SSHUser")
		assert(sshUser != null)

		mon.Lwait.call(4)
		println("Spawning process for host="+host)
		
		ctx=SymDict(host,sshUser)
		process=SpawnProcess(ctx, UpdateCFT(host, sshUser))

		mon.Ladd.call(process)
		
		out(process)
	| _->process
		Lib:Header("Waiting for " + process.data.host)
		process.wait
		Inner {process.output->line println(line)}
/UpdateCFTAll



P(1)=>host
P(2)=>target
P(3,"mpstat") => command
P(4)=>lineFilter
	if (SSH:HostOk (host)) Inner {

	    println("---- " + host + " ----")
	    SSH:run (target, "which mpstat", true).get("exitCode") != 0 =>install
	    if(install) {
	        println("    (installing sysstat)")
	        SSH:sudo (target, "apt-get -y install sysstat")
	    }
	    SSH:run (target, command).get("stdout")->line
	    	assert(lineFilter == null || line.contains(lineFilter))
	        report(List(host,line))
	} 
/SysStat


# View host status
P(1,"mpstat") => command
P(2)  => lineFilter

	HostData=Hosts:Parse
	HostData.LallHosts.call->host

		HostData.Lget.call(host, "OS") => os
		assert(os=="linux")
        
        HostData.Lget.call(host, "SSHUser") =>sshUser
        assert(sshUser != null)
        
        sshUser+"@"+host =>target

        ctx=SymDict(host,target,command,lineFilter)
        proc=SpawnProcess(ctx,
        	SysStat(host,target,command,lineFilter)
        )
		out(proc)
	| _-> proc
		proc.wait
		Inner {
			#proc.output->line println(line) |
			proc.exitValue->line println(line)
		}		
/SysStatAll


SysStatAll("mpstat")
/MPStat

SysStatAll("iostat")
/IOStat





# Update database with list of debian hosts
# ---
	HostData=Hosts:Parse
	HostData.LallHosts.call->host
		assert(HostData.Lget.call(host, "OSFamily")=="debian")
		       
        HostData.Lget.call (host, "SSHUser") =>sshUser
        assert(sshUser != null)

        target=sshUser+"@"+host

        data=SymDict(host,sshUser,target)
        out(data)
/GetDebianHostsInfo







# Configure /etc/systemd/resolved.conf
# ---
	HostData=Hosts:Parse
	file=Lib:TmpFile("resolved_conf")
	file.create(resolved_conf)
	
	HostData.LallHosts.call->host
		assert(HostData.Lget.call(host, "OSFamily")=="debian")
		       
        HostData.Lget.call (host, "SSHUser") =>sshUser
        assert(sshUser != null)

		Lib:Header(host)

        target=sshUser+"@"+host
        if (!SSH:HostOkSSH(target)) {
        	println("- Host unreachable - skipping target " + target)
        	assert(false)
        }

		SSH:copy(file, target, "./resolved_conf")
		SSH:sudo(target,"cp ./resolved_conf /etc/systemd/resolved.conf")
		println("- Updated file /etc/systemd/resolv.conf")
	|
	file.delete
	
/FixResolve


# /etc/systemd/resolved.conf
# --
<<<<< EOF
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.
#
# Entries in this file show the compile time defaults.
# You can change settings by editing this file.
# Defaults can be restored by simply deleting this file.
#
# See resolved.conf(5) for details

[Resolve]
DNS=10.0.0.3 10.0.0.4
#FallbackDNS=
#Domains=
#LLMNR=no
#MulticastDNS=no
#DNSSEC=no
#Cache=yes
#DNSStubListener=yes
>>>>> EOF
/resolved_conf

Parse.Ldump.call
/dump
