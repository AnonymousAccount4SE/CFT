# Readme
<<<<<<<<<<<<<<<< EOF
Testing that local blocks scope and operation is correct (v2.4.0)
Also verifying that inner blocks and lambdas do not affect outer loop logic

2021-03-13 RFO
>>>>>>>>>>>>>>>> EOF
/Readme



a={1+1}
println("a="+a)
/t1

t1=="a=2"
/Test01_SumInsideLocalBlock




Inner{1+1}
/t1b

t1b==2
/Test01_SumInsideInnerBlock




{List(1,2,3)->x out(x+10)}
/t2

t2.concat("-")=="11-12-13"
/Test02_ListIterInLocalBlock




{List(1,2,3)->x out(x+10) | _.sum}
/t3

tryCatch(t3).ok == false
/Test03_PipeInsideLocal_ShouldFail




Inner {List(1,2,3)->x out(x+10) | _.sum}
/t4

t4==36
/Test04_PipeInsideInner




if(true) {
	1
} else {2
}
/t5

t5==1
/Test05_IfWithLocalBlocks



P(1)=>bool
if(bool) {
	List(1,2,3)->x out(x)
} else {
	1
}
/t5b

t5b(true).concat("-")=="1-2-3" && t5b(false)==1
/Test05_AlternateListOrValue




List(1,2,3)->x
	out(x)
	if (x%2==0) {
		out("even")
	} else {
		out("odd")
	}
/t6

t6.concat=="1odd2even3odd"
/Test06_ConditionaOutLocal




List(1,2,3)->x
	out(x)
	if (x%2==0) Inner {
		out("even")
	} else {
		out("odd")
	}
/t6b

t6b.concat=="1odd23odd"
/Test06_ConditionaOutInnerLocal






List(1,2,3)->x 
	if (x%2==0) {
		assert(false)
	}
	out(x)
/t7

t7.concat("-")=="1-3"
/Test07_ConditionalAssertFalseLocal




List(1,2,3)->x
	if (x%2==0) Inner {
		List(4,5,6) -> y assert(false)
	}
	out(x)
/t8

t8.concat("-")=="1-2-3"
/Test08_OuterLoopUnaffectedByInnerBlockLoop





# 2021-08-27 Fixed


List(1,2,3)->x
	if (x%2==0) Inner {
		assert(false)
	}
	out(x)
/t9

t9.concat("-")=="1-2-3"
/Test09_OuterLoopUnaffectedByInnerBlockAssert





List(1,2,3)->x
	Lambda{assert(false)}.call
	out(x)
/t10

t10.concat("-")=="1-2-3"
/Test10_OuterLoopUnaffectedByLambdaAssert





# ------------------------------------------
# Test 11 - 2021-04-07 lambda file sort bug. 
#   Does not handle pipe correctly in Lambda code - the two should to the same!
#   2021-08-27 Fixed
# ------------------------------------------


# Lambda version
	P(1,Dir.files)=>files 
	L=Lambda{
		List(1,2,3)->x out(x)
		|
		"abc".chars->x out(x)
	}
	L.call()
/t11_lambda


# function version
	List(1,2,3)->x out(x)
	|
	"abc".chars->x out(x)
/t11_function



# Lambda output should match function output
	t11_lambda.concat==t11_function.concat
/Test11_lambda_pipe_2021_04_07




# ------------------------------------------
# Possibly the same problem as in Test11
# Except here we get a java exception (ConcurrentModificationException)
#   2021-08-27 Fixed
# ------------------------------------------

# If an Inner is like a function, the below should return true, but it fails with exception
	Inner {
		List(4,1,3,2)->i out(Int(i,i)) | _.sort->x out(x.data)
	}.concat
/t12_asInner


# Function implementation
	List(4,1,3,2)->i out(Int(i,i)) | _.sort->x out(x.data) | _.concat
/t12_asFunction


# Inner with loop PIPE loop
	tryCatch(t12_asInner) => res
	if (res.ok, res.result==t12_asFunction, "Exception")
/Test12_Inner_With_loop_pipe_loop





# Run all TestX
# --
	Sys.functions.sort->f
		assert(f.startsWith("Test"))
		report(f,eval(f))
/RunAll



# -----------------------
# 2021-09-07
# Inner loop report output list 
# spilling over to outer scope
#
# Not a problem when replacing report() with out() - (See Test13b)
# -----------------------

# Function
# --
	List(1,2,3) => data
	Inner {
		data->x report("i"+x)
	} -> line
		out("x"+line)
		# --
		# Should return list of "x"+line
		# Verify test returns true by replacing report() with out() above
/t13

# Inner loop report output problem
# --
	t13 => result
	getType(result)=="List" && result.concat=="xi1xi2xi3"
/Test13_Inner_report_output_propagation




# Same as Test13 but with "out" instead of "report".
# report() should work like out(), but it doesn't
# ---

# Function
# --
	List(1,2,3) => data
	Inner {
		data->x out("i"+x)
	} -> line
		out("x"+line)
		# --
		# Should return list of "x"+line
		# Verify test returns true by replacing report() with out() above
/t13b

# Inner loop report output problem
# --
	t13b => result
	getType(result)=="List" && result.concat=="xi1xi2xi3"
/Test13b_Inner_out_output_propagation










# Function1
# --
	{}
/t14_f1


# Function2
# --
	1
	{}
/t14_f2


# Local block return value confusion
# --
# Initially thought that t14_f1 and t14_f2 should return the same, 
# as if an empty local block is an expression, but of course it is
# not. Instead an empty local block means EXACTLY the same 
# as NO CODE, and so ... :-)
# --
	t14_f1 == null && t14_f2 == 1
/Test14_local_block_return_value







# Inner block return values
# --
	2
	{3}
/t15


# Local block return value
# --
	t15==3
/Test15_local_block_return_value







# Inner block return values
# --
	2
	{null}
/t16


# Local block return value
# --
	t16==null
/Test16_local_block_return_value




# Lib.Java
# 2021-09-08
# This code exercises key functionality: class lookup, constructor lookup and call with params, 
# method lookup and call with params, and conversion of values as parameters and return value from function
#
Lib.Java.forName("java.lang.String") => String
String.getConstructor(String).call(Lib.Java.String("test")) => obj
String.getConstructor(String).call(Lib.Java.String("123")) => obj2
Lib.Java.Object(obj2) => paramObj
String.getMethod("concat",String).call(obj,paramObj).value
/t17



t17=="test123"
/Test17_Lib_Java_interface






# String .mergeExpr
# --

List(List(List(1)))
/t18

"a<<t18>>b".mergeExpr.concat("|")=="a1b"
/Test18_mergeExpr_list1_nested




List(1,2)
/t19

"a<<t19>>b".mergeExpr.concat("|")=="a1|2b"
/Test19_mergeExpr_list2





List(1,2,3)
/t20

"a<<t20>>b".mergeExpr.concat("|")=="a1|2|3b"
/Test20_mergeExpr_list3



"a<<null>>b".mergeExpr.concat("|")=="ab"
/Test21_mergeExpr_null




"a<<List(List(null))>>b".mergeExpr.concat("|")=="ab"
/Test22_mergeExpr_null_nested



f="X" "a<<f>>b".mergeExpr.concat("|")=="aXb"
/Test23_mergeExpr_localVariable




"abc".mergeExpr.concat("|")=="abc"
/Test24_mergeExpr_noExpr



"abc<<d".mergeExpr.concat("|")=="abc<<d"
/Test25_mergeExpr_incomplete_expr



"abc(5+5)def".mergeExpr("(",")").concat("|")=="abc10def"
/Test26_mergeExpr_alternative_markup




"a<<List(1,2,3)->x out(x+1)>>b".mergeExpr.concat("|")=="a2|3|4b"
/Test27_mergeExpr_iteration_ok


# PIPE not allowed - use a lambda :-)
#
tryCatch("a<<List(1,2,3)->x out(x+1) | _.concat>>b".mergeExpr).ok==false
/Test28_mergeExpr_iteration_pipe_invalid



# But Inner blocks are allowed, and they can contain PIPE.
#

List(1,2,3)
/t28b

'A<< Inner{t28b->x out(x+1) | _.sum}+1 >>B'.mergeExpr.concat("|")=="A10B"
/Test28b_MergeExpr_iteration_pipe_inside_inner



# SymDict

a=5 SymDict(a).get("a")==5
/Test29_Symdict_basic

a=List(1,2,3) SymDict(a).get("a").concat("|")=="1|2|3"
/Test30_Symdict_list



