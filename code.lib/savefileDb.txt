# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
<<<<<<<< EOF
----------------------------------------------
Simple key/value database organized into 
multiple collections. 
----------------------------------------------
>>>>>>>> EOF
/Readme



# DbDir is "Db" under Sys.homeDir
    Sys.homeDir.sub("Db")=d
    ?(!d.exists, d.create)
    d
/DbDir


# Get db-file for collection (optional) - created with valid
    P(1,"default")=collection
    DbDir.file(collection+".txt") =file
    ?(!file.exists, file.create("# Created " + Date.fmt))
    file
/DbFile

# Add value to database
P(1)=key
P(2)=val
P(3,"default")=collection
    Lambda { P(1)=val syn(val) } =x
    error(x.?call(val)==false, "Value must be synthesizable")
    Dict
        .set("key",key)
        .set("value",val)
    =dict
    DbFile(collection).append(syn(dict))
    true
/Add

# List database
P(1,"default")=collection
    DbFile(collection).read->line
        reject(line.startsWith("#"))
        eval(line)=dict
        report(dict.key, dict.value)
/Show

# Find all data objects for key
P(1)=key
P(2,"default")=collection
    DbFile(collection).read->line
        reject(line.startsWith("#"))
        eval(line) =dict
        assert(dict.key==key)
        out(dict.value)
/FindAll

# Get last object for key
P(1)=key
P(2,"default")=collection
P(3)=defaultValue
    FindAll(key,collection).last =x
    ?(x != null, x, defaultValue)
/Get





# Delete all data objects for key
P(1)=key
P(2,"default")=collection
    DbFile(collection).read->line
        condOut(line.startsWith("#"), line)
        reject(line.startsWith("#"))
        
        eval(line) =dict
        reject(dict.key==key)
        out(line)
| _=lines
    DbFile(collection).create(lines)
/Delete


# Delete all but last data object for key
P(1)=key
P(2,"default")=collection
    Get(key,collection) =last
    Delete(key,collection)
    Add(key,last,collection)
/Purge


# Set temp value (in memory only)
P(1)=key
P(2)=value
P(3,"default")=collection
    ?(Val("temp")==null, Inner{ValDef("temp",Dict) }) 
    Val("temp").get(collection,Dict).set(key,value)
    true
/TempSet

# Set temp value (in memory only)
P(1)=key
P(2,"default")=collection
    ?(Val("temp")==null, Inner{ValDef("temp",Dict) }) 
    Val("temp").get(collection,Dict) =coll
    ?(coll.has(key), coll.get(key,null), null)
/TempGet

# Show temp values
    ?(Val("temp")==null, Inner{ValDef("temp",Dict) })
    Val("temp").keys->collection
        Val("temp").get(collection).keys->name
            report(collection, name, Val("temp").get(collection).get(name))
/TempShow


# Get or enter string value if missing
P(1)=key
P(2)=prompt
P(3)=collection
    Get(key,collection) =val
    ?(val==null,Inner{
        readLine(prompt) =val
        Add(key,val,collection)
    })
    val
/GetOrEnter


# Get, enter or confirm string value 
P(1)=key
P(2)=prompt
P(3)=collection
    Get(key,collection) =val
    ?(val==null, Inner{
        readLine(prompt) =val
        Add(key,val,collection)
    },Inner{
        call "Lib:ReadValue" (prompt, val) =val2
        ?(val2 != val, Add(key,val2,collection))
        val2 =val
    })
    val
/GetEnterOrConfirm


        
    



