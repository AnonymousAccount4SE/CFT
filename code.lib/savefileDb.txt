# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
<<<<<<<< EOF
----------------------------------------------
Simple key/value database organized into 
multiple collections, persisted to files under
Lib:DirPrivate.sub("Db")

So primitive it hurts, but serves for now.
----------------------------------------------
>>>>>>>> EOF
/Readme



# DbDir is "Db" under Sys.homeDir
    Lib:DirPrivate.sub("Db") =>d
    if(!d.exists) d.create
    d
/DbDir


# Get db-file for collection (optional) - created with valid
    P(1,"default") =>collection
    DbDir.file(collection+".txt") =>file
    if(!file.exists) file.create("# Created " + Date.fmt)
    file
/DbFile

# Add value to database
P(1) =>key
P(2) =>val
P(3,"default") =>collection
    Lambda { P(1) =>val syn(val) } =>x
    error(x.?call(val)==false, "Value must be synthesizable")
    Dict
        .set("key",key)
        .set("value",val)
    =>dict
    DbFile(collection).append(syn(dict))
    true
/Add

# List database
P(1,"default") =>collection
    DbFile(collection).read->line
        reject(line.startsWith("#"))
        eval(line) =>dict
        report(dict.key, dict.value)
/Show

# Find all data objects for key
P(1) =>key
P(2,"default") =>collection
    DbFile(collection).read->line
        reject(line.startsWith("#"))
        eval(line) =>dict
        assert(dict.key==key)
        out(dict.value)
/FindAll


# Get last object for key
P(1) =>key
P(2,"default") =>collection
P(3) =>defaultValue
    FindAll(key,collection).last =>x
    if(x != null, x, defaultValue)
/Get





# Delete all data objects for key
P(1) =>key
P(2,"default") =>collection
    DbFile(collection).read->line
        condOut(line.startsWith("#"), line)
        reject(line.startsWith("#"))
        
        eval(line) =>dict
        reject(dict.key==key)
        out(line)
| _ =>lines
    DbFile(collection).create(lines)
/Delete


# Delete all but last data object for key
P(1) =>key
P(2,"default") =>collection
    Get(key,collection) =>last
    Delete(key,collection)
    Add(key,last,collection)
/Purge


# Purge all keys for all collection
	allCollections=List
    Inner {
        DbDir.files(Glob("*.txt"))->f
            out(f.name.before(".txt"))
        | _.sort =>allCollections
    } 

	allCollections->collection
		println("Purging " + collection)
		GetCollectionKeys(collection)->key
			Purge(key,collection)
/PurgeAll
	


# Set temp value (in memory only)
P(1) =>key
P(2) =>value
P(3,"default") =>collection
    if(Val("temp")==null) {
        ValDef("temp",Dict)
    } 
    Val("temp").get(collection,Dict).set(key,value)
    true
/TempSet

# Set temp value (in memory only)
P(1) =>key
P(2,"default") =>collection
    if(Val("temp")==null) {
        ValDef("temp",Dict)
    } 
    Val("temp").get(collection,Dict) =>coll
    if(coll.has(key), coll.get(key,null), null)
/TempGet

# Show temp values
    if(Val("temp")==null) {
        ValDef("temp",Dict) 
    }
    Val("temp").keys->collection
        Val("temp").get(collection).keys->name
            report(collection, name, Val("temp").get(collection).get(name))
/TempShow


# Get or enter string value if missing
P(1) =>key
P(2) =>prompt
P(3) =>collection
    Get(key,collection) =>val
    if(val==null) {
        readLine(prompt) =>val
        Add(key,val,collection)
    }
    val
/GetOrEnter


# Get, enter or confirm string value 
P(1) =>key
P(2) =>prompt
P(3) =>collection
    Get(key,collection) =>val
    if(val==null) {
        readLine(prompt) =>val
        Add(key,val,collection)
    } else {
        Lib:ReadValue (prompt, val) =>val2
        if(val2 != val, Add(key,val2,collection))
        val2 =>val
    }
    val
/GetEnterOrConfirm




# Find all keys in collection
P(1,"default") =>collection
    DbFile(collection).read->line
        reject(line.startsWith("#"))
        eval(line) =>dict
        out(dict.key)
    | _.unique.sort
/GetCollectionKeys



# Ultra primitive Db GUI - for maintaining data sets
#
P(1) => collection
if (collection == null) {
    Inner {
        DbDir.files(Glob("*.txt"))->f
            out(f.name.before(".txt"))
        | _.sort.concat(" ") =>allCollections
    } 
    println
    println("* Defined collections: " + allCollections)
    println
    collection = readLine("Collection name?") 
}
loop
    println
    Lib:Header ("Collection: " + collection)
    
    Inner {
        GetCollectionKeys(collection)->key
            s=(key+"                     ").sub(0,20)
            println("   " + s + " : " + Get(key,collection))
    }
    println
    cmd = readLine("Command? (s=set/d=delete/D=deleteMany/q=quit)")
    break(cmd.startsWith("q"))
    
    if (cmd.startsWith("s")) {
        readLine("key")=>key
        readLine("value")=>value
        Add(key,value,collection)
        Purge(key,collection)  # remove previous values for key
        
    } else if (cmd.startsWith("d")) {
        readLine("delete key")=>key
        Delete(key,collection)
        
    } else if (cmd.startsWith("D")) {
        readLine("delete keys starting with") => x
        if (x != "") Inner {
            GetCollectionKeys(collection)->key 
                assert(key.startsWith(x))
                Delete(key,collection)
        }
        
    } else {
        println("%% Unknown command")
    }
        
/GUI
    
    


        
    



